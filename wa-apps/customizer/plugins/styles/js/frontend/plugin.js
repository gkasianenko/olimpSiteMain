/*!
 * styles v1.4.2
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('vue'), require('vue-i18n'), require('uikit'), require('vuex'), require('uikit-util')) :
	typeof define === 'function' && define.amd ? define(['vue', 'vue-i18n', 'uikit', 'vuex', 'uikit-util'], factory) :
	(global = global || self, global.VueCustomizerstyles = factory(global.Vue, global.VueI18n, global.UIkit, global.Vuex, global.UIkit.util));
}(this, (function (Vue$1, VueI18n, uikit, vuex, uikitUtil) { 'use strict';

	Vue$1 = Vue$1 && Object.prototype.hasOwnProperty.call(Vue$1, 'default') ? Vue$1['default'] : Vue$1;
	VueI18n = VueI18n && Object.prototype.hasOwnProperty.call(VueI18n, 'default') ? VueI18n['default'] : VueI18n;

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var codemirror = createCommonjsModule(function (module, exports) {
	  // CodeMirror, copyright (c) by Marijn Haverbeke and others
	  // Distributed under an MIT license: https://codemirror.net/LICENSE
	  // This is CodeMirror (https://codemirror.net), a code editor
	  // implemented in JavaScript on top of the browser's DOM.
	  //
	  // You can find some technical background for some of the code below
	  // at http://marijnhaverbeke.nl/blog/#cm-internals .
	  (function (global, factory) {
	     module.exports = factory() ;
	  })(commonjsGlobal, function () {
	    // detected are enabled based on userAgent etc sniffing.

	    var userAgent = navigator.userAgent;
	    var platform = navigator.platform;
	    var gecko = /gecko\/\d/i.test(userAgent);
	    var ie_upto10 = /MSIE \d/.test(userAgent);
	    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
	    var edge = /Edge\/(\d+)/.exec(userAgent);
	    var ie = ie_upto10 || ie_11up || edge;
	    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
	    var webkit = !edge && /WebKit\//.test(userAgent);
	    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
	    var chrome = !edge && /Chrome\//.test(userAgent);
	    var presto = /Opera\//.test(userAgent);
	    var safari = /Apple Computer/.test(navigator.vendor);
	    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
	    var phantom = /PhantomJS/.test(userAgent);
	    var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
	    var android = /Android/.test(userAgent); // This is woefully incomplete. Suggestions for alternative methods welcome.

	    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
	    var mac = ios || /Mac/.test(platform);
	    var chromeOS = /\bCrOS\b/.test(userAgent);
	    var windows = /win/i.test(platform);
	    var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);

	    if (presto_version) {
	      presto_version = Number(presto_version[1]);
	    }

	    if (presto_version && presto_version >= 15) {
	      presto = false;
	      webkit = true;
	    } // Some browsers use the wrong event properties to signal cmd/ctrl on OS X


	    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
	    var captureRightClick = gecko || ie && ie_version >= 9;

	    function classTest(cls) {
	      return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
	    }

	    var rmClass = function (node, cls) {
	      var current = node.className;
	      var match = classTest(cls).exec(current);

	      if (match) {
	        var after = current.slice(match.index + match[0].length);
	        node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	      }
	    };

	    function removeChildren(e) {
	      for (var count = e.childNodes.length; count > 0; --count) {
	        e.removeChild(e.firstChild);
	      }

	      return e;
	    }

	    function removeChildrenAndAdd(parent, e) {
	      return removeChildren(parent).appendChild(e);
	    }

	    function elt(tag, content, className, style) {
	      var e = document.createElement(tag);

	      if (className) {
	        e.className = className;
	      }

	      if (style) {
	        e.style.cssText = style;
	      }

	      if (typeof content == "string") {
	        e.appendChild(document.createTextNode(content));
	      } else if (content) {
	        for (var i = 0; i < content.length; ++i) {
	          e.appendChild(content[i]);
	        }
	      }

	      return e;
	    } // wrapper for elt, which removes the elt from the accessibility tree


	    function eltP(tag, content, className, style) {
	      var e = elt(tag, content, className, style);
	      e.setAttribute("role", "presentation");
	      return e;
	    }

	    var range;

	    if (document.createRange) {
	      range = function (node, start, end, endNode) {
	        var r = document.createRange();
	        r.setEnd(endNode || node, end);
	        r.setStart(node, start);
	        return r;
	      };
	    } else {
	      range = function (node, start, end) {
	        var r = document.body.createTextRange();

	        try {
	          r.moveToElementText(node.parentNode);
	        } catch (e) {
	          return r;
	        }

	        r.collapse(true);
	        r.moveEnd("character", end);
	        r.moveStart("character", start);
	        return r;
	      };
	    }

	    function contains(parent, child) {
	      if (child.nodeType == 3) // Android browser always returns false when child is a textnode
	        {
	          child = child.parentNode;
	        }

	      if (parent.contains) {
	        return parent.contains(child);
	      }

	      do {
	        if (child.nodeType == 11) {
	          child = child.host;
	        }

	        if (child == parent) {
	          return true;
	        }
	      } while (child = child.parentNode);
	    }

	    function activeElt() {
	      // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
	      // IE < 10 will throw when accessed while the page is loading or in an iframe.
	      // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
	      var activeElement;

	      try {
	        activeElement = document.activeElement;
	      } catch (e) {
	        activeElement = document.body || null;
	      }

	      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
	        activeElement = activeElement.shadowRoot.activeElement;
	      }

	      return activeElement;
	    }

	    function addClass(node, cls) {
	      var current = node.className;

	      if (!classTest(cls).test(current)) {
	        node.className += (current ? " " : "") + cls;
	      }
	    }

	    function joinClasses(a, b) {
	      var as = a.split(" ");

	      for (var i = 0; i < as.length; i++) {
	        if (as[i] && !classTest(as[i]).test(b)) {
	          b += " " + as[i];
	        }
	      }

	      return b;
	    }

	    var selectInput = function (node) {
	      node.select();
	    };

	    if (ios) // Mobile Safari apparently has a bug where select() is broken.
	      {
	        selectInput = function (node) {
	          node.selectionStart = 0;
	          node.selectionEnd = node.value.length;
	        };
	      } else if (ie) // Suppress mysterious IE10 errors
	      {
	        selectInput = function (node) {
	          try {
	            node.select();
	          } catch (_e) {}
	        };
	      }

	    function bind(f) {
	      var args = Array.prototype.slice.call(arguments, 1);
	      return function () {
	        return f.apply(null, args);
	      };
	    }

	    function copyObj(obj, target, overwrite) {
	      if (!target) {
	        target = {};
	      }

	      for (var prop in obj) {
	        if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
	          target[prop] = obj[prop];
	        }
	      }

	      return target;
	    } // Counts the column offset in a string, taking tabs into account.
	    // Used mostly to find indentation.


	    function countColumn(string, end, tabSize, startIndex, startValue) {
	      if (end == null) {
	        end = string.search(/[^\s\u00a0]/);

	        if (end == -1) {
	          end = string.length;
	        }
	      }

	      for (var i = startIndex || 0, n = startValue || 0;;) {
	        var nextTab = string.indexOf("\t", i);

	        if (nextTab < 0 || nextTab >= end) {
	          return n + (end - i);
	        }

	        n += nextTab - i;
	        n += tabSize - n % tabSize;
	        i = nextTab + 1;
	      }
	    }

	    var Delayed = function () {
	      this.id = null;
	      this.f = null;
	      this.time = 0;
	      this.handler = bind(this.onTimeout, this);
	    };

	    Delayed.prototype.onTimeout = function (self) {
	      self.id = 0;

	      if (self.time <= +new Date()) {
	        self.f();
	      } else {
	        setTimeout(self.handler, self.time - +new Date());
	      }
	    };

	    Delayed.prototype.set = function (ms, f) {
	      this.f = f;
	      var time = +new Date() + ms;

	      if (!this.id || time < this.time) {
	        clearTimeout(this.id);
	        this.id = setTimeout(this.handler, ms);
	        this.time = time;
	      }
	    };

	    function indexOf(array, elt) {
	      for (var i = 0; i < array.length; ++i) {
	        if (array[i] == elt) {
	          return i;
	        }
	      }

	      return -1;
	    } // Number of pixels added to scroller and sizer to hide scrollbar


	    var scrollerGap = 50; // Returned or thrown by various protocols to signal 'I'm not
	    // handling this'.

	    var Pass = {
	      toString: function () {
	        return "CodeMirror.Pass";
	      }
	    }; // Reused option objects for setSelection & friends

	    var sel_dontScroll = {
	      scroll: false
	    },
	        sel_mouse = {
	      origin: "*mouse"
	    },
	        sel_move = {
	      origin: "+move"
	    }; // The inverse of countColumn -- find the offset that corresponds to
	    // a particular column.

	    function findColumn(string, goal, tabSize) {
	      for (var pos = 0, col = 0;;) {
	        var nextTab = string.indexOf("\t", pos);

	        if (nextTab == -1) {
	          nextTab = string.length;
	        }

	        var skipped = nextTab - pos;

	        if (nextTab == string.length || col + skipped >= goal) {
	          return pos + Math.min(skipped, goal - col);
	        }

	        col += nextTab - pos;
	        col += tabSize - col % tabSize;
	        pos = nextTab + 1;

	        if (col >= goal) {
	          return pos;
	        }
	      }
	    }

	    var spaceStrs = [""];

	    function spaceStr(n) {
	      while (spaceStrs.length <= n) {
	        spaceStrs.push(lst(spaceStrs) + " ");
	      }

	      return spaceStrs[n];
	    }

	    function lst(arr) {
	      return arr[arr.length - 1];
	    }

	    function map(array, f) {
	      var out = [];

	      for (var i = 0; i < array.length; i++) {
	        out[i] = f(array[i], i);
	      }

	      return out;
	    }

	    function insertSorted(array, value, score) {
	      var pos = 0,
	          priority = score(value);

	      while (pos < array.length && score(array[pos]) <= priority) {
	        pos++;
	      }

	      array.splice(pos, 0, value);
	    }

	    function nothing() {}

	    function createObj(base, props) {
	      var inst;

	      if (Object.create) {
	        inst = Object.create(base);
	      } else {
	        nothing.prototype = base;
	        inst = new nothing();
	      }

	      if (props) {
	        copyObj(props, inst);
	      }

	      return inst;
	    }

	    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

	    function isWordCharBasic(ch) {
	      return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
	    }

	    function isWordChar(ch, helper) {
	      if (!helper) {
	        return isWordCharBasic(ch);
	      }

	      if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
	        return true;
	      }

	      return helper.test(ch);
	    }

	    function isEmpty(obj) {
	      for (var n in obj) {
	        if (obj.hasOwnProperty(n) && obj[n]) {
	          return false;
	        }
	      }

	      return true;
	    } // Extending unicode characters. A series of a non-extending char +
	    // any number of extending chars is treated as a single unit as far
	    // as editing and measuring is concerned. This is not fully correct,
	    // since some scripts/fonts/browsers also treat other configurations
	    // of code points as a group.


	    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

	    function isExtendingChar(ch) {
	      return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
	    } // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.


	    function skipExtendingChars(str, pos, dir) {
	      while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
	        pos += dir;
	      }

	      return pos;
	    } // Returns the value from the range [`from`; `to`] that satisfies
	    // `pred` and is closest to `from`. Assumes that at least `to`
	    // satisfies `pred`. Supports `from` being greater than `to`.


	    function findFirst(pred, from, to) {
	      // At any point we are certain `to` satisfies `pred`, don't know
	      // whether `from` does.
	      var dir = from > to ? -1 : 1;

	      for (;;) {
	        if (from == to) {
	          return from;
	        }

	        var midF = (from + to) / 2,
	            mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);

	        if (mid == from) {
	          return pred(mid) ? from : to;
	        }

	        if (pred(mid)) {
	          to = mid;
	        } else {
	          from = mid + dir;
	        }
	      }
	    } // BIDI HELPERS


	    function iterateBidiSections(order, from, to, f) {
	      if (!order) {
	        return f(from, to, "ltr", 0);
	      }

	      var found = false;

	      for (var i = 0; i < order.length; ++i) {
	        var part = order[i];

	        if (part.from < to && part.to > from || from == to && part.to == from) {
	          f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
	          found = true;
	        }
	      }

	      if (!found) {
	        f(from, to, "ltr");
	      }
	    }

	    var bidiOther = null;

	    function getBidiPartAt(order, ch, sticky) {
	      var found;
	      bidiOther = null;

	      for (var i = 0; i < order.length; ++i) {
	        var cur = order[i];

	        if (cur.from < ch && cur.to > ch) {
	          return i;
	        }

	        if (cur.to == ch) {
	          if (cur.from != cur.to && sticky == "before") {
	            found = i;
	          } else {
	            bidiOther = i;
	          }
	        }

	        if (cur.from == ch) {
	          if (cur.from != cur.to && sticky != "before") {
	            found = i;
	          } else {
	            bidiOther = i;
	          }
	        }
	      }

	      return found != null ? found : bidiOther;
	    } // Bidirectional ordering algorithm
	    // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	    // that this (partially) implements.
	    // One-char codes used for character types:
	    // L (L):   Left-to-Right
	    // R (R):   Right-to-Left
	    // r (AL):  Right-to-Left Arabic
	    // 1 (EN):  European Number
	    // + (ES):  European Number Separator
	    // % (ET):  European Number Terminator
	    // n (AN):  Arabic Number
	    // , (CS):  Common Number Separator
	    // m (NSM): Non-Spacing Mark
	    // b (BN):  Boundary Neutral
	    // s (B):   Paragraph Separator
	    // t (S):   Segment Separator
	    // w (WS):  Whitespace
	    // N (ON):  Other Neutrals
	    // Returns null if characters are ordered as they appear
	    // (left-to-right), or an array of sections ({from, to, level}
	    // objects) in the order in which they occur visually.


	    var bidiOrdering = function () {
	      // Character types for codepoints 0 to 0xff
	      var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"; // Character types for codepoints 0x600 to 0x6f9

	      var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";

	      function charType(code) {
	        if (code <= 0xf7) {
	          return lowTypes.charAt(code);
	        } else if (0x590 <= code && code <= 0x5f4) {
	          return "R";
	        } else if (0x600 <= code && code <= 0x6f9) {
	          return arabicTypes.charAt(code - 0x600);
	        } else if (0x6ee <= code && code <= 0x8ac) {
	          return "r";
	        } else if (0x2000 <= code && code <= 0x200b) {
	          return "w";
	        } else if (code == 0x200c) {
	          return "b";
	        } else {
	          return "L";
	        }
	      }

	      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
	      var isNeutral = /[stwN]/,
	          isStrong = /[LRr]/,
	          countsAsLeft = /[Lb1n]/,
	          countsAsNum = /[1n]/;

	      function BidiSpan(level, from, to) {
	        this.level = level;
	        this.from = from;
	        this.to = to;
	      }

	      return function (str, direction) {
	        var outerType = direction == "ltr" ? "L" : "R";

	        if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
	          return false;
	        }

	        var len = str.length,
	            types = [];

	        for (var i = 0; i < len; ++i) {
	          types.push(charType(str.charCodeAt(i)));
	        } // W1. Examine each non-spacing mark (NSM) in the level run, and
	        // change the type of the NSM to the type of the previous
	        // character. If the NSM is at the start of the level run, it will
	        // get the type of sor.


	        for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
	          var type = types[i$1];

	          if (type == "m") {
	            types[i$1] = prev;
	          } else {
	            prev = type;
	          }
	        } // W2. Search backwards from each instance of a European number
	        // until the first strong type (R, L, AL, or sor) is found. If an
	        // AL is found, change the type of the European number to Arabic
	        // number.
	        // W3. Change all ALs to R.


	        for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
	          var type$1 = types[i$2];

	          if (type$1 == "1" && cur == "r") {
	            types[i$2] = "n";
	          } else if (isStrong.test(type$1)) {
	            cur = type$1;

	            if (type$1 == "r") {
	              types[i$2] = "R";
	            }
	          }
	        } // W4. A single European separator between two European numbers
	        // changes to a European number. A single common separator between
	        // two numbers of the same type changes to that type.


	        for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
	          var type$2 = types[i$3];

	          if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
	            types[i$3] = "1";
	          } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
	            types[i$3] = prev$1;
	          }

	          prev$1 = type$2;
	        } // W5. A sequence of European terminators adjacent to European
	        // numbers changes to all European numbers.
	        // W6. Otherwise, separators and terminators change to Other
	        // Neutral.


	        for (var i$4 = 0; i$4 < len; ++i$4) {
	          var type$3 = types[i$4];

	          if (type$3 == ",") {
	            types[i$4] = "N";
	          } else if (type$3 == "%") {
	            var end = void 0;

	            for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}

	            var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";

	            for (var j = i$4; j < end; ++j) {
	              types[j] = replace;
	            }

	            i$4 = end - 1;
	          }
	        } // W7. Search backwards from each instance of a European number
	        // until the first strong type (R, L, or sor) is found. If an L is
	        // found, then change the type of the European number to L.


	        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
	          var type$4 = types[i$5];

	          if (cur$1 == "L" && type$4 == "1") {
	            types[i$5] = "L";
	          } else if (isStrong.test(type$4)) {
	            cur$1 = type$4;
	          }
	        } // N1. A sequence of neutrals takes the direction of the
	        // surrounding strong text if the text on both sides has the same
	        // direction. European and Arabic numbers act as if they were R in
	        // terms of their influence on neutrals. Start-of-level-run (sor)
	        // and end-of-level-run (eor) are used at level run boundaries.
	        // N2. Any remaining neutrals take the embedding direction.


	        for (var i$6 = 0; i$6 < len; ++i$6) {
	          if (isNeutral.test(types[i$6])) {
	            var end$1 = void 0;

	            for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}

	            var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
	            var after = (end$1 < len ? types[end$1] : outerType) == "L";
	            var replace$1 = before == after ? before ? "L" : "R" : outerType;

	            for (var j$1 = i$6; j$1 < end$1; ++j$1) {
	              types[j$1] = replace$1;
	            }

	            i$6 = end$1 - 1;
	          }
	        } // Here we depart from the documented algorithm, in order to avoid
	        // building up an actual levels array. Since there are only three
	        // levels (0, 1, 2) in an implementation that doesn't take
	        // explicit embedding into account, we can build up the order on
	        // the fly, without following the level-based algorithm.


	        var order = [],
	            m;

	        for (var i$7 = 0; i$7 < len;) {
	          if (countsAsLeft.test(types[i$7])) {
	            var start = i$7;

	            for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}

	            order.push(new BidiSpan(0, start, i$7));
	          } else {
	            var pos = i$7,
	                at = order.length,
	                isRTL = direction == "rtl" ? 1 : 0;

	            for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}

	            for (var j$2 = pos; j$2 < i$7;) {
	              if (countsAsNum.test(types[j$2])) {
	                if (pos < j$2) {
	                  order.splice(at, 0, new BidiSpan(1, pos, j$2));
	                  at += isRTL;
	                }

	                var nstart = j$2;

	                for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}

	                order.splice(at, 0, new BidiSpan(2, nstart, j$2));
	                at += isRTL;
	                pos = j$2;
	              } else {
	                ++j$2;
	              }
	            }

	            if (pos < i$7) {
	              order.splice(at, 0, new BidiSpan(1, pos, i$7));
	            }
	          }
	        }

	        if (direction == "ltr") {
	          if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	            order[0].from = m[0].length;
	            order.unshift(new BidiSpan(0, 0, m[0].length));
	          }

	          if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	            lst(order).to -= m[0].length;
	            order.push(new BidiSpan(0, len - m[0].length, len));
	          }
	        }

	        return direction == "rtl" ? order.reverse() : order;
	      };
	    }(); // Get the bidi ordering for the given line (and cache it). Returns
	    // false for lines that are fully left-to-right, and an array of
	    // BidiSpan objects otherwise.


	    function getOrder(line, direction) {
	      var order = line.order;

	      if (order == null) {
	        order = line.order = bidiOrdering(line.text, direction);
	      }

	      return order;
	    } // EVENT HANDLING
	    // Lightweight event framework. on/off also work on DOM nodes,
	    // registering native DOM handlers.


	    var noHandlers = [];

	    var on = function (emitter, type, f) {
	      if (emitter.addEventListener) {
	        emitter.addEventListener(type, f, false);
	      } else if (emitter.attachEvent) {
	        emitter.attachEvent("on" + type, f);
	      } else {
	        var map = emitter._handlers || (emitter._handlers = {});
	        map[type] = (map[type] || noHandlers).concat(f);
	      }
	    };

	    function getHandlers(emitter, type) {
	      return emitter._handlers && emitter._handlers[type] || noHandlers;
	    }

	    function off(emitter, type, f) {
	      if (emitter.removeEventListener) {
	        emitter.removeEventListener(type, f, false);
	      } else if (emitter.detachEvent) {
	        emitter.detachEvent("on" + type, f);
	      } else {
	        var map = emitter._handlers,
	            arr = map && map[type];

	        if (arr) {
	          var index = indexOf(arr, f);

	          if (index > -1) {
	            map[type] = arr.slice(0, index).concat(arr.slice(index + 1));
	          }
	        }
	      }
	    }

	    function signal(emitter, type
	    /*, values...*/
	    ) {
	      var handlers = getHandlers(emitter, type);

	      if (!handlers.length) {
	        return;
	      }

	      var args = Array.prototype.slice.call(arguments, 2);

	      for (var i = 0; i < handlers.length; ++i) {
	        handlers[i].apply(null, args);
	      }
	    } // The DOM events that CodeMirror handles can be overridden by
	    // registering a (non-DOM) handler on the editor for the event name,
	    // and preventDefault-ing the event in that handler.


	    function signalDOMEvent(cm, e, override) {
	      if (typeof e == "string") {
	        e = {
	          type: e,
	          preventDefault: function () {
	            this.defaultPrevented = true;
	          }
	        };
	      }

	      signal(cm, override || e.type, cm, e);
	      return e_defaultPrevented(e) || e.codemirrorIgnore;
	    }

	    function signalCursorActivity(cm) {
	      var arr = cm._handlers && cm._handlers.cursorActivity;

	      if (!arr) {
	        return;
	      }

	      var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);

	      for (var i = 0; i < arr.length; ++i) {
	        if (indexOf(set, arr[i]) == -1) {
	          set.push(arr[i]);
	        }
	      }
	    }

	    function hasHandler(emitter, type) {
	      return getHandlers(emitter, type).length > 0;
	    } // Add on and off methods to a constructor's prototype, to make
	    // registering events on such objects more convenient.


	    function eventMixin(ctor) {
	      ctor.prototype.on = function (type, f) {
	        on(this, type, f);
	      };

	      ctor.prototype.off = function (type, f) {
	        off(this, type, f);
	      };
	    } // Due to the fact that we still support jurassic IE versions, some
	    // compatibility wrappers are needed.


	    function e_preventDefault(e) {
	      if (e.preventDefault) {
	        e.preventDefault();
	      } else {
	        e.returnValue = false;
	      }
	    }

	    function e_stopPropagation(e) {
	      if (e.stopPropagation) {
	        e.stopPropagation();
	      } else {
	        e.cancelBubble = true;
	      }
	    }

	    function e_defaultPrevented(e) {
	      return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
	    }

	    function e_stop(e) {
	      e_preventDefault(e);
	      e_stopPropagation(e);
	    }

	    function e_target(e) {
	      return e.target || e.srcElement;
	    }

	    function e_button(e) {
	      var b = e.which;

	      if (b == null) {
	        if (e.button & 1) {
	          b = 1;
	        } else if (e.button & 2) {
	          b = 3;
	        } else if (e.button & 4) {
	          b = 2;
	        }
	      }

	      if (mac && e.ctrlKey && b == 1) {
	        b = 3;
	      }

	      return b;
	    } // Detect drag-and-drop


	    var dragAndDrop = function () {
	      // There is *some* kind of drag-and-drop support in IE6-8, but I
	      // couldn't get it to work yet.
	      if (ie && ie_version < 9) {
	        return false;
	      }

	      var div = elt('div');
	      return "draggable" in div || "dragDrop" in div;
	    }();

	    var zwspSupported;

	    function zeroWidthElement(measure) {
	      if (zwspSupported == null) {
	        var test = elt("span", "\u200b");
	        removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));

	        if (measure.firstChild.offsetHeight != 0) {
	          zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
	        }
	      }

	      var node = zwspSupported ? elt("span", "\u200b") : elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
	      node.setAttribute("cm-text", "");
	      return node;
	    } // Feature-detect IE's crummy client rect reporting for bidi text


	    var badBidiRects;

	    function hasBadBidiRects(measure) {
	      if (badBidiRects != null) {
	        return badBidiRects;
	      }

	      var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
	      var r0 = range(txt, 0, 1).getBoundingClientRect();
	      var r1 = range(txt, 1, 2).getBoundingClientRect();
	      removeChildren(measure);

	      if (!r0 || r0.left == r0.right) {
	        return false;
	      } // Safari returns null in some cases (#2780)


	      return badBidiRects = r1.right - r0.right < 3;
	    } // See if "".split is the broken IE version, if so, provide an
	    // alternative way to split lines.


	    var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
	      var pos = 0,
	          result = [],
	          l = string.length;

	      while (pos <= l) {
	        var nl = string.indexOf("\n", pos);

	        if (nl == -1) {
	          nl = string.length;
	        }

	        var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
	        var rt = line.indexOf("\r");

	        if (rt != -1) {
	          result.push(line.slice(0, rt));
	          pos += rt + 1;
	        } else {
	          result.push(line);
	          pos = nl + 1;
	        }
	      }

	      return result;
	    } : function (string) {
	      return string.split(/\r\n?|\n/);
	    };
	    var hasSelection = window.getSelection ? function (te) {
	      try {
	        return te.selectionStart != te.selectionEnd;
	      } catch (e) {
	        return false;
	      }
	    } : function (te) {
	      var range;

	      try {
	        range = te.ownerDocument.selection.createRange();
	      } catch (e) {}

	      if (!range || range.parentElement() != te) {
	        return false;
	      }

	      return range.compareEndPoints("StartToEnd", range) != 0;
	    };

	    var hasCopyEvent = function () {
	      var e = elt("div");

	      if ("oncopy" in e) {
	        return true;
	      }

	      e.setAttribute("oncopy", "return;");
	      return typeof e.oncopy == "function";
	    }();

	    var badZoomedRects = null;

	    function hasBadZoomedRects(measure) {
	      if (badZoomedRects != null) {
	        return badZoomedRects;
	      }

	      var node = removeChildrenAndAdd(measure, elt("span", "x"));
	      var normal = node.getBoundingClientRect();
	      var fromRange = range(node, 0, 1).getBoundingClientRect();
	      return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
	    } // Known modes, by name and by MIME


	    var modes = {},
	        mimeModes = {}; // Extra arguments are stored as the mode's dependencies, which is
	    // used by (legacy) mechanisms like loadmode.js to automatically
	    // load a mode. (Preferred mechanism is the require/define calls.)

	    function defineMode(name, mode) {
	      if (arguments.length > 2) {
	        mode.dependencies = Array.prototype.slice.call(arguments, 2);
	      }

	      modes[name] = mode;
	    }

	    function defineMIME(mime, spec) {
	      mimeModes[mime] = spec;
	    } // Given a MIME type, a {name, ...options} config object, or a name
	    // string, return a mode config object.


	    function resolveMode(spec) {
	      if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	        spec = mimeModes[spec];
	      } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	        var found = mimeModes[spec.name];

	        if (typeof found == "string") {
	          found = {
	            name: found
	          };
	        }

	        spec = createObj(found, spec);
	        spec.name = found.name;
	      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	        return resolveMode("application/xml");
	      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
	        return resolveMode("application/json");
	      }

	      if (typeof spec == "string") {
	        return {
	          name: spec
	        };
	      } else {
	        return spec || {
	          name: "null"
	        };
	      }
	    } // Given a mode spec (anything that resolveMode accepts), find and
	    // initialize an actual mode object.


	    function getMode(options, spec) {
	      spec = resolveMode(spec);
	      var mfactory = modes[spec.name];

	      if (!mfactory) {
	        return getMode(options, "text/plain");
	      }

	      var modeObj = mfactory(options, spec);

	      if (modeExtensions.hasOwnProperty(spec.name)) {
	        var exts = modeExtensions[spec.name];

	        for (var prop in exts) {
	          if (!exts.hasOwnProperty(prop)) {
	            continue;
	          }

	          if (modeObj.hasOwnProperty(prop)) {
	            modeObj["_" + prop] = modeObj[prop];
	          }

	          modeObj[prop] = exts[prop];
	        }
	      }

	      modeObj.name = spec.name;

	      if (spec.helperType) {
	        modeObj.helperType = spec.helperType;
	      }

	      if (spec.modeProps) {
	        for (var prop$1 in spec.modeProps) {
	          modeObj[prop$1] = spec.modeProps[prop$1];
	        }
	      }

	      return modeObj;
	    } // This can be used to attach properties to mode objects from
	    // outside the actual mode definition.


	    var modeExtensions = {};

	    function extendMode(mode, properties) {
	      var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
	      copyObj(properties, exts);
	    }

	    function copyState(mode, state) {
	      if (state === true) {
	        return state;
	      }

	      if (mode.copyState) {
	        return mode.copyState(state);
	      }

	      var nstate = {};

	      for (var n in state) {
	        var val = state[n];

	        if (val instanceof Array) {
	          val = val.concat([]);
	        }

	        nstate[n] = val;
	      }

	      return nstate;
	    } // Given a mode and a state (for that mode), find the inner mode and
	    // state at the position that the state refers to.


	    function innerMode(mode, state) {
	      var info;

	      while (mode.innerMode) {
	        info = mode.innerMode(state);

	        if (!info || info.mode == mode) {
	          break;
	        }

	        state = info.state;
	        mode = info.mode;
	      }

	      return info || {
	        mode: mode,
	        state: state
	      };
	    }

	    function startState(mode, a1, a2) {
	      return mode.startState ? mode.startState(a1, a2) : true;
	    } // STRING STREAM
	    // Fed to the mode parsers, provides helper functions to make
	    // parsers more succinct.


	    var StringStream = function (string, tabSize, lineOracle) {
	      this.pos = this.start = 0;
	      this.string = string;
	      this.tabSize = tabSize || 8;
	      this.lastColumnPos = this.lastColumnValue = 0;
	      this.lineStart = 0;
	      this.lineOracle = lineOracle;
	    };

	    StringStream.prototype.eol = function () {
	      return this.pos >= this.string.length;
	    };

	    StringStream.prototype.sol = function () {
	      return this.pos == this.lineStart;
	    };

	    StringStream.prototype.peek = function () {
	      return this.string.charAt(this.pos) || undefined;
	    };

	    StringStream.prototype.next = function () {
	      if (this.pos < this.string.length) {
	        return this.string.charAt(this.pos++);
	      }
	    };

	    StringStream.prototype.eat = function (match) {
	      var ch = this.string.charAt(this.pos);
	      var ok;

	      if (typeof match == "string") {
	        ok = ch == match;
	      } else {
	        ok = ch && (match.test ? match.test(ch) : match(ch));
	      }

	      if (ok) {
	        ++this.pos;
	        return ch;
	      }
	    };

	    StringStream.prototype.eatWhile = function (match) {
	      var start = this.pos;

	      while (this.eat(match)) {}

	      return this.pos > start;
	    };

	    StringStream.prototype.eatSpace = function () {
	      var start = this.pos;

	      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
	        ++this.pos;
	      }

	      return this.pos > start;
	    };

	    StringStream.prototype.skipToEnd = function () {
	      this.pos = this.string.length;
	    };

	    StringStream.prototype.skipTo = function (ch) {
	      var found = this.string.indexOf(ch, this.pos);

	      if (found > -1) {
	        this.pos = found;
	        return true;
	      }
	    };

	    StringStream.prototype.backUp = function (n) {
	      this.pos -= n;
	    };

	    StringStream.prototype.column = function () {
	      if (this.lastColumnPos < this.start) {
	        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
	        this.lastColumnPos = this.start;
	      }

	      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
	    };

	    StringStream.prototype.indentation = function () {
	      return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
	    };

	    StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
	      if (typeof pattern == "string") {
	        var cased = function (str) {
	          return caseInsensitive ? str.toLowerCase() : str;
	        };

	        var substr = this.string.substr(this.pos, pattern.length);

	        if (cased(substr) == cased(pattern)) {
	          if (consume !== false) {
	            this.pos += pattern.length;
	          }

	          return true;
	        }
	      } else {
	        var match = this.string.slice(this.pos).match(pattern);

	        if (match && match.index > 0) {
	          return null;
	        }

	        if (match && consume !== false) {
	          this.pos += match[0].length;
	        }

	        return match;
	      }
	    };

	    StringStream.prototype.current = function () {
	      return this.string.slice(this.start, this.pos);
	    };

	    StringStream.prototype.hideFirstChars = function (n, inner) {
	      this.lineStart += n;

	      try {
	        return inner();
	      } finally {
	        this.lineStart -= n;
	      }
	    };

	    StringStream.prototype.lookAhead = function (n) {
	      var oracle = this.lineOracle;
	      return oracle && oracle.lookAhead(n);
	    };

	    StringStream.prototype.baseToken = function () {
	      var oracle = this.lineOracle;
	      return oracle && oracle.baseToken(this.pos);
	    }; // Find the line object corresponding to the given line number.


	    function getLine(doc, n) {
	      n -= doc.first;

	      if (n < 0 || n >= doc.size) {
	        throw new Error("There is no line " + (n + doc.first) + " in the document.");
	      }

	      var chunk = doc;

	      while (!chunk.lines) {
	        for (var i = 0;; ++i) {
	          var child = chunk.children[i],
	              sz = child.chunkSize();

	          if (n < sz) {
	            chunk = child;
	            break;
	          }

	          n -= sz;
	        }
	      }

	      return chunk.lines[n];
	    } // Get the part of a document between two positions, as an array of
	    // strings.


	    function getBetween(doc, start, end) {
	      var out = [],
	          n = start.line;
	      doc.iter(start.line, end.line + 1, function (line) {
	        var text = line.text;

	        if (n == end.line) {
	          text = text.slice(0, end.ch);
	        }

	        if (n == start.line) {
	          text = text.slice(start.ch);
	        }

	        out.push(text);
	        ++n;
	      });
	      return out;
	    } // Get the lines between from and to, as array of strings.


	    function getLines(doc, from, to) {
	      var out = [];
	      doc.iter(from, to, function (line) {
	        out.push(line.text);
	      }); // iter aborts when callback returns truthy value

	      return out;
	    } // Update the height of a line, propagating the height change
	    // upwards to parent nodes.


	    function updateLineHeight(line, height) {
	      var diff = height - line.height;

	      if (diff) {
	        for (var n = line; n; n = n.parent) {
	          n.height += diff;
	        }
	      }
	    } // Given a line object, find its line number by walking up through
	    // its parent links.


	    function lineNo(line) {
	      if (line.parent == null) {
	        return null;
	      }

	      var cur = line.parent,
	          no = indexOf(cur.lines, line);

	      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	        for (var i = 0;; ++i) {
	          if (chunk.children[i] == cur) {
	            break;
	          }

	          no += chunk.children[i].chunkSize();
	        }
	      }

	      return no + cur.first;
	    } // Find the line at the given vertical position, using the height
	    // information in the document tree.


	    function lineAtHeight(chunk, h) {
	      var n = chunk.first;

	      outer: do {
	        for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
	          var child = chunk.children[i$1],
	              ch = child.height;

	          if (h < ch) {
	            chunk = child;
	            continue outer;
	          }

	          h -= ch;
	          n += child.chunkSize();
	        }

	        return n;
	      } while (!chunk.lines);

	      var i = 0;

	      for (; i < chunk.lines.length; ++i) {
	        var line = chunk.lines[i],
	            lh = line.height;

	        if (h < lh) {
	          break;
	        }

	        h -= lh;
	      }

	      return n + i;
	    }

	    function isLine(doc, l) {
	      return l >= doc.first && l < doc.first + doc.size;
	    }

	    function lineNumberFor(options, i) {
	      return String(options.lineNumberFormatter(i + options.firstLineNumber));
	    } // A Pos instance represents a position within the text.


	    function Pos(line, ch, sticky) {
	      if (sticky === void 0) sticky = null;

	      if (!(this instanceof Pos)) {
	        return new Pos(line, ch, sticky);
	      }

	      this.line = line;
	      this.ch = ch;
	      this.sticky = sticky;
	    } // Compare two positions, return 0 if they are the same, a negative
	    // number when a is less, and a positive number otherwise.


	    function cmp(a, b) {
	      return a.line - b.line || a.ch - b.ch;
	    }

	    function equalCursorPos(a, b) {
	      return a.sticky == b.sticky && cmp(a, b) == 0;
	    }

	    function copyPos(x) {
	      return Pos(x.line, x.ch);
	    }

	    function maxPos(a, b) {
	      return cmp(a, b) < 0 ? b : a;
	    }

	    function minPos(a, b) {
	      return cmp(a, b) < 0 ? a : b;
	    } // Most of the external API clips given positions to make sure they
	    // actually exist within the document.


	    function clipLine(doc, n) {
	      return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
	    }

	    function clipPos(doc, pos) {
	      if (pos.line < doc.first) {
	        return Pos(doc.first, 0);
	      }

	      var last = doc.first + doc.size - 1;

	      if (pos.line > last) {
	        return Pos(last, getLine(doc, last).text.length);
	      }

	      return clipToLen(pos, getLine(doc, pos.line).text.length);
	    }

	    function clipToLen(pos, linelen) {
	      var ch = pos.ch;

	      if (ch == null || ch > linelen) {
	        return Pos(pos.line, linelen);
	      } else if (ch < 0) {
	        return Pos(pos.line, 0);
	      } else {
	        return pos;
	      }
	    }

	    function clipPosArray(doc, array) {
	      var out = [];

	      for (var i = 0; i < array.length; i++) {
	        out[i] = clipPos(doc, array[i]);
	      }

	      return out;
	    }

	    var SavedContext = function (state, lookAhead) {
	      this.state = state;
	      this.lookAhead = lookAhead;
	    };

	    var Context = function (doc, state, line, lookAhead) {
	      this.state = state;
	      this.doc = doc;
	      this.line = line;
	      this.maxLookAhead = lookAhead || 0;
	      this.baseTokens = null;
	      this.baseTokenPos = 1;
	    };

	    Context.prototype.lookAhead = function (n) {
	      var line = this.doc.getLine(this.line + n);

	      if (line != null && n > this.maxLookAhead) {
	        this.maxLookAhead = n;
	      }

	      return line;
	    };

	    Context.prototype.baseToken = function (n) {
	      if (!this.baseTokens) {
	        return null;
	      }

	      while (this.baseTokens[this.baseTokenPos] <= n) {
	        this.baseTokenPos += 2;
	      }

	      var type = this.baseTokens[this.baseTokenPos + 1];
	      return {
	        type: type && type.replace(/( |^)overlay .*/, ""),
	        size: this.baseTokens[this.baseTokenPos] - n
	      };
	    };

	    Context.prototype.nextLine = function () {
	      this.line++;

	      if (this.maxLookAhead > 0) {
	        this.maxLookAhead--;
	      }
	    };

	    Context.fromSaved = function (doc, saved, line) {
	      if (saved instanceof SavedContext) {
	        return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
	      } else {
	        return new Context(doc, copyState(doc.mode, saved), line);
	      }
	    };

	    Context.prototype.save = function (copy) {
	      var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
	      return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
	    }; // Compute a style array (an array starting with a mode generation
	    // -- for invalidation -- followed by pairs of end positions and
	    // style strings), which is used to highlight the tokens on the
	    // line.


	    function highlightLine(cm, line, context, forceToEnd) {
	      // A styles array always starts with a number identifying the
	      // mode/overlays that it is based on (for easy invalidation).
	      var st = [cm.state.modeGen],
	          lineClasses = {}; // Compute the base array of styles

	      runMode(cm, line.text, cm.doc.mode, context, function (end, style) {
	        return st.push(end, style);
	      }, lineClasses, forceToEnd);
	      var state = context.state; // Run overlays, adjust style array.

	      var loop = function (o) {
	        context.baseTokens = st;
	        var overlay = cm.state.overlays[o],
	            i = 1,
	            at = 0;
	        context.state = true;
	        runMode(cm, line.text, overlay.mode, context, function (end, style) {
	          var start = i; // Ensure there's a token end at the current position, and that i points at it

	          while (at < end) {
	            var i_end = st[i];

	            if (i_end > end) {
	              st.splice(i, 1, end, st[i + 1], i_end);
	            }

	            i += 2;
	            at = Math.min(end, i_end);
	          }

	          if (!style) {
	            return;
	          }

	          if (overlay.opaque) {
	            st.splice(start, i - start, end, "overlay " + style);
	            i = start + 2;
	          } else {
	            for (; start < i; start += 2) {
	              var cur = st[start + 1];
	              st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
	            }
	          }
	        }, lineClasses);
	        context.state = state;
	        context.baseTokens = null;
	        context.baseTokenPos = 1;
	      };

	      for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);

	      return {
	        styles: st,
	        classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
	      };
	    }

	    function getLineStyles(cm, line, updateFrontier) {
	      if (!line.styles || line.styles[0] != cm.state.modeGen) {
	        var context = getContextBefore(cm, lineNo(line));
	        var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
	        var result = highlightLine(cm, line, context);

	        if (resetState) {
	          context.state = resetState;
	        }

	        line.stateAfter = context.save(!resetState);
	        line.styles = result.styles;

	        if (result.classes) {
	          line.styleClasses = result.classes;
	        } else if (line.styleClasses) {
	          line.styleClasses = null;
	        }

	        if (updateFrontier === cm.doc.highlightFrontier) {
	          cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
	        }
	      }

	      return line.styles;
	    }

	    function getContextBefore(cm, n, precise) {
	      var doc = cm.doc,
	          display = cm.display;

	      if (!doc.mode.startState) {
	        return new Context(doc, true, n);
	      }

	      var start = findStartLine(cm, n, precise);
	      var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
	      var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
	      doc.iter(start, n, function (line) {
	        processLine(cm, line.text, context);
	        var pos = context.line;
	        line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
	        context.nextLine();
	      });

	      if (precise) {
	        doc.modeFrontier = context.line;
	      }

	      return context;
	    } // Lightweight form of highlight -- proceed over this line and
	    // update state, but don't save a style array. Used for lines that
	    // aren't currently visible.


	    function processLine(cm, text, context, startAt) {
	      var mode = cm.doc.mode;
	      var stream = new StringStream(text, cm.options.tabSize, context);
	      stream.start = stream.pos = startAt || 0;

	      if (text == "") {
	        callBlankLine(mode, context.state);
	      }

	      while (!stream.eol()) {
	        readToken(mode, stream, context.state);
	        stream.start = stream.pos;
	      }
	    }

	    function callBlankLine(mode, state) {
	      if (mode.blankLine) {
	        return mode.blankLine(state);
	      }

	      if (!mode.innerMode) {
	        return;
	      }

	      var inner = innerMode(mode, state);

	      if (inner.mode.blankLine) {
	        return inner.mode.blankLine(inner.state);
	      }
	    }

	    function readToken(mode, stream, state, inner) {
	      for (var i = 0; i < 10; i++) {
	        if (inner) {
	          inner[0] = innerMode(mode, state).mode;
	        }

	        var style = mode.token(stream, state);

	        if (stream.pos > stream.start) {
	          return style;
	        }
	      }

	      throw new Error("Mode " + mode.name + " failed to advance stream.");
	    }

	    var Token = function (stream, type, state) {
	      this.start = stream.start;
	      this.end = stream.pos;
	      this.string = stream.current();
	      this.type = type || null;
	      this.state = state;
	    }; // Utility for getTokenAt and getLineTokens


	    function takeToken(cm, pos, precise, asArray) {
	      var doc = cm.doc,
	          mode = doc.mode,
	          style;
	      pos = clipPos(doc, pos);
	      var line = getLine(doc, pos.line),
	          context = getContextBefore(cm, pos.line, precise);
	      var stream = new StringStream(line.text, cm.options.tabSize, context),
	          tokens;

	      if (asArray) {
	        tokens = [];
	      }

	      while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	        stream.start = stream.pos;
	        style = readToken(mode, stream, context.state);

	        if (asArray) {
	          tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
	        }
	      }

	      return asArray ? tokens : new Token(stream, style, context.state);
	    }

	    function extractLineClasses(type, output) {
	      if (type) {
	        for (;;) {
	          var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);

	          if (!lineClass) {
	            break;
	          }

	          type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
	          var prop = lineClass[1] ? "bgClass" : "textClass";

	          if (output[prop] == null) {
	            output[prop] = lineClass[2];
	          } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop])) {
	            output[prop] += " " + lineClass[2];
	          }
	        }
	      }

	      return type;
	    } // Run the given mode's parser over a line, calling f for each token.


	    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
	      var flattenSpans = mode.flattenSpans;

	      if (flattenSpans == null) {
	        flattenSpans = cm.options.flattenSpans;
	      }

	      var curStart = 0,
	          curStyle = null;
	      var stream = new StringStream(text, cm.options.tabSize, context),
	          style;
	      var inner = cm.options.addModeClass && [null];

	      if (text == "") {
	        extractLineClasses(callBlankLine(mode, context.state), lineClasses);
	      }

	      while (!stream.eol()) {
	        if (stream.pos > cm.options.maxHighlightLength) {
	          flattenSpans = false;

	          if (forceToEnd) {
	            processLine(cm, text, context, stream.pos);
	          }

	          stream.pos = text.length;
	          style = null;
	        } else {
	          style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
	        }

	        if (inner) {
	          var mName = inner[0].name;

	          if (mName) {
	            style = "m-" + (style ? mName + " " + style : mName);
	          }
	        }

	        if (!flattenSpans || curStyle != style) {
	          while (curStart < stream.start) {
	            curStart = Math.min(stream.start, curStart + 5000);
	            f(curStart, curStyle);
	          }

	          curStyle = style;
	        }

	        stream.start = stream.pos;
	      }

	      while (curStart < stream.pos) {
	        // Webkit seems to refuse to render text nodes longer than 57444
	        // characters, and returns inaccurate measurements in nodes
	        // starting around 5000 chars.
	        var pos = Math.min(stream.pos, curStart + 5000);
	        f(pos, curStyle);
	        curStart = pos;
	      }
	    } // Finds the line to start with when starting a parse. Tries to
	    // find a line with a stateAfter, so that it can start with a
	    // valid state. If that fails, it returns the line with the
	    // smallest indentation, which tends to need the least context to
	    // parse correctly.


	    function findStartLine(cm, n, precise) {
	      var minindent,
	          minline,
	          doc = cm.doc;
	      var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);

	      for (var search = n; search > lim; --search) {
	        if (search <= doc.first) {
	          return doc.first;
	        }

	        var line = getLine(doc, search - 1),
	            after = line.stateAfter;

	        if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
	          return search;
	        }

	        var indented = countColumn(line.text, null, cm.options.tabSize);

	        if (minline == null || minindent > indented) {
	          minline = search - 1;
	          minindent = indented;
	        }
	      }

	      return minline;
	    }

	    function retreatFrontier(doc, n) {
	      doc.modeFrontier = Math.min(doc.modeFrontier, n);

	      if (doc.highlightFrontier < n - 10) {
	        return;
	      }

	      var start = doc.first;

	      for (var line = n - 1; line > start; line--) {
	        var saved = getLine(doc, line).stateAfter; // change is on 3
	        // state on line 1 looked ahead 2 -- so saw 3
	        // test 1 + 2 < 3 should cover this

	        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
	          start = line + 1;
	          break;
	        }
	      }

	      doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
	    } // Optimize some code when these features are not used.


	    var sawReadOnlySpans = false,
	        sawCollapsedSpans = false;

	    function seeReadOnlySpans() {
	      sawReadOnlySpans = true;
	    }

	    function seeCollapsedSpans() {
	      sawCollapsedSpans = true;
	    } // TEXTMARKER SPANS


	    function MarkedSpan(marker, from, to) {
	      this.marker = marker;
	      this.from = from;
	      this.to = to;
	    } // Search an array of spans for a span matching the given marker.


	    function getMarkedSpanFor(spans, marker) {
	      if (spans) {
	        for (var i = 0; i < spans.length; ++i) {
	          var span = spans[i];

	          if (span.marker == marker) {
	            return span;
	          }
	        }
	      }
	    } // Remove a span from an array, returning undefined if no spans are
	    // left (we don't store arrays for lines without spans).


	    function removeMarkedSpan(spans, span) {
	      var r;

	      for (var i = 0; i < spans.length; ++i) {
	        if (spans[i] != span) {
	          (r || (r = [])).push(spans[i]);
	        }
	      }

	      return r;
	    } // Add a span to a line.


	    function addMarkedSpan(line, span) {
	      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
	      span.marker.attachLine(line);
	    } // Used for the algorithm that adjusts markers for a change in the
	    // document. These functions cut an array of spans at a given
	    // character position, returning an array of remaining chunks (or
	    // undefined if nothing remains).


	    function markedSpansBefore(old, startCh, isInsert) {
	      var nw;

	      if (old) {
	        for (var i = 0; i < old.length; ++i) {
	          var span = old[i],
	              marker = span.marker;
	          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);

	          if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
	            (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
	          }
	        }
	      }

	      return nw;
	    }

	    function markedSpansAfter(old, endCh, isInsert) {
	      var nw;

	      if (old) {
	        for (var i = 0; i < old.length; ++i) {
	          var span = old[i],
	              marker = span.marker;
	          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);

	          if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
	            (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
	          }
	        }
	      }

	      return nw;
	    } // Given a change object, compute the new set of marker spans that
	    // cover the line in which the change took place. Removes spans
	    // entirely within the change, reconnects spans belonging to the
	    // same marker that appear on both sides of the change, and cuts off
	    // spans partially within the change. Returns an array of span
	    // arrays with one element for each line in (after) the change.


	    function stretchSpansOverChange(doc, change) {
	      if (change.full) {
	        return null;
	      }

	      var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
	      var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;

	      if (!oldFirst && !oldLast) {
	        return null;
	      }

	      var startCh = change.from.ch,
	          endCh = change.to.ch,
	          isInsert = cmp(change.from, change.to) == 0; // Get the spans that 'stick out' on both sides

	      var first = markedSpansBefore(oldFirst, startCh, isInsert);
	      var last = markedSpansAfter(oldLast, endCh, isInsert); // Next, merge those two ends

	      var sameLine = change.text.length == 1,
	          offset = lst(change.text).length + (sameLine ? startCh : 0);

	      if (first) {
	        // Fix up .to properties of first
	        for (var i = 0; i < first.length; ++i) {
	          var span = first[i];

	          if (span.to == null) {
	            var found = getMarkedSpanFor(last, span.marker);

	            if (!found) {
	              span.to = startCh;
	            } else if (sameLine) {
	              span.to = found.to == null ? null : found.to + offset;
	            }
	          }
	        }
	      }

	      if (last) {
	        // Fix up .from in last (or move them into first in case of sameLine)
	        for (var i$1 = 0; i$1 < last.length; ++i$1) {
	          var span$1 = last[i$1];

	          if (span$1.to != null) {
	            span$1.to += offset;
	          }

	          if (span$1.from == null) {
	            var found$1 = getMarkedSpanFor(first, span$1.marker);

	            if (!found$1) {
	              span$1.from = offset;

	              if (sameLine) {
	                (first || (first = [])).push(span$1);
	              }
	            }
	          } else {
	            span$1.from += offset;

	            if (sameLine) {
	              (first || (first = [])).push(span$1);
	            }
	          }
	        }
	      } // Make sure we didn't create any zero-length spans


	      if (first) {
	        first = clearEmptySpans(first);
	      }

	      if (last && last != first) {
	        last = clearEmptySpans(last);
	      }

	      var newMarkers = [first];

	      if (!sameLine) {
	        // Fill gap with whole-line-spans
	        var gap = change.text.length - 2,
	            gapMarkers;

	        if (gap > 0 && first) {
	          for (var i$2 = 0; i$2 < first.length; ++i$2) {
	            if (first[i$2].to == null) {
	              (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
	            }
	          }
	        }

	        for (var i$3 = 0; i$3 < gap; ++i$3) {
	          newMarkers.push(gapMarkers);
	        }

	        newMarkers.push(last);
	      }

	      return newMarkers;
	    } // Remove spans that are empty and don't have a clearWhenEmpty
	    // option of false.


	    function clearEmptySpans(spans) {
	      for (var i = 0; i < spans.length; ++i) {
	        var span = spans[i];

	        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
	          spans.splice(i--, 1);
	        }
	      }

	      if (!spans.length) {
	        return null;
	      }

	      return spans;
	    } // Used to 'clip' out readOnly ranges when making a change.


	    function removeReadOnlyRanges(doc, from, to) {
	      var markers = null;
	      doc.iter(from.line, to.line + 1, function (line) {
	        if (line.markedSpans) {
	          for (var i = 0; i < line.markedSpans.length; ++i) {
	            var mark = line.markedSpans[i].marker;

	            if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
	              (markers || (markers = [])).push(mark);
	            }
	          }
	        }
	      });

	      if (!markers) {
	        return null;
	      }

	      var parts = [{
	        from: from,
	        to: to
	      }];

	      for (var i = 0; i < markers.length; ++i) {
	        var mk = markers[i],
	            m = mk.find(0);

	        for (var j = 0; j < parts.length; ++j) {
	          var p = parts[j];

	          if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
	            continue;
	          }

	          var newParts = [j, 1],
	              dfrom = cmp(p.from, m.from),
	              dto = cmp(p.to, m.to);

	          if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
	            newParts.push({
	              from: p.from,
	              to: m.from
	            });
	          }

	          if (dto > 0 || !mk.inclusiveRight && !dto) {
	            newParts.push({
	              from: m.to,
	              to: p.to
	            });
	          }

	          parts.splice.apply(parts, newParts);
	          j += newParts.length - 3;
	        }
	      }

	      return parts;
	    } // Connect or disconnect spans from a line.


	    function detachMarkedSpans(line) {
	      var spans = line.markedSpans;

	      if (!spans) {
	        return;
	      }

	      for (var i = 0; i < spans.length; ++i) {
	        spans[i].marker.detachLine(line);
	      }

	      line.markedSpans = null;
	    }

	    function attachMarkedSpans(line, spans) {
	      if (!spans) {
	        return;
	      }

	      for (var i = 0; i < spans.length; ++i) {
	        spans[i].marker.attachLine(line);
	      }

	      line.markedSpans = spans;
	    } // Helpers used when computing which overlapping collapsed span
	    // counts as the larger one.


	    function extraLeft(marker) {
	      return marker.inclusiveLeft ? -1 : 0;
	    }

	    function extraRight(marker) {
	      return marker.inclusiveRight ? 1 : 0;
	    } // Returns a number indicating which of two overlapping collapsed
	    // spans is larger (and thus includes the other). Falls back to
	    // comparing ids when the spans cover exactly the same range.


	    function compareCollapsedMarkers(a, b) {
	      var lenDiff = a.lines.length - b.lines.length;

	      if (lenDiff != 0) {
	        return lenDiff;
	      }

	      var aPos = a.find(),
	          bPos = b.find();
	      var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);

	      if (fromCmp) {
	        return -fromCmp;
	      }

	      var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);

	      if (toCmp) {
	        return toCmp;
	      }

	      return b.id - a.id;
	    } // Find out whether a line ends or starts in a collapsed span. If
	    // so, return the marker for that span.


	    function collapsedSpanAtSide(line, start) {
	      var sps = sawCollapsedSpans && line.markedSpans,
	          found;

	      if (sps) {
	        for (var sp = void 0, i = 0; i < sps.length; ++i) {
	          sp = sps[i];

	          if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
	            found = sp.marker;
	          }
	        }
	      }

	      return found;
	    }

	    function collapsedSpanAtStart(line) {
	      return collapsedSpanAtSide(line, true);
	    }

	    function collapsedSpanAtEnd(line) {
	      return collapsedSpanAtSide(line, false);
	    }

	    function collapsedSpanAround(line, ch) {
	      var sps = sawCollapsedSpans && line.markedSpans,
	          found;

	      if (sps) {
	        for (var i = 0; i < sps.length; ++i) {
	          var sp = sps[i];

	          if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
	            found = sp.marker;
	          }
	        }
	      }

	      return found;
	    } // Test whether there exists a collapsed span that partially
	    // overlaps (covers the start or end, but not both) of a new span.
	    // Such overlap is not allowed.


	    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
	      var line = getLine(doc, lineNo);
	      var sps = sawCollapsedSpans && line.markedSpans;

	      if (sps) {
	        for (var i = 0; i < sps.length; ++i) {
	          var sp = sps[i];

	          if (!sp.marker.collapsed) {
	            continue;
	          }

	          var found = sp.marker.find(0);
	          var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
	          var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);

	          if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
	            continue;
	          }

	          if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
	            return true;
	          }
	        }
	      }
	    } // A visual line is a line as drawn on the screen. Folding, for
	    // example, can cause multiple logical lines to appear on the same
	    // visual line. This finds the start of the visual line that the
	    // given line is part of (usually that is the line itself).


	    function visualLine(line) {
	      var merged;

	      while (merged = collapsedSpanAtStart(line)) {
	        line = merged.find(-1, true).line;
	      }

	      return line;
	    }

	    function visualLineEnd(line) {
	      var merged;

	      while (merged = collapsedSpanAtEnd(line)) {
	        line = merged.find(1, true).line;
	      }

	      return line;
	    } // Returns an array of logical lines that continue the visual line
	    // started by the argument, or undefined if there are no such lines.


	    function visualLineContinued(line) {
	      var merged, lines;

	      while (merged = collapsedSpanAtEnd(line)) {
	        line = merged.find(1, true).line;
	        (lines || (lines = [])).push(line);
	      }

	      return lines;
	    } // Get the line number of the start of the visual line that the
	    // given line number is part of.


	    function visualLineNo(doc, lineN) {
	      var line = getLine(doc, lineN),
	          vis = visualLine(line);

	      if (line == vis) {
	        return lineN;
	      }

	      return lineNo(vis);
	    } // Get the line number of the start of the next visual line after
	    // the given line.


	    function visualLineEndNo(doc, lineN) {
	      if (lineN > doc.lastLine()) {
	        return lineN;
	      }

	      var line = getLine(doc, lineN),
	          merged;

	      if (!lineIsHidden(doc, line)) {
	        return lineN;
	      }

	      while (merged = collapsedSpanAtEnd(line)) {
	        line = merged.find(1, true).line;
	      }

	      return lineNo(line) + 1;
	    } // Compute whether a line is hidden. Lines count as hidden when they
	    // are part of a visual line that starts with another line, or when
	    // they are entirely covered by collapsed, non-widget span.


	    function lineIsHidden(doc, line) {
	      var sps = sawCollapsedSpans && line.markedSpans;

	      if (sps) {
	        for (var sp = void 0, i = 0; i < sps.length; ++i) {
	          sp = sps[i];

	          if (!sp.marker.collapsed) {
	            continue;
	          }

	          if (sp.from == null) {
	            return true;
	          }

	          if (sp.marker.widgetNode) {
	            continue;
	          }

	          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
	            return true;
	          }
	        }
	      }
	    }

	    function lineIsHiddenInner(doc, line, span) {
	      if (span.to == null) {
	        var end = span.marker.find(1, true);
	        return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
	      }

	      if (span.marker.inclusiveRight && span.to == line.text.length) {
	        return true;
	      }

	      for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
	        sp = line.markedSpans[i];

	        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
	          return true;
	        }
	      }
	    } // Find the height above the given line.


	    function heightAtLine(lineObj) {
	      lineObj = visualLine(lineObj);
	      var h = 0,
	          chunk = lineObj.parent;

	      for (var i = 0; i < chunk.lines.length; ++i) {
	        var line = chunk.lines[i];

	        if (line == lineObj) {
	          break;
	        } else {
	          h += line.height;
	        }
	      }

	      for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	        for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
	          var cur = p.children[i$1];

	          if (cur == chunk) {
	            break;
	          } else {
	            h += cur.height;
	          }
	        }
	      }

	      return h;
	    } // Compute the character length of a line, taking into account
	    // collapsed ranges (see markText) that might hide parts, and join
	    // other lines onto it.


	    function lineLength(line) {
	      if (line.height == 0) {
	        return 0;
	      }

	      var len = line.text.length,
	          merged,
	          cur = line;

	      while (merged = collapsedSpanAtStart(cur)) {
	        var found = merged.find(0, true);
	        cur = found.from.line;
	        len += found.from.ch - found.to.ch;
	      }

	      cur = line;

	      while (merged = collapsedSpanAtEnd(cur)) {
	        var found$1 = merged.find(0, true);
	        len -= cur.text.length - found$1.from.ch;
	        cur = found$1.to.line;
	        len += cur.text.length - found$1.to.ch;
	      }

	      return len;
	    } // Find the longest line in the document.


	    function findMaxLine(cm) {
	      var d = cm.display,
	          doc = cm.doc;
	      d.maxLine = getLine(doc, doc.first);
	      d.maxLineLength = lineLength(d.maxLine);
	      d.maxLineChanged = true;
	      doc.iter(function (line) {
	        var len = lineLength(line);

	        if (len > d.maxLineLength) {
	          d.maxLineLength = len;
	          d.maxLine = line;
	        }
	      });
	    } // LINE DATA STRUCTURE
	    // Line objects. These hold state related to a line, including
	    // highlighting info (the styles array).


	    var Line = function (text, markedSpans, estimateHeight) {
	      this.text = text;
	      attachMarkedSpans(this, markedSpans);
	      this.height = estimateHeight ? estimateHeight(this) : 1;
	    };

	    Line.prototype.lineNo = function () {
	      return lineNo(this);
	    };

	    eventMixin(Line); // Change the content (text, markers) of a line. Automatically
	    // invalidates cached information and tries to re-estimate the
	    // line's height.

	    function updateLine(line, text, markedSpans, estimateHeight) {
	      line.text = text;

	      if (line.stateAfter) {
	        line.stateAfter = null;
	      }

	      if (line.styles) {
	        line.styles = null;
	      }

	      if (line.order != null) {
	        line.order = null;
	      }

	      detachMarkedSpans(line);
	      attachMarkedSpans(line, markedSpans);
	      var estHeight = estimateHeight ? estimateHeight(line) : 1;

	      if (estHeight != line.height) {
	        updateLineHeight(line, estHeight);
	      }
	    } // Detach a line from the document tree and its markers.


	    function cleanUpLine(line) {
	      line.parent = null;
	      detachMarkedSpans(line);
	    } // Convert a style as returned by a mode (either null, or a string
	    // containing one or more styles) to a CSS style. This is cached,
	    // and also looks for line-wide styles.


	    var styleToClassCache = {},
	        styleToClassCacheWithMode = {};

	    function interpretTokenStyle(style, options) {
	      if (!style || /^\s*$/.test(style)) {
	        return null;
	      }

	      var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
	      return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
	    } // Render the DOM representation of the text of a line. Also builds
	    // up a 'line map', which points at the DOM nodes that represent
	    // specific stretches of text, and is used by the measuring code.
	    // The returned object contains the DOM node, this map, and
	    // information about line-wide styles that were set by the mode.


	    function buildLineContent(cm, lineView) {
	      // The padding-right forces the element to have a 'border', which
	      // is needed on Webkit to be able to get line-level bounding
	      // rectangles for it (in measureChar).
	      var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
	      var builder = {
	        pre: eltP("pre", [content], "CodeMirror-line"),
	        content: content,
	        col: 0,
	        pos: 0,
	        cm: cm,
	        trailingSpace: false,
	        splitSpaces: cm.getOption("lineWrapping")
	      };
	      lineView.measure = {}; // Iterate over the logical lines that make up this visual line.

	      for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	        var line = i ? lineView.rest[i - 1] : lineView.line,
	            order = void 0;
	        builder.pos = 0;
	        builder.addToken = buildToken; // Optionally wire in some hacks into the token-rendering
	        // algorithm, to deal with browser quirks.

	        if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
	          builder.addToken = buildTokenBadBidi(builder.addToken, order);
	        }

	        builder.map = [];
	        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
	        insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));

	        if (line.styleClasses) {
	          if (line.styleClasses.bgClass) {
	            builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
	          }

	          if (line.styleClasses.textClass) {
	            builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
	          }
	        } // Ensure at least a single node is present, for measuring.


	        if (builder.map.length == 0) {
	          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
	        } // Store the map and a cache object for the current logical line


	        if (i == 0) {
	          lineView.measure.map = builder.map;
	          lineView.measure.cache = {};
	        } else {
	          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
	          (lineView.measure.caches || (lineView.measure.caches = [])).push({});
	        }
	      } // See issue #2901


	      if (webkit) {
	        var last = builder.content.lastChild;

	        if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
	          builder.content.className = "cm-tab-wrap-hack";
	        }
	      }

	      signal(cm, "renderLine", cm, lineView.line, builder.pre);

	      if (builder.pre.className) {
	        builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
	      }

	      return builder;
	    }

	    function defaultSpecialCharPlaceholder(ch) {
	      var token = elt("span", "\u2022", "cm-invalidchar");
	      token.title = "\\u" + ch.charCodeAt(0).toString(16);
	      token.setAttribute("aria-label", token.title);
	      return token;
	    } // Build up the DOM representation for a single token, and add it to
	    // the line map. Takes care to render special characters separately.


	    function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
	      if (!text) {
	        return;
	      }

	      var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
	      var special = builder.cm.state.specialChars,
	          mustWrap = false;
	      var content;

	      if (!special.test(text)) {
	        builder.col += text.length;
	        content = document.createTextNode(displayText);
	        builder.map.push(builder.pos, builder.pos + text.length, content);

	        if (ie && ie_version < 9) {
	          mustWrap = true;
	        }

	        builder.pos += text.length;
	      } else {
	        content = document.createDocumentFragment();
	        var pos = 0;

	        while (true) {
	          special.lastIndex = pos;
	          var m = special.exec(text);
	          var skipped = m ? m.index - pos : text.length - pos;

	          if (skipped) {
	            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));

	            if (ie && ie_version < 9) {
	              content.appendChild(elt("span", [txt]));
	            } else {
	              content.appendChild(txt);
	            }

	            builder.map.push(builder.pos, builder.pos + skipped, txt);
	            builder.col += skipped;
	            builder.pos += skipped;
	          }

	          if (!m) {
	            break;
	          }

	          pos += skipped + 1;
	          var txt$1 = void 0;

	          if (m[0] == "\t") {
	            var tabSize = builder.cm.options.tabSize,
	                tabWidth = tabSize - builder.col % tabSize;
	            txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
	            txt$1.setAttribute("role", "presentation");
	            txt$1.setAttribute("cm-text", "\t");
	            builder.col += tabWidth;
	          } else if (m[0] == "\r" || m[0] == "\n") {
	            txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
	            txt$1.setAttribute("cm-text", m[0]);
	            builder.col += 1;
	          } else {
	            txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
	            txt$1.setAttribute("cm-text", m[0]);

	            if (ie && ie_version < 9) {
	              content.appendChild(elt("span", [txt$1]));
	            } else {
	              content.appendChild(txt$1);
	            }

	            builder.col += 1;
	          }

	          builder.map.push(builder.pos, builder.pos + 1, txt$1);
	          builder.pos++;
	        }
	      }

	      builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;

	      if (style || startStyle || endStyle || mustWrap || css || attributes) {
	        var fullStyle = style || "";

	        if (startStyle) {
	          fullStyle += startStyle;
	        }

	        if (endStyle) {
	          fullStyle += endStyle;
	        }

	        var token = elt("span", [content], fullStyle, css);

	        if (attributes) {
	          for (var attr in attributes) {
	            if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
	              token.setAttribute(attr, attributes[attr]);
	            }
	          }
	        }

	        return builder.content.appendChild(token);
	      }

	      builder.content.appendChild(content);
	    } // Change some spaces to NBSP to prevent the browser from collapsing
	    // trailing spaces at the end of a line when rendering text (issue #1362).


	    function splitSpaces(text, trailingBefore) {
	      if (text.length > 1 && !/  /.test(text)) {
	        return text;
	      }

	      var spaceBefore = trailingBefore,
	          result = "";

	      for (var i = 0; i < text.length; i++) {
	        var ch = text.charAt(i);

	        if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
	          ch = "\u00a0";
	        }

	        result += ch;
	        spaceBefore = ch == " ";
	      }

	      return result;
	    } // Work around nonsense dimensions being reported for stretches of
	    // right-to-left text.


	    function buildTokenBadBidi(inner, order) {
	      return function (builder, text, style, startStyle, endStyle, css, attributes) {
	        style = style ? style + " cm-force-border" : "cm-force-border";
	        var start = builder.pos,
	            end = start + text.length;

	        for (;;) {
	          // Find the part that overlaps with the start of this text
	          var part = void 0;

	          for (var i = 0; i < order.length; i++) {
	            part = order[i];

	            if (part.to > start && part.from <= start) {
	              break;
	            }
	          }

	          if (part.to >= end) {
	            return inner(builder, text, style, startStyle, endStyle, css, attributes);
	          }

	          inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
	          startStyle = null;
	          text = text.slice(part.to - start);
	          start = part.to;
	        }
	      };
	    }

	    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	      var widget = !ignoreWidget && marker.widgetNode;

	      if (widget) {
	        builder.map.push(builder.pos, builder.pos + size, widget);
	      }

	      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
	        if (!widget) {
	          widget = builder.content.appendChild(document.createElement("span"));
	        }

	        widget.setAttribute("cm-marker", marker.id);
	      }

	      if (widget) {
	        builder.cm.display.input.setUneditable(widget);
	        builder.content.appendChild(widget);
	      }

	      builder.pos += size;
	      builder.trailingSpace = false;
	    } // Outputs a number of spans to make up a line, taking highlighting
	    // and marked text into account.


	    function insertLineContent(line, builder, styles) {
	      var spans = line.markedSpans,
	          allText = line.text,
	          at = 0;

	      if (!spans) {
	        for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
	          builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
	        }

	        return;
	      }

	      var len = allText.length,
	          pos = 0,
	          i = 1,
	          text = "",
	          style,
	          css;
	      var nextChange = 0,
	          spanStyle,
	          spanEndStyle,
	          spanStartStyle,
	          collapsed,
	          attributes;

	      for (;;) {
	        if (nextChange == pos) {
	          // Update current marker set
	          spanStyle = spanEndStyle = spanStartStyle = css = "";
	          attributes = null;
	          collapsed = null;
	          nextChange = Infinity;
	          var foundBookmarks = [],
	              endStyles = void 0;

	          for (var j = 0; j < spans.length; ++j) {
	            var sp = spans[j],
	                m = sp.marker;

	            if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
	              foundBookmarks.push(m);
	            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
	              if (sp.to != null && sp.to != pos && nextChange > sp.to) {
	                nextChange = sp.to;
	                spanEndStyle = "";
	              }

	              if (m.className) {
	                spanStyle += " " + m.className;
	              }

	              if (m.css) {
	                css = (css ? css + ";" : "") + m.css;
	              }

	              if (m.startStyle && sp.from == pos) {
	                spanStartStyle += " " + m.startStyle;
	              }

	              if (m.endStyle && sp.to == nextChange) {
	                (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
	              } // support for the old title property
	              // https://github.com/codemirror/CodeMirror/pull/5673


	              if (m.title) {
	                (attributes || (attributes = {})).title = m.title;
	              }

	              if (m.attributes) {
	                for (var attr in m.attributes) {
	                  (attributes || (attributes = {}))[attr] = m.attributes[attr];
	                }
	              }

	              if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
	                collapsed = sp;
	              }
	            } else if (sp.from > pos && nextChange > sp.from) {
	              nextChange = sp.from;
	            }
	          }

	          if (endStyles) {
	            for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
	              if (endStyles[j$1 + 1] == nextChange) {
	                spanEndStyle += " " + endStyles[j$1];
	              }
	            }
	          }

	          if (!collapsed || collapsed.from == pos) {
	            for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
	              buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
	            }
	          }

	          if (collapsed && (collapsed.from || 0) == pos) {
	            buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);

	            if (collapsed.to == null) {
	              return;
	            }

	            if (collapsed.to == pos) {
	              collapsed = false;
	            }
	          }
	        }

	        if (pos >= len) {
	          break;
	        }

	        var upto = Math.min(len, nextChange);

	        while (true) {
	          if (text) {
	            var end = pos + text.length;

	            if (!collapsed) {
	              var tokenText = end > upto ? text.slice(0, upto - pos) : text;
	              builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
	            }

	            if (end >= upto) {
	              text = text.slice(upto - pos);
	              pos = upto;
	              break;
	            }

	            pos = end;
	            spanStartStyle = "";
	          }

	          text = allText.slice(at, at = styles[i++]);
	          style = interpretTokenStyle(styles[i++], builder.cm.options);
	        }
	      }
	    } // These objects are used to represent the visible (currently drawn)
	    // part of the document. A LineView may correspond to multiple
	    // logical lines, if those are connected by collapsed ranges.


	    function LineView(doc, line, lineN) {
	      // The starting line
	      this.line = line; // Continuing lines, if any

	      this.rest = visualLineContinued(line); // Number of logical lines in this visual line

	      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
	      this.node = this.text = null;
	      this.hidden = lineIsHidden(doc, line);
	    } // Create a range of LineView objects for the given lines.


	    function buildViewArray(cm, from, to) {
	      var array = [],
	          nextPos;

	      for (var pos = from; pos < to; pos = nextPos) {
	        var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
	        nextPos = pos + view.size;
	        array.push(view);
	      }

	      return array;
	    }

	    var operationGroup = null;

	    function pushOperation(op) {
	      if (operationGroup) {
	        operationGroup.ops.push(op);
	      } else {
	        op.ownsGroup = operationGroup = {
	          ops: [op],
	          delayedCallbacks: []
	        };
	      }
	    }

	    function fireCallbacksForOps(group) {
	      // Calls delayed callbacks and cursorActivity handlers until no
	      // new ones appear
	      var callbacks = group.delayedCallbacks,
	          i = 0;

	      do {
	        for (; i < callbacks.length; i++) {
	          callbacks[i].call(null);
	        }

	        for (var j = 0; j < group.ops.length; j++) {
	          var op = group.ops[j];

	          if (op.cursorActivityHandlers) {
	            while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
	              op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
	            }
	          }
	        }
	      } while (i < callbacks.length);
	    }

	    function finishOperation(op, endCb) {
	      var group = op.ownsGroup;

	      if (!group) {
	        return;
	      }

	      try {
	        fireCallbacksForOps(group);
	      } finally {
	        operationGroup = null;
	        endCb(group);
	      }
	    }

	    var orphanDelayedCallbacks = null; // Often, we want to signal events at a point where we are in the
	    // middle of some work, but don't want the handler to start calling
	    // other methods on the editor, which might be in an inconsistent
	    // state or simply not expect any other events to happen.
	    // signalLater looks whether there are any handlers, and schedules
	    // them to be executed when the last operation ends, or, if no
	    // operation is active, when a timeout fires.

	    function signalLater(emitter, type
	    /*, values...*/
	    ) {
	      var arr = getHandlers(emitter, type);

	      if (!arr.length) {
	        return;
	      }

	      var args = Array.prototype.slice.call(arguments, 2),
	          list;

	      if (operationGroup) {
	        list = operationGroup.delayedCallbacks;
	      } else if (orphanDelayedCallbacks) {
	        list = orphanDelayedCallbacks;
	      } else {
	        list = orphanDelayedCallbacks = [];
	        setTimeout(fireOrphanDelayed, 0);
	      }

	      var loop = function (i) {
	        list.push(function () {
	          return arr[i].apply(null, args);
	        });
	      };

	      for (var i = 0; i < arr.length; ++i) loop(i);
	    }

	    function fireOrphanDelayed() {
	      var delayed = orphanDelayedCallbacks;
	      orphanDelayedCallbacks = null;

	      for (var i = 0; i < delayed.length; ++i) {
	        delayed[i]();
	      }
	    } // When an aspect of a line changes, a string is added to
	    // lineView.changes. This updates the relevant part of the line's
	    // DOM structure.


	    function updateLineForChanges(cm, lineView, lineN, dims) {
	      for (var j = 0; j < lineView.changes.length; j++) {
	        var type = lineView.changes[j];

	        if (type == "text") {
	          updateLineText(cm, lineView);
	        } else if (type == "gutter") {
	          updateLineGutter(cm, lineView, lineN, dims);
	        } else if (type == "class") {
	          updateLineClasses(cm, lineView);
	        } else if (type == "widget") {
	          updateLineWidgets(cm, lineView, dims);
	        }
	      }

	      lineView.changes = null;
	    } // Lines with gutter elements, widgets or a background class need to
	    // be wrapped, and have the extra elements added to the wrapper div


	    function ensureLineWrapped(lineView) {
	      if (lineView.node == lineView.text) {
	        lineView.node = elt("div", null, null, "position: relative");

	        if (lineView.text.parentNode) {
	          lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
	        }

	        lineView.node.appendChild(lineView.text);

	        if (ie && ie_version < 8) {
	          lineView.node.style.zIndex = 2;
	        }
	      }

	      return lineView.node;
	    }

	    function updateLineBackground(cm, lineView) {
	      var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;

	      if (cls) {
	        cls += " CodeMirror-linebackground";
	      }

	      if (lineView.background) {
	        if (cls) {
	          lineView.background.className = cls;
	        } else {
	          lineView.background.parentNode.removeChild(lineView.background);
	          lineView.background = null;
	        }
	      } else if (cls) {
	        var wrap = ensureLineWrapped(lineView);
	        lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
	        cm.display.input.setUneditable(lineView.background);
	      }
	    } // Wrapper around buildLineContent which will reuse the structure
	    // in display.externalMeasured when possible.


	    function getLineContent(cm, lineView) {
	      var ext = cm.display.externalMeasured;

	      if (ext && ext.line == lineView.line) {
	        cm.display.externalMeasured = null;
	        lineView.measure = ext.measure;
	        return ext.built;
	      }

	      return buildLineContent(cm, lineView);
	    } // Redraw the line's text. Interacts with the background and text
	    // classes because the mode may output tokens that influence these
	    // classes.


	    function updateLineText(cm, lineView) {
	      var cls = lineView.text.className;
	      var built = getLineContent(cm, lineView);

	      if (lineView.text == lineView.node) {
	        lineView.node = built.pre;
	      }

	      lineView.text.parentNode.replaceChild(built.pre, lineView.text);
	      lineView.text = built.pre;

	      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	        lineView.bgClass = built.bgClass;
	        lineView.textClass = built.textClass;
	        updateLineClasses(cm, lineView);
	      } else if (cls) {
	        lineView.text.className = cls;
	      }
	    }

	    function updateLineClasses(cm, lineView) {
	      updateLineBackground(cm, lineView);

	      if (lineView.line.wrapClass) {
	        ensureLineWrapped(lineView).className = lineView.line.wrapClass;
	      } else if (lineView.node != lineView.text) {
	        lineView.node.className = "";
	      }

	      var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
	      lineView.text.className = textClass || "";
	    }

	    function updateLineGutter(cm, lineView, lineN, dims) {
	      if (lineView.gutter) {
	        lineView.node.removeChild(lineView.gutter);
	        lineView.gutter = null;
	      }

	      if (lineView.gutterBackground) {
	        lineView.node.removeChild(lineView.gutterBackground);
	        lineView.gutterBackground = null;
	      }

	      if (lineView.line.gutterClass) {
	        var wrap = ensureLineWrapped(lineView);
	        lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
	        cm.display.input.setUneditable(lineView.gutterBackground);
	        wrap.insertBefore(lineView.gutterBackground, lineView.text);
	      }

	      var markers = lineView.line.gutterMarkers;

	      if (cm.options.lineNumbers || markers) {
	        var wrap$1 = ensureLineWrapped(lineView);
	        var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
	        cm.display.input.setUneditable(gutterWrap);
	        wrap$1.insertBefore(gutterWrap, lineView.text);

	        if (lineView.line.gutterClass) {
	          gutterWrap.className += " " + lineView.line.gutterClass;
	        }

	        if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
	          lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
	        }

	        if (markers) {
	          for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
	            var id = cm.display.gutterSpecs[k].className,
	                found = markers.hasOwnProperty(id) && markers[id];

	            if (found) {
	              gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
	            }
	          }
	        }
	      }
	    }

	    function updateLineWidgets(cm, lineView, dims) {
	      if (lineView.alignable) {
	        lineView.alignable = null;
	      }

	      var isWidget = classTest("CodeMirror-linewidget");

	      for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
	        next = node.nextSibling;

	        if (isWidget.test(node.className)) {
	          lineView.node.removeChild(node);
	        }
	      }

	      insertLineWidgets(cm, lineView, dims);
	    } // Build a line's DOM representation from scratch


	    function buildLineElement(cm, lineView, lineN, dims) {
	      var built = getLineContent(cm, lineView);
	      lineView.text = lineView.node = built.pre;

	      if (built.bgClass) {
	        lineView.bgClass = built.bgClass;
	      }

	      if (built.textClass) {
	        lineView.textClass = built.textClass;
	      }

	      updateLineClasses(cm, lineView);
	      updateLineGutter(cm, lineView, lineN, dims);
	      insertLineWidgets(cm, lineView, dims);
	      return lineView.node;
	    } // A lineView may contain multiple logical lines (when merged by
	    // collapsed spans). The widgets for all of them need to be drawn.


	    function insertLineWidgets(cm, lineView, dims) {
	      insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);

	      if (lineView.rest) {
	        for (var i = 0; i < lineView.rest.length; i++) {
	          insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
	        }
	      }
	    }

	    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
	      if (!line.widgets) {
	        return;
	      }

	      var wrap = ensureLineWrapped(lineView);

	      for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	        var widget = ws[i],
	            node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));

	        if (!widget.handleMouseEvents) {
	          node.setAttribute("cm-ignore-events", "true");
	        }

	        positionLineWidget(widget, node, lineView, dims);
	        cm.display.input.setUneditable(node);

	        if (allowAbove && widget.above) {
	          wrap.insertBefore(node, lineView.gutter || lineView.text);
	        } else {
	          wrap.appendChild(node);
	        }

	        signalLater(widget, "redraw");
	      }
	    }

	    function positionLineWidget(widget, node, lineView, dims) {
	      if (widget.noHScroll) {
	        (lineView.alignable || (lineView.alignable = [])).push(node);
	        var width = dims.wrapperWidth;
	        node.style.left = dims.fixedPos + "px";

	        if (!widget.coverGutter) {
	          width -= dims.gutterTotalWidth;
	          node.style.paddingLeft = dims.gutterTotalWidth + "px";
	        }

	        node.style.width = width + "px";
	      }

	      if (widget.coverGutter) {
	        node.style.zIndex = 5;
	        node.style.position = "relative";

	        if (!widget.noHScroll) {
	          node.style.marginLeft = -dims.gutterTotalWidth + "px";
	        }
	      }
	    }

	    function widgetHeight(widget) {
	      if (widget.height != null) {
	        return widget.height;
	      }

	      var cm = widget.doc.cm;

	      if (!cm) {
	        return 0;
	      }

	      if (!contains(document.body, widget.node)) {
	        var parentStyle = "position: relative;";

	        if (widget.coverGutter) {
	          parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
	        }

	        if (widget.noHScroll) {
	          parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
	        }

	        removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
	      }

	      return widget.height = widget.node.parentNode.offsetHeight;
	    } // Return true when the given mouse event happened in a widget


	    function eventInWidget(display, e) {
	      for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	        if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
	          return true;
	        }
	      }
	    } // POSITION MEASUREMENT


	    function paddingTop(display) {
	      return display.lineSpace.offsetTop;
	    }

	    function paddingVert(display) {
	      return display.mover.offsetHeight - display.lineSpace.offsetHeight;
	    }

	    function paddingH(display) {
	      if (display.cachedPaddingH) {
	        return display.cachedPaddingH;
	      }

	      var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
	      var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
	      var data = {
	        left: parseInt(style.paddingLeft),
	        right: parseInt(style.paddingRight)
	      };

	      if (!isNaN(data.left) && !isNaN(data.right)) {
	        display.cachedPaddingH = data;
	      }

	      return data;
	    }

	    function scrollGap(cm) {
	      return scrollerGap - cm.display.nativeBarWidth;
	    }

	    function displayWidth(cm) {
	      return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
	    }

	    function displayHeight(cm) {
	      return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
	    } // Ensure the lineView.wrapping.heights array is populated. This is
	    // an array of bottom offsets for the lines that make up a drawn
	    // line. When lineWrapping is on, there might be more than one
	    // height.


	    function ensureLineHeights(cm, lineView, rect) {
	      var wrapping = cm.options.lineWrapping;
	      var curWidth = wrapping && displayWidth(cm);

	      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	        var heights = lineView.measure.heights = [];

	        if (wrapping) {
	          lineView.measure.width = curWidth;
	          var rects = lineView.text.firstChild.getClientRects();

	          for (var i = 0; i < rects.length - 1; i++) {
	            var cur = rects[i],
	                next = rects[i + 1];

	            if (Math.abs(cur.bottom - next.bottom) > 2) {
	              heights.push((cur.bottom + next.top) / 2 - rect.top);
	            }
	          }
	        }

	        heights.push(rect.bottom - rect.top);
	      }
	    } // Find a line map (mapping character offsets to text nodes) and a
	    // measurement cache for the given line number. (A line view might
	    // contain multiple lines when collapsed ranges are present.)


	    function mapFromLineView(lineView, line, lineN) {
	      if (lineView.line == line) {
	        return {
	          map: lineView.measure.map,
	          cache: lineView.measure.cache
	        };
	      }

	      for (var i = 0; i < lineView.rest.length; i++) {
	        if (lineView.rest[i] == line) {
	          return {
	            map: lineView.measure.maps[i],
	            cache: lineView.measure.caches[i]
	          };
	        }
	      }

	      for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
	        if (lineNo(lineView.rest[i$1]) > lineN) {
	          return {
	            map: lineView.measure.maps[i$1],
	            cache: lineView.measure.caches[i$1],
	            before: true
	          };
	        }
	      }
	    } // Render a line into the hidden node display.externalMeasured. Used
	    // when measurement is needed for a line that's not in the viewport.


	    function updateExternalMeasurement(cm, line) {
	      line = visualLine(line);
	      var lineN = lineNo(line);
	      var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
	      view.lineN = lineN;
	      var built = view.built = buildLineContent(cm, view);
	      view.text = built.pre;
	      removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
	      return view;
	    } // Get a {top, bottom, left, right} box (in line-local coordinates)
	    // for a given character.


	    function measureChar(cm, line, ch, bias) {
	      return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
	    } // Find a line view that corresponds to the given line number.


	    function findViewForLine(cm, lineN) {
	      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
	        return cm.display.view[findViewIndex(cm, lineN)];
	      }

	      var ext = cm.display.externalMeasured;

	      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
	        return ext;
	      }
	    } // Measurement can be split in two steps, the set-up work that
	    // applies to the whole line, and the measurement of the actual
	    // character. Functions like coordsChar, that need to do a lot of
	    // measurements in a row, can thus ensure that the set-up work is
	    // only done once.


	    function prepareMeasureForLine(cm, line) {
	      var lineN = lineNo(line);
	      var view = findViewForLine(cm, lineN);

	      if (view && !view.text) {
	        view = null;
	      } else if (view && view.changes) {
	        updateLineForChanges(cm, view, lineN, getDimensions(cm));
	        cm.curOp.forceUpdate = true;
	      }

	      if (!view) {
	        view = updateExternalMeasurement(cm, line);
	      }

	      var info = mapFromLineView(view, line, lineN);
	      return {
	        line: line,
	        view: view,
	        rect: null,
	        map: info.map,
	        cache: info.cache,
	        before: info.before,
	        hasHeights: false
	      };
	    } // Given a prepared measurement object, measures the position of an
	    // actual character (or fetches it from the cache).


	    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	      if (prepared.before) {
	        ch = -1;
	      }

	      var key = ch + (bias || ""),
	          found;

	      if (prepared.cache.hasOwnProperty(key)) {
	        found = prepared.cache[key];
	      } else {
	        if (!prepared.rect) {
	          prepared.rect = prepared.view.text.getBoundingClientRect();
	        }

	        if (!prepared.hasHeights) {
	          ensureLineHeights(cm, prepared.view, prepared.rect);
	          prepared.hasHeights = true;
	        }

	        found = measureCharInner(cm, prepared, ch, bias);

	        if (!found.bogus) {
	          prepared.cache[key] = found;
	        }
	      }

	      return {
	        left: found.left,
	        right: found.right,
	        top: varHeight ? found.rtop : found.top,
	        bottom: varHeight ? found.rbottom : found.bottom
	      };
	    }

	    var nullRect = {
	      left: 0,
	      right: 0,
	      top: 0,
	      bottom: 0
	    };

	    function nodeAndOffsetInLineMap(map, ch, bias) {
	      var node, start, end, collapse, mStart, mEnd; // First, search the line map for the text node corresponding to,
	      // or closest to, the target character.

	      for (var i = 0; i < map.length; i += 3) {
	        mStart = map[i];
	        mEnd = map[i + 1];

	        if (ch < mStart) {
	          start = 0;
	          end = 1;
	          collapse = "left";
	        } else if (ch < mEnd) {
	          start = ch - mStart;
	          end = start + 1;
	        } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
	          end = mEnd - mStart;
	          start = end - 1;

	          if (ch >= mEnd) {
	            collapse = "right";
	          }
	        }

	        if (start != null) {
	          node = map[i + 2];

	          if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
	            collapse = bias;
	          }

	          if (bias == "left" && start == 0) {
	            while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
	              node = map[(i -= 3) + 2];
	              collapse = "left";
	            }
	          }

	          if (bias == "right" && start == mEnd - mStart) {
	            while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
	              node = map[(i += 3) + 2];
	              collapse = "right";
	            }
	          }

	          break;
	        }
	      }

	      return {
	        node: node,
	        start: start,
	        end: end,
	        collapse: collapse,
	        coverStart: mStart,
	        coverEnd: mEnd
	      };
	    }

	    function getUsefulRect(rects, bias) {
	      var rect = nullRect;

	      if (bias == "left") {
	        for (var i = 0; i < rects.length; i++) {
	          if ((rect = rects[i]).left != rect.right) {
	            break;
	          }
	        }
	      } else {
	        for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
	          if ((rect = rects[i$1]).left != rect.right) {
	            break;
	          }
	        }
	      }

	      return rect;
	    }

	    function measureCharInner(cm, prepared, ch, bias) {
	      var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
	      var node = place.node,
	          start = place.start,
	          end = place.end,
	          collapse = place.collapse;
	      var rect;

	      if (node.nodeType == 3) {
	        // If it is a text node, use a range to retrieve the coordinates.
	        for (var i$1 = 0; i$1 < 4; i$1++) {
	          // Retry a maximum of 4 times when nonsense rectangles are returned
	          while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
	            --start;
	          }

	          while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
	            ++end;
	          }

	          if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
	            rect = node.parentNode.getBoundingClientRect();
	          } else {
	            rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
	          }

	          if (rect.left || rect.right || start == 0) {
	            break;
	          }

	          end = start;
	          start = start - 1;
	          collapse = "right";
	        }

	        if (ie && ie_version < 11) {
	          rect = maybeUpdateRectForZooming(cm.display.measure, rect);
	        }
	      } else {
	        // If it is a widget, simply get the box for the whole widget.
	        if (start > 0) {
	          collapse = bias = "right";
	        }

	        var rects;

	        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
	          rect = rects[bias == "right" ? rects.length - 1 : 0];
	        } else {
	          rect = node.getBoundingClientRect();
	        }
	      }

	      if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	        var rSpan = node.parentNode.getClientRects()[0];

	        if (rSpan) {
	          rect = {
	            left: rSpan.left,
	            right: rSpan.left + charWidth(cm.display),
	            top: rSpan.top,
	            bottom: rSpan.bottom
	          };
	        } else {
	          rect = nullRect;
	        }
	      }

	      var rtop = rect.top - prepared.rect.top,
	          rbot = rect.bottom - prepared.rect.top;
	      var mid = (rtop + rbot) / 2;
	      var heights = prepared.view.measure.heights;
	      var i = 0;

	      for (; i < heights.length - 1; i++) {
	        if (mid < heights[i]) {
	          break;
	        }
	      }

	      var top = i ? heights[i - 1] : 0,
	          bot = heights[i];
	      var result = {
	        left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	        right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	        top: top,
	        bottom: bot
	      };

	      if (!rect.left && !rect.right) {
	        result.bogus = true;
	      }

	      if (!cm.options.singleCursorHeightPerLine) {
	        result.rtop = rtop;
	        result.rbottom = rbot;
	      }

	      return result;
	    } // Work around problem with bounding client rects on ranges being
	    // returned incorrectly when zoomed on IE10 and below.


	    function maybeUpdateRectForZooming(measure, rect) {
	      if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
	        return rect;
	      }

	      var scaleX = screen.logicalXDPI / screen.deviceXDPI;
	      var scaleY = screen.logicalYDPI / screen.deviceYDPI;
	      return {
	        left: rect.left * scaleX,
	        right: rect.right * scaleX,
	        top: rect.top * scaleY,
	        bottom: rect.bottom * scaleY
	      };
	    }

	    function clearLineMeasurementCacheFor(lineView) {
	      if (lineView.measure) {
	        lineView.measure.cache = {};
	        lineView.measure.heights = null;

	        if (lineView.rest) {
	          for (var i = 0; i < lineView.rest.length; i++) {
	            lineView.measure.caches[i] = {};
	          }
	        }
	      }
	    }

	    function clearLineMeasurementCache(cm) {
	      cm.display.externalMeasure = null;
	      removeChildren(cm.display.lineMeasure);

	      for (var i = 0; i < cm.display.view.length; i++) {
	        clearLineMeasurementCacheFor(cm.display.view[i]);
	      }
	    }

	    function clearCaches(cm) {
	      clearLineMeasurementCache(cm);
	      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;

	      if (!cm.options.lineWrapping) {
	        cm.display.maxLineChanged = true;
	      }

	      cm.display.lineNumChars = null;
	    }

	    function pageScrollX() {
	      // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
	      // which causes page_Offset and bounding client rects to use
	      // different reference viewports and invalidate our calculations.
	      if (chrome && android) {
	        return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
	      }

	      return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
	    }

	    function pageScrollY() {
	      if (chrome && android) {
	        return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
	      }

	      return window.pageYOffset || (document.documentElement || document.body).scrollTop;
	    }

	    function widgetTopHeight(lineObj) {
	      var height = 0;

	      if (lineObj.widgets) {
	        for (var i = 0; i < lineObj.widgets.length; ++i) {
	          if (lineObj.widgets[i].above) {
	            height += widgetHeight(lineObj.widgets[i]);
	          }
	        }
	      }

	      return height;
	    } // Converts a {top, bottom, left, right} box from line-local
	    // coordinates into another coordinate system. Context may be one of
	    // "line", "div" (display.lineDiv), "local"./null (editor), "window",
	    // or "page".


	    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
	      if (!includeWidgets) {
	        var height = widgetTopHeight(lineObj);
	        rect.top += height;
	        rect.bottom += height;
	      }

	      if (context == "line") {
	        return rect;
	      }

	      if (!context) {
	        context = "local";
	      }

	      var yOff = heightAtLine(lineObj);

	      if (context == "local") {
	        yOff += paddingTop(cm.display);
	      } else {
	        yOff -= cm.display.viewOffset;
	      }

	      if (context == "page" || context == "window") {
	        var lOff = cm.display.lineSpace.getBoundingClientRect();
	        yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
	        var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
	        rect.left += xOff;
	        rect.right += xOff;
	      }

	      rect.top += yOff;
	      rect.bottom += yOff;
	      return rect;
	    } // Coverts a box from "div" coords to another coordinate system.
	    // Context may be "window", "page", "div", or "local"./null.


	    function fromCoordSystem(cm, coords, context) {
	      if (context == "div") {
	        return coords;
	      }

	      var left = coords.left,
	          top = coords.top; // First move into "page" coordinate system

	      if (context == "page") {
	        left -= pageScrollX();
	        top -= pageScrollY();
	      } else if (context == "local" || !context) {
	        var localBox = cm.display.sizer.getBoundingClientRect();
	        left += localBox.left;
	        top += localBox.top;
	      }

	      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
	      return {
	        left: left - lineSpaceBox.left,
	        top: top - lineSpaceBox.top
	      };
	    }

	    function charCoords(cm, pos, context, lineObj, bias) {
	      if (!lineObj) {
	        lineObj = getLine(cm.doc, pos.line);
	      }

	      return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
	    } // Returns a box for a given cursor position, which may have an
	    // 'other' property containing the position of the secondary cursor
	    // on a bidi boundary.
	    // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
	    // and after `char - 1` in writing order of `char - 1`
	    // A cursor Pos(line, char, "after") is on the same visual line as `char`
	    // and before `char` in writing order of `char`
	    // Examples (upper-case letters are RTL, lower-case are LTR):
	    //     Pos(0, 1, ...)
	    //     before   after
	    // ab     a|b     a|b
	    // aB     a|B     aB|
	    // Ab     |Ab     A|b
	    // AB     B|A     B|A
	    // Every position after the last character on a line is considered to stick
	    // to the last character on the line.


	    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	      lineObj = lineObj || getLine(cm.doc, pos.line);

	      if (!preparedMeasure) {
	        preparedMeasure = prepareMeasureForLine(cm, lineObj);
	      }

	      function get(ch, right) {
	        var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);

	        if (right) {
	          m.left = m.right;
	        } else {
	          m.right = m.left;
	        }

	        return intoCoordSystem(cm, lineObj, m, context);
	      }

	      var order = getOrder(lineObj, cm.doc.direction),
	          ch = pos.ch,
	          sticky = pos.sticky;

	      if (ch >= lineObj.text.length) {
	        ch = lineObj.text.length;
	        sticky = "before";
	      } else if (ch <= 0) {
	        ch = 0;
	        sticky = "after";
	      }

	      if (!order) {
	        return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
	      }

	      function getBidi(ch, partPos, invert) {
	        var part = order[partPos],
	            right = part.level == 1;
	        return get(invert ? ch - 1 : ch, right != invert);
	      }

	      var partPos = getBidiPartAt(order, ch, sticky);
	      var other = bidiOther;
	      var val = getBidi(ch, partPos, sticky == "before");

	      if (other != null) {
	        val.other = getBidi(ch, other, sticky != "before");
	      }

	      return val;
	    } // Used to cheaply estimate the coordinates for a position. Used for
	    // intermediate scroll updates.


	    function estimateCoords(cm, pos) {
	      var left = 0;
	      pos = clipPos(cm.doc, pos);

	      if (!cm.options.lineWrapping) {
	        left = charWidth(cm.display) * pos.ch;
	      }

	      var lineObj = getLine(cm.doc, pos.line);
	      var top = heightAtLine(lineObj) + paddingTop(cm.display);
	      return {
	        left: left,
	        right: left,
	        top: top,
	        bottom: top + lineObj.height
	      };
	    } // Positions returned by coordsChar contain some extra information.
	    // xRel is the relative x position of the input coordinates compared
	    // to the found position (so xRel > 0 means the coordinates are to
	    // the right of the character position, for example). When outside
	    // is true, that means the coordinates lie outside the line's
	    // vertical range.


	    function PosWithInfo(line, ch, sticky, outside, xRel) {
	      var pos = Pos(line, ch, sticky);
	      pos.xRel = xRel;

	      if (outside) {
	        pos.outside = outside;
	      }

	      return pos;
	    } // Compute the character position closest to the given coordinates.
	    // Input must be lineSpace-local ("div" coordinate system).


	    function coordsChar(cm, x, y) {
	      var doc = cm.doc;
	      y += cm.display.viewOffset;

	      if (y < 0) {
	        return PosWithInfo(doc.first, 0, null, -1, -1);
	      }

	      var lineN = lineAtHeight(doc, y),
	          last = doc.first + doc.size - 1;

	      if (lineN > last) {
	        return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
	      }

	      if (x < 0) {
	        x = 0;
	      }

	      var lineObj = getLine(doc, lineN);

	      for (;;) {
	        var found = coordsCharInner(cm, lineObj, lineN, x, y);
	        var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));

	        if (!collapsed) {
	          return found;
	        }

	        var rangeEnd = collapsed.find(1);

	        if (rangeEnd.line == lineN) {
	          return rangeEnd;
	        }

	        lineObj = getLine(doc, lineN = rangeEnd.line);
	      }
	    }

	    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
	      y -= widgetTopHeight(lineObj);
	      var end = lineObj.text.length;
	      var begin = findFirst(function (ch) {
	        return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
	      }, end, 0);
	      end = findFirst(function (ch) {
	        return measureCharPrepared(cm, preparedMeasure, ch).top > y;
	      }, begin, end);
	      return {
	        begin: begin,
	        end: end
	      };
	    }

	    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
	      if (!preparedMeasure) {
	        preparedMeasure = prepareMeasureForLine(cm, lineObj);
	      }

	      var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
	      return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
	    } // Returns true if the given side of a box is after the given
	    // coordinates, in top-to-bottom, left-to-right order.


	    function boxIsAfter(box, x, y, left) {
	      return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
	    }

	    function coordsCharInner(cm, lineObj, lineNo, x, y) {
	      // Move y into line-local coordinate space
	      y -= heightAtLine(lineObj);
	      var preparedMeasure = prepareMeasureForLine(cm, lineObj); // When directly calling `measureCharPrepared`, we have to adjust
	      // for the widgets at this line.

	      var widgetHeight = widgetTopHeight(lineObj);
	      var begin = 0,
	          end = lineObj.text.length,
	          ltr = true;
	      var order = getOrder(lineObj, cm.doc.direction); // If the line isn't plain left-to-right text, first figure out
	      // which bidi section the coordinates fall into.

	      if (order) {
	        var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);
	        ltr = part.level != 1; // The awkward -1 offsets are needed because findFirst (called
	        // on these below) will treat its first bound as inclusive,
	        // second as exclusive, but we want to actually address the
	        // characters in the part's range

	        begin = ltr ? part.from : part.to - 1;
	        end = ltr ? part.to : part.from - 1;
	      } // A binary search to find the first character whose bounding box
	      // starts after the coordinates. If we run across any whose box wrap
	      // the coordinates, store that.


	      var chAround = null,
	          boxAround = null;
	      var ch = findFirst(function (ch) {
	        var box = measureCharPrepared(cm, preparedMeasure, ch);
	        box.top += widgetHeight;
	        box.bottom += widgetHeight;

	        if (!boxIsAfter(box, x, y, false)) {
	          return false;
	        }

	        if (box.top <= y && box.left <= x) {
	          chAround = ch;
	          boxAround = box;
	        }

	        return true;
	      }, begin, end);
	      var baseX,
	          sticky,
	          outside = false; // If a box around the coordinates was found, use that

	      if (boxAround) {
	        // Distinguish coordinates nearer to the left or right side of the box
	        var atLeft = x - boxAround.left < boxAround.right - x,
	            atStart = atLeft == ltr;
	        ch = chAround + (atStart ? 0 : 1);
	        sticky = atStart ? "after" : "before";
	        baseX = atLeft ? boxAround.left : boxAround.right;
	      } else {
	        // (Adjust for extended bound, if necessary.)
	        if (!ltr && (ch == end || ch == begin)) {
	          ch++;
	        } // To determine which side to associate with, get the box to the
	        // left of the character and compare it's vertical position to the
	        // coordinates


	        sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y == ltr ? "after" : "before"; // Now get accurate coordinates for this place, in order to get a
	        // base X position

	        var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
	        baseX = coords.left;
	        outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
	      }

	      ch = skipExtendingChars(lineObj.text, ch, 1);
	      return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);
	    }

	    function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
	      // Bidi parts are sorted left-to-right, and in a non-line-wrapping
	      // situation, we can take this ordering to correspond to the visual
	      // ordering. This finds the first part whose end is after the given
	      // coordinates.
	      var index = findFirst(function (i) {
	        var part = order[i],
	            ltr = part.level != 1;
	        return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
	      }, 0, order.length - 1);
	      var part = order[index]; // If this isn't the first part, the part's start is also after
	      // the coordinates, and the coordinates aren't on the same line as
	      // that start, move one part back.

	      if (index > 0) {
	        var ltr = part.level != 1;
	        var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);

	        if (boxIsAfter(start, x, y, true) && start.top > y) {
	          part = order[index - 1];
	        }
	      }

	      return part;
	    }

	    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
	      // In a wrapped line, rtl text on wrapping boundaries can do things
	      // that don't correspond to the ordering in our `order` array at
	      // all, so a binary search doesn't work, and we want to return a
	      // part that only spans one line so that the binary search in
	      // coordsCharInner is safe. As such, we first find the extent of the
	      // wrapped line, and then do a flat search in which we discard any
	      // spans that aren't on the line.
	      var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
	      var begin = ref.begin;
	      var end = ref.end;

	      if (/\s/.test(lineObj.text.charAt(end - 1))) {
	        end--;
	      }

	      var part = null,
	          closestDist = null;

	      for (var i = 0; i < order.length; i++) {
	        var p = order[i];

	        if (p.from >= end || p.to <= begin) {
	          continue;
	        }

	        var ltr = p.level != 1;
	        var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right; // Weigh against spans ending before this, so that they are only
	        // picked if nothing ends after

	        var dist = endX < x ? x - endX + 1e9 : endX - x;

	        if (!part || closestDist > dist) {
	          part = p;
	          closestDist = dist;
	        }
	      }

	      if (!part) {
	        part = order[order.length - 1];
	      } // Clip the part to the wrapped line.


	      if (part.from < begin) {
	        part = {
	          from: begin,
	          to: part.to,
	          level: part.level
	        };
	      }

	      if (part.to > end) {
	        part = {
	          from: part.from,
	          to: end,
	          level: part.level
	        };
	      }

	      return part;
	    }

	    var measureText; // Compute the default text height.

	    function textHeight(display) {
	      if (display.cachedTextHeight != null) {
	        return display.cachedTextHeight;
	      }

	      if (measureText == null) {
	        measureText = elt("pre", null, "CodeMirror-line-like"); // Measure a bunch of lines, for browsers that compute
	        // fractional heights.

	        for (var i = 0; i < 49; ++i) {
	          measureText.appendChild(document.createTextNode("x"));
	          measureText.appendChild(elt("br"));
	        }

	        measureText.appendChild(document.createTextNode("x"));
	      }

	      removeChildrenAndAdd(display.measure, measureText);
	      var height = measureText.offsetHeight / 50;

	      if (height > 3) {
	        display.cachedTextHeight = height;
	      }

	      removeChildren(display.measure);
	      return height || 1;
	    } // Compute the default character width.


	    function charWidth(display) {
	      if (display.cachedCharWidth != null) {
	        return display.cachedCharWidth;
	      }

	      var anchor = elt("span", "xxxxxxxxxx");
	      var pre = elt("pre", [anchor], "CodeMirror-line-like");
	      removeChildrenAndAdd(display.measure, pre);
	      var rect = anchor.getBoundingClientRect(),
	          width = (rect.right - rect.left) / 10;

	      if (width > 2) {
	        display.cachedCharWidth = width;
	      }

	      return width || 10;
	    } // Do a bulk-read of the DOM positions and sizes needed to draw the
	    // view, so that we don't interleave reading and writing to the DOM.


	    function getDimensions(cm) {
	      var d = cm.display,
	          left = {},
	          width = {};
	      var gutterLeft = d.gutters.clientLeft;

	      for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	        var id = cm.display.gutterSpecs[i].className;
	        left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
	        width[id] = n.clientWidth;
	      }

	      return {
	        fixedPos: compensateForHScroll(d),
	        gutterTotalWidth: d.gutters.offsetWidth,
	        gutterLeft: left,
	        gutterWidth: width,
	        wrapperWidth: d.wrapper.clientWidth
	      };
	    } // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	    // but using getBoundingClientRect to get a sub-pixel-accurate
	    // result.


	    function compensateForHScroll(display) {
	      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
	    } // Returns a function that estimates the height of a line, to use as
	    // first approximation until the line becomes visible (and is thus
	    // properly measurable).


	    function estimateHeight(cm) {
	      var th = textHeight(cm.display),
	          wrapping = cm.options.lineWrapping;
	      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
	      return function (line) {
	        if (lineIsHidden(cm.doc, line)) {
	          return 0;
	        }

	        var widgetsHeight = 0;

	        if (line.widgets) {
	          for (var i = 0; i < line.widgets.length; i++) {
	            if (line.widgets[i].height) {
	              widgetsHeight += line.widgets[i].height;
	            }
	          }
	        }

	        if (wrapping) {
	          return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
	        } else {
	          return widgetsHeight + th;
	        }
	      };
	    }

	    function estimateLineHeights(cm) {
	      var doc = cm.doc,
	          est = estimateHeight(cm);
	      doc.iter(function (line) {
	        var estHeight = est(line);

	        if (estHeight != line.height) {
	          updateLineHeight(line, estHeight);
	        }
	      });
	    } // Given a mouse event, find the corresponding position. If liberal
	    // is false, it checks whether a gutter or scrollbar was clicked,
	    // and returns null if it was. forRect is used by rectangular
	    // selections, and tries to estimate a character position even for
	    // coordinates beyond the right of the text.


	    function posFromMouse(cm, e, liberal, forRect) {
	      var display = cm.display;

	      if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
	        return null;
	      }

	      var x,
	          y,
	          space = display.lineSpace.getBoundingClientRect(); // Fails unpredictably on IE[67] when mouse is dragged around quickly.

	      try {
	        x = e.clientX - space.left;
	        y = e.clientY - space.top;
	      } catch (e$1) {
	        return null;
	      }

	      var coords = coordsChar(cm, x, y),
	          line;

	      if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	        var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
	        coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
	      }

	      return coords;
	    } // Find the view element corresponding to a given line. Return null
	    // when the line isn't visible.


	    function findViewIndex(cm, n) {
	      if (n >= cm.display.viewTo) {
	        return null;
	      }

	      n -= cm.display.viewFrom;

	      if (n < 0) {
	        return null;
	      }

	      var view = cm.display.view;

	      for (var i = 0; i < view.length; i++) {
	        n -= view[i].size;

	        if (n < 0) {
	          return i;
	        }
	      }
	    } // Updates the display.view data structure for a given change to the
	    // document. From and to are in pre-change coordinates. Lendiff is
	    // the amount of lines added or subtracted by the change. This is
	    // used for changes that span multiple lines, or change the way
	    // lines are divided into visual lines. regLineChange (below)
	    // registers single-line changes.


	    function regChange(cm, from, to, lendiff) {
	      if (from == null) {
	        from = cm.doc.first;
	      }

	      if (to == null) {
	        to = cm.doc.first + cm.doc.size;
	      }

	      if (!lendiff) {
	        lendiff = 0;
	      }

	      var display = cm.display;

	      if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
	        display.updateLineNumbers = from;
	      }

	      cm.curOp.viewChanged = true;

	      if (from >= display.viewTo) {
	        // Change after
	        if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
	          resetView(cm);
	        }
	      } else if (to <= display.viewFrom) {
	        // Change before
	        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	          resetView(cm);
	        } else {
	          display.viewFrom += lendiff;
	          display.viewTo += lendiff;
	        }
	      } else if (from <= display.viewFrom && to >= display.viewTo) {
	        // Full overlap
	        resetView(cm);
	      } else if (from <= display.viewFrom) {
	        // Top overlap
	        var cut = viewCuttingPoint(cm, to, to + lendiff, 1);

	        if (cut) {
	          display.view = display.view.slice(cut.index);
	          display.viewFrom = cut.lineN;
	          display.viewTo += lendiff;
	        } else {
	          resetView(cm);
	        }
	      } else if (to >= display.viewTo) {
	        // Bottom overlap
	        var cut$1 = viewCuttingPoint(cm, from, from, -1);

	        if (cut$1) {
	          display.view = display.view.slice(0, cut$1.index);
	          display.viewTo = cut$1.lineN;
	        } else {
	          resetView(cm);
	        }
	      } else {
	        // Gap in the middle
	        var cutTop = viewCuttingPoint(cm, from, from, -1);
	        var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);

	        if (cutTop && cutBot) {
	          display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
	          display.viewTo += lendiff;
	        } else {
	          resetView(cm);
	        }
	      }

	      var ext = display.externalMeasured;

	      if (ext) {
	        if (to < ext.lineN) {
	          ext.lineN += lendiff;
	        } else if (from < ext.lineN + ext.size) {
	          display.externalMeasured = null;
	        }
	      }
	    } // Register a change to a single line. Type must be one of "text",
	    // "gutter", "class", "widget"


	    function regLineChange(cm, line, type) {
	      cm.curOp.viewChanged = true;
	      var display = cm.display,
	          ext = cm.display.externalMeasured;

	      if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
	        display.externalMeasured = null;
	      }

	      if (line < display.viewFrom || line >= display.viewTo) {
	        return;
	      }

	      var lineView = display.view[findViewIndex(cm, line)];

	      if (lineView.node == null) {
	        return;
	      }

	      var arr = lineView.changes || (lineView.changes = []);

	      if (indexOf(arr, type) == -1) {
	        arr.push(type);
	      }
	    } // Clear the view.


	    function resetView(cm) {
	      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
	      cm.display.view = [];
	      cm.display.viewOffset = 0;
	    }

	    function viewCuttingPoint(cm, oldN, newN, dir) {
	      var index = findViewIndex(cm, oldN),
	          diff,
	          view = cm.display.view;

	      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
	        return {
	          index: index,
	          lineN: newN
	        };
	      }

	      var n = cm.display.viewFrom;

	      for (var i = 0; i < index; i++) {
	        n += view[i].size;
	      }

	      if (n != oldN) {
	        if (dir > 0) {
	          if (index == view.length - 1) {
	            return null;
	          }

	          diff = n + view[index].size - oldN;
	          index++;
	        } else {
	          diff = n - oldN;
	        }

	        oldN += diff;
	        newN += diff;
	      }

	      while (visualLineNo(cm.doc, newN) != newN) {
	        if (index == (dir < 0 ? 0 : view.length - 1)) {
	          return null;
	        }

	        newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
	        index += dir;
	      }

	      return {
	        index: index,
	        lineN: newN
	      };
	    } // Force the view to cover a given range, adding empty view element
	    // or clipping off existing ones as needed.


	    function adjustView(cm, from, to) {
	      var display = cm.display,
	          view = display.view;

	      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	        display.view = buildViewArray(cm, from, to);
	        display.viewFrom = from;
	      } else {
	        if (display.viewFrom > from) {
	          display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
	        } else if (display.viewFrom < from) {
	          display.view = display.view.slice(findViewIndex(cm, from));
	        }

	        display.viewFrom = from;

	        if (display.viewTo < to) {
	          display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
	        } else if (display.viewTo > to) {
	          display.view = display.view.slice(0, findViewIndex(cm, to));
	        }
	      }

	      display.viewTo = to;
	    } // Count the number of lines in the view whose DOM representation is
	    // out of date (or nonexistent).


	    function countDirtyView(cm) {
	      var view = cm.display.view,
	          dirty = 0;

	      for (var i = 0; i < view.length; i++) {
	        var lineView = view[i];

	        if (!lineView.hidden && (!lineView.node || lineView.changes)) {
	          ++dirty;
	        }
	      }

	      return dirty;
	    }

	    function updateSelection(cm) {
	      cm.display.input.showSelection(cm.display.input.prepareSelection());
	    }

	    function prepareSelection(cm, primary) {
	      if (primary === void 0) primary = true;
	      var doc = cm.doc,
	          result = {};
	      var curFragment = result.cursors = document.createDocumentFragment();
	      var selFragment = result.selection = document.createDocumentFragment();

	      for (var i = 0; i < doc.sel.ranges.length; i++) {
	        if (!primary && i == doc.sel.primIndex) {
	          continue;
	        }

	        var range = doc.sel.ranges[i];

	        if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) {
	          continue;
	        }

	        var collapsed = range.empty();

	        if (collapsed || cm.options.showCursorWhenSelecting) {
	          drawSelectionCursor(cm, range.head, curFragment);
	        }

	        if (!collapsed) {
	          drawSelectionRange(cm, range, selFragment);
	        }
	      }

	      return result;
	    } // Draws a cursor for the given range


	    function drawSelectionCursor(cm, head, output) {
	      var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
	      var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
	      cursor.style.left = pos.left + "px";
	      cursor.style.top = pos.top + "px";
	      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

	      if (pos.other) {
	        // Secondary cursor, shown when on a 'jump' in bi-directional text
	        var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
	        otherCursor.style.display = "";
	        otherCursor.style.left = pos.other.left + "px";
	        otherCursor.style.top = pos.other.top + "px";
	        otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
	      }
	    }

	    function cmpCoords(a, b) {
	      return a.top - b.top || a.left - b.left;
	    } // Draws the given range as a highlighted selection


	    function drawSelectionRange(cm, range, output) {
	      var display = cm.display,
	          doc = cm.doc;
	      var fragment = document.createDocumentFragment();
	      var padding = paddingH(cm.display),
	          leftSide = padding.left;
	      var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
	      var docLTR = doc.direction == "ltr";

	      function add(left, top, width, bottom) {
	        if (top < 0) {
	          top = 0;
	        }

	        top = Math.round(top);
	        bottom = Math.round(bottom);
	        fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
	      }

	      function drawForLine(line, fromArg, toArg) {
	        var lineObj = getLine(doc, line);
	        var lineLen = lineObj.text.length;
	        var start, end;

	        function coords(ch, bias) {
	          return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
	        }

	        function wrapX(pos, dir, side) {
	          var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
	          var prop = dir == "ltr" == (side == "after") ? "left" : "right";
	          var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
	          return coords(ch, prop)[prop];
	        }

	        var order = getOrder(lineObj, doc.direction);
	        iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
	          var ltr = dir == "ltr";
	          var fromPos = coords(from, ltr ? "left" : "right");
	          var toPos = coords(to - 1, ltr ? "right" : "left");
	          var openStart = fromArg == null && from == 0,
	              openEnd = toArg == null && to == lineLen;
	          var first = i == 0,
	              last = !order || i == order.length - 1;

	          if (toPos.top - fromPos.top <= 3) {
	            // Single line
	            var openLeft = (docLTR ? openStart : openEnd) && first;
	            var openRight = (docLTR ? openEnd : openStart) && last;
	            var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
	            var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
	            add(left, fromPos.top, right - left, fromPos.bottom);
	          } else {
	            // Multiple lines
	            var topLeft, topRight, botLeft, botRight;

	            if (ltr) {
	              topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
	              topRight = docLTR ? rightSide : wrapX(from, dir, "before");
	              botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
	              botRight = docLTR && openEnd && last ? rightSide : toPos.right;
	            } else {
	              topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
	              topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
	              botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
	              botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
	            }

	            add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);

	            if (fromPos.bottom < toPos.top) {
	              add(leftSide, fromPos.bottom, null, toPos.top);
	            }

	            add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
	          }

	          if (!start || cmpCoords(fromPos, start) < 0) {
	            start = fromPos;
	          }

	          if (cmpCoords(toPos, start) < 0) {
	            start = toPos;
	          }

	          if (!end || cmpCoords(fromPos, end) < 0) {
	            end = fromPos;
	          }

	          if (cmpCoords(toPos, end) < 0) {
	            end = toPos;
	          }
	        });
	        return {
	          start: start,
	          end: end
	        };
	      }

	      var sFrom = range.from(),
	          sTo = range.to();

	      if (sFrom.line == sTo.line) {
	        drawForLine(sFrom.line, sFrom.ch, sTo.ch);
	      } else {
	        var fromLine = getLine(doc, sFrom.line),
	            toLine = getLine(doc, sTo.line);
	        var singleVLine = visualLine(fromLine) == visualLine(toLine);
	        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
	        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;

	        if (singleVLine) {
	          if (leftEnd.top < rightStart.top - 2) {
	            add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
	            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
	          } else {
	            add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
	          }
	        }

	        if (leftEnd.bottom < rightStart.top) {
	          add(leftSide, leftEnd.bottom, null, rightStart.top);
	        }
	      }

	      output.appendChild(fragment);
	    } // Cursor-blinking


	    function restartBlink(cm) {
	      if (!cm.state.focused) {
	        return;
	      }

	      var display = cm.display;
	      clearInterval(display.blinker);
	      var on = true;
	      display.cursorDiv.style.visibility = "";

	      if (cm.options.cursorBlinkRate > 0) {
	        display.blinker = setInterval(function () {
	          if (!cm.hasFocus()) {
	            onBlur(cm);
	          }

	          display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
	        }, cm.options.cursorBlinkRate);
	      } else if (cm.options.cursorBlinkRate < 0) {
	        display.cursorDiv.style.visibility = "hidden";
	      }
	    }

	    function ensureFocus(cm) {
	      if (!cm.hasFocus()) {
	        cm.display.input.focus();

	        if (!cm.state.focused) {
	          onFocus(cm);
	        }
	      }
	    }

	    function delayBlurEvent(cm) {
	      cm.state.delayingBlurEvent = true;
	      setTimeout(function () {
	        if (cm.state.delayingBlurEvent) {
	          cm.state.delayingBlurEvent = false;

	          if (cm.state.focused) {
	            onBlur(cm);
	          }
	        }
	      }, 100);
	    }

	    function onFocus(cm, e) {
	      if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
	        cm.state.delayingBlurEvent = false;
	      }

	      if (cm.options.readOnly == "nocursor") {
	        return;
	      }

	      if (!cm.state.focused) {
	        signal(cm, "focus", cm, e);
	        cm.state.focused = true;
	        addClass(cm.display.wrapper, "CodeMirror-focused"); // This test prevents this from firing when a context
	        // menu is closed (since the input reset would kill the
	        // select-all detection hack)

	        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	          cm.display.input.reset();

	          if (webkit) {
	            setTimeout(function () {
	              return cm.display.input.reset(true);
	            }, 20);
	          } // Issue #1730

	        }

	        cm.display.input.receivedFocus();
	      }

	      restartBlink(cm);
	    }

	    function onBlur(cm, e) {
	      if (cm.state.delayingBlurEvent) {
	        return;
	      }

	      if (cm.state.focused) {
	        signal(cm, "blur", cm, e);
	        cm.state.focused = false;
	        rmClass(cm.display.wrapper, "CodeMirror-focused");
	      }

	      clearInterval(cm.display.blinker);
	      setTimeout(function () {
	        if (!cm.state.focused) {
	          cm.display.shift = false;
	        }
	      }, 150);
	    } // Read the actual heights of the rendered lines, and update their
	    // stored heights to match.


	    function updateHeightsInViewport(cm) {
	      var display = cm.display;
	      var prevBottom = display.lineDiv.offsetTop;

	      for (var i = 0; i < display.view.length; i++) {
	        var cur = display.view[i],
	            wrapping = cm.options.lineWrapping;
	        var height = void 0,
	            width = 0;

	        if (cur.hidden) {
	          continue;
	        }

	        if (ie && ie_version < 8) {
	          var bot = cur.node.offsetTop + cur.node.offsetHeight;
	          height = bot - prevBottom;
	          prevBottom = bot;
	        } else {
	          var box = cur.node.getBoundingClientRect();
	          height = box.bottom - box.top; // Check that lines don't extend past the right of the current
	          // editor width

	          if (!wrapping && cur.text.firstChild) {
	            width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
	          }
	        }

	        var diff = cur.line.height - height;

	        if (diff > .005 || diff < -.005) {
	          updateLineHeight(cur.line, height);
	          updateWidgetHeight(cur.line);

	          if (cur.rest) {
	            for (var j = 0; j < cur.rest.length; j++) {
	              updateWidgetHeight(cur.rest[j]);
	            }
	          }
	        }

	        if (width > cm.display.sizerWidth) {
	          var chWidth = Math.ceil(width / charWidth(cm.display));

	          if (chWidth > cm.display.maxLineLength) {
	            cm.display.maxLineLength = chWidth;
	            cm.display.maxLine = cur.line;
	            cm.display.maxLineChanged = true;
	          }
	        }
	      }
	    } // Read and store the height of line widgets associated with the
	    // given line.


	    function updateWidgetHeight(line) {
	      if (line.widgets) {
	        for (var i = 0; i < line.widgets.length; ++i) {
	          var w = line.widgets[i],
	              parent = w.node.parentNode;

	          if (parent) {
	            w.height = parent.offsetHeight;
	          }
	        }
	      }
	    } // Compute the lines that are visible in a given viewport (defaults
	    // the the current scroll position). viewport may contain top,
	    // height, and ensure (see op.scrollToPos) properties.


	    function visibleLines(display, doc, viewport) {
	      var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
	      top = Math.floor(top - paddingTop(display));
	      var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
	      var from = lineAtHeight(doc, top),
	          to = lineAtHeight(doc, bottom); // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	      // forces those lines into the viewport (if possible).

	      if (viewport && viewport.ensure) {
	        var ensureFrom = viewport.ensure.from.line,
	            ensureTo = viewport.ensure.to.line;

	        if (ensureFrom < from) {
	          from = ensureFrom;
	          to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
	        } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	          from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
	          to = ensureTo;
	        }
	      }

	      return {
	        from: from,
	        to: Math.max(to, from + 1)
	      };
	    } // SCROLLING THINGS INTO VIEW
	    // If an editor sits on the top or bottom of the window, partially
	    // scrolled out of view, this ensures that the cursor is visible.


	    function maybeScrollWindow(cm, rect) {
	      if (signalDOMEvent(cm, "scrollCursorIntoView")) {
	        return;
	      }

	      var display = cm.display,
	          box = display.sizer.getBoundingClientRect(),
	          doScroll = null;

	      if (rect.top + box.top < 0) {
	        doScroll = true;
	      } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
	        doScroll = false;
	      }

	      if (doScroll != null && !phantom) {
	        var scrollNode = elt("div", "\u200b", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
	        cm.display.lineSpace.appendChild(scrollNode);
	        scrollNode.scrollIntoView(doScroll);
	        cm.display.lineSpace.removeChild(scrollNode);
	      }
	    } // Scroll a given position into view (immediately), verifying that
	    // it actually became visible (as line heights are accurately
	    // measured, the position of something may 'drift' during drawing).


	    function scrollPosIntoView(cm, pos, end, margin) {
	      if (margin == null) {
	        margin = 0;
	      }

	      var rect;

	      if (!cm.options.lineWrapping && pos == end) {
	        // Set pos and end to the cursor positions around the character pos sticks to
	        // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
	        // If pos == Pos(_, 0, "before"), pos and end are unchanged
	        pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
	        end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
	      }

	      for (var limit = 0; limit < 5; limit++) {
	        var changed = false;
	        var coords = cursorCoords(cm, pos);
	        var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
	        rect = {
	          left: Math.min(coords.left, endCoords.left),
	          top: Math.min(coords.top, endCoords.top) - margin,
	          right: Math.max(coords.left, endCoords.left),
	          bottom: Math.max(coords.bottom, endCoords.bottom) + margin
	        };
	        var scrollPos = calculateScrollPos(cm, rect);
	        var startTop = cm.doc.scrollTop,
	            startLeft = cm.doc.scrollLeft;

	        if (scrollPos.scrollTop != null) {
	          updateScrollTop(cm, scrollPos.scrollTop);

	          if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
	            changed = true;
	          }
	        }

	        if (scrollPos.scrollLeft != null) {
	          setScrollLeft(cm, scrollPos.scrollLeft);

	          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
	            changed = true;
	          }
	        }

	        if (!changed) {
	          break;
	        }
	      }

	      return rect;
	    } // Scroll a given set of coordinates into view (immediately).


	    function scrollIntoView(cm, rect) {
	      var scrollPos = calculateScrollPos(cm, rect);

	      if (scrollPos.scrollTop != null) {
	        updateScrollTop(cm, scrollPos.scrollTop);
	      }

	      if (scrollPos.scrollLeft != null) {
	        setScrollLeft(cm, scrollPos.scrollLeft);
	      }
	    } // Calculate a new scroll position needed to scroll the given
	    // rectangle into view. Returns an object with scrollTop and
	    // scrollLeft properties. When these are undefined, the
	    // vertical/horizontal position does not need to be adjusted.


	    function calculateScrollPos(cm, rect) {
	      var display = cm.display,
	          snapMargin = textHeight(cm.display);

	      if (rect.top < 0) {
	        rect.top = 0;
	      }

	      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
	      var screen = displayHeight(cm),
	          result = {};

	      if (rect.bottom - rect.top > screen) {
	        rect.bottom = rect.top + screen;
	      }

	      var docBottom = cm.doc.height + paddingVert(display);
	      var atTop = rect.top < snapMargin,
	          atBottom = rect.bottom > docBottom - snapMargin;

	      if (rect.top < screentop) {
	        result.scrollTop = atTop ? 0 : rect.top;
	      } else if (rect.bottom > screentop + screen) {
	        var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);

	        if (newTop != screentop) {
	          result.scrollTop = newTop;
	        }
	      }

	      var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
	      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
	      var screenw = displayWidth(cm) - display.gutters.offsetWidth;
	      var tooWide = rect.right - rect.left > screenw;

	      if (tooWide) {
	        rect.right = rect.left + screenw;
	      }

	      if (rect.left < 10) {
	        result.scrollLeft = 0;
	      } else if (rect.left < screenleft) {
	        result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
	      } else if (rect.right > screenw + screenleft - 3) {
	        result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
	      }

	      return result;
	    } // Store a relative adjustment to the scroll position in the current
	    // operation (to be applied when the operation finishes).


	    function addToScrollTop(cm, top) {
	      if (top == null) {
	        return;
	      }

	      resolveScrollToPos(cm);
	      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
	    } // Make sure that at the end of the operation the current cursor is
	    // shown.


	    function ensureCursorVisible(cm) {
	      resolveScrollToPos(cm);
	      var cur = cm.getCursor();
	      cm.curOp.scrollToPos = {
	        from: cur,
	        to: cur,
	        margin: cm.options.cursorScrollMargin
	      };
	    }

	    function scrollToCoords(cm, x, y) {
	      if (x != null || y != null) {
	        resolveScrollToPos(cm);
	      }

	      if (x != null) {
	        cm.curOp.scrollLeft = x;
	      }

	      if (y != null) {
	        cm.curOp.scrollTop = y;
	      }
	    }

	    function scrollToRange(cm, range) {
	      resolveScrollToPos(cm);
	      cm.curOp.scrollToPos = range;
	    } // When an operation has its scrollToPos property set, and another
	    // scroll action is applied before the end of the operation, this
	    // 'simulates' scrolling that position into view in a cheap way, so
	    // that the effect of intermediate scroll commands is not ignored.


	    function resolveScrollToPos(cm) {
	      var range = cm.curOp.scrollToPos;

	      if (range) {
	        cm.curOp.scrollToPos = null;
	        var from = estimateCoords(cm, range.from),
	            to = estimateCoords(cm, range.to);
	        scrollToCoordsRange(cm, from, to, range.margin);
	      }
	    }

	    function scrollToCoordsRange(cm, from, to, margin) {
	      var sPos = calculateScrollPos(cm, {
	        left: Math.min(from.left, to.left),
	        top: Math.min(from.top, to.top) - margin,
	        right: Math.max(from.right, to.right),
	        bottom: Math.max(from.bottom, to.bottom) + margin
	      });
	      scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
	    } // Sync the scrollable area and scrollbars, ensure the viewport
	    // covers the visible area.


	    function updateScrollTop(cm, val) {
	      if (Math.abs(cm.doc.scrollTop - val) < 2) {
	        return;
	      }

	      if (!gecko) {
	        updateDisplaySimple(cm, {
	          top: val
	        });
	      }

	      setScrollTop(cm, val, true);

	      if (gecko) {
	        updateDisplaySimple(cm);
	      }

	      startWorker(cm, 100);
	    }

	    function setScrollTop(cm, val, forceScroll) {
	      val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));

	      if (cm.display.scroller.scrollTop == val && !forceScroll) {
	        return;
	      }

	      cm.doc.scrollTop = val;
	      cm.display.scrollbars.setScrollTop(val);

	      if (cm.display.scroller.scrollTop != val) {
	        cm.display.scroller.scrollTop = val;
	      }
	    } // Sync scroller and scrollbar, ensure the gutter elements are
	    // aligned.


	    function setScrollLeft(cm, val, isScroller, forceScroll) {
	      val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));

	      if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
	        return;
	      }

	      cm.doc.scrollLeft = val;
	      alignHorizontally(cm);

	      if (cm.display.scroller.scrollLeft != val) {
	        cm.display.scroller.scrollLeft = val;
	      }

	      cm.display.scrollbars.setScrollLeft(val);
	    } // SCROLLBARS
	    // Prepare DOM reads needed to update the scrollbars. Done in one
	    // shot to minimize update/measure roundtrips.


	    function measureForScrollbars(cm) {
	      var d = cm.display,
	          gutterW = d.gutters.offsetWidth;
	      var docH = Math.round(cm.doc.height + paddingVert(cm.display));
	      return {
	        clientHeight: d.scroller.clientHeight,
	        viewHeight: d.wrapper.clientHeight,
	        scrollWidth: d.scroller.scrollWidth,
	        clientWidth: d.scroller.clientWidth,
	        viewWidth: d.wrapper.clientWidth,
	        barLeft: cm.options.fixedGutter ? gutterW : 0,
	        docHeight: docH,
	        scrollHeight: docH + scrollGap(cm) + d.barHeight,
	        nativeBarWidth: d.nativeBarWidth,
	        gutterWidth: gutterW
	      };
	    }

	    var NativeScrollbars = function (place, scroll, cm) {
	      this.cm = cm;
	      var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
	      var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
	      vert.tabIndex = horiz.tabIndex = -1;
	      place(vert);
	      place(horiz);
	      on(vert, "scroll", function () {
	        if (vert.clientHeight) {
	          scroll(vert.scrollTop, "vertical");
	        }
	      });
	      on(horiz, "scroll", function () {
	        if (horiz.clientWidth) {
	          scroll(horiz.scrollLeft, "horizontal");
	        }
	      });
	      this.checkedZeroWidth = false; // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).

	      if (ie && ie_version < 8) {
	        this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
	      }
	    };

	    NativeScrollbars.prototype.update = function (measure) {
	      var needsH = measure.scrollWidth > measure.clientWidth + 1;
	      var needsV = measure.scrollHeight > measure.clientHeight + 1;
	      var sWidth = measure.nativeBarWidth;

	      if (needsV) {
	        this.vert.style.display = "block";
	        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
	        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0); // A bug in IE8 can cause this value to be negative, so guard it.

	        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
	      } else {
	        this.vert.style.display = "";
	        this.vert.firstChild.style.height = "0";
	      }

	      if (needsH) {
	        this.horiz.style.display = "block";
	        this.horiz.style.right = needsV ? sWidth + "px" : "0";
	        this.horiz.style.left = measure.barLeft + "px";
	        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
	        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
	      } else {
	        this.horiz.style.display = "";
	        this.horiz.firstChild.style.width = "0";
	      }

	      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
	        if (sWidth == 0) {
	          this.zeroWidthHack();
	        }

	        this.checkedZeroWidth = true;
	      }

	      return {
	        right: needsV ? sWidth : 0,
	        bottom: needsH ? sWidth : 0
	      };
	    };

	    NativeScrollbars.prototype.setScrollLeft = function (pos) {
	      if (this.horiz.scrollLeft != pos) {
	        this.horiz.scrollLeft = pos;
	      }

	      if (this.disableHoriz) {
	        this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
	      }
	    };

	    NativeScrollbars.prototype.setScrollTop = function (pos) {
	      if (this.vert.scrollTop != pos) {
	        this.vert.scrollTop = pos;
	      }

	      if (this.disableVert) {
	        this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
	      }
	    };

	    NativeScrollbars.prototype.zeroWidthHack = function () {
	      var w = mac && !mac_geMountainLion ? "12px" : "18px";
	      this.horiz.style.height = this.vert.style.width = w;
	      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
	      this.disableHoriz = new Delayed();
	      this.disableVert = new Delayed();
	    };

	    NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
	      bar.style.pointerEvents = "auto";

	      function maybeDisable() {
	        // To find out whether the scrollbar is still visible, we
	        // check whether the element under the pixel in the bottom
	        // right corner of the scrollbar box is the scrollbar box
	        // itself (when the bar is still visible) or its filler child
	        // (when the bar is hidden). If it is still visible, we keep
	        // it enabled, if it's hidden, we disable pointer events.
	        var box = bar.getBoundingClientRect();
	        var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);

	        if (elt != bar) {
	          bar.style.pointerEvents = "none";
	        } else {
	          delay.set(1000, maybeDisable);
	        }
	      }

	      delay.set(1000, maybeDisable);
	    };

	    NativeScrollbars.prototype.clear = function () {
	      var parent = this.horiz.parentNode;
	      parent.removeChild(this.horiz);
	      parent.removeChild(this.vert);
	    };

	    var NullScrollbars = function () {};

	    NullScrollbars.prototype.update = function () {
	      return {
	        bottom: 0,
	        right: 0
	      };
	    };

	    NullScrollbars.prototype.setScrollLeft = function () {};

	    NullScrollbars.prototype.setScrollTop = function () {};

	    NullScrollbars.prototype.clear = function () {};

	    function updateScrollbars(cm, measure) {
	      if (!measure) {
	        measure = measureForScrollbars(cm);
	      }

	      var startWidth = cm.display.barWidth,
	          startHeight = cm.display.barHeight;
	      updateScrollbarsInner(cm, measure);

	      for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	        if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
	          updateHeightsInViewport(cm);
	        }

	        updateScrollbarsInner(cm, measureForScrollbars(cm));
	        startWidth = cm.display.barWidth;
	        startHeight = cm.display.barHeight;
	      }
	    } // Re-synchronize the fake scrollbars with the actual size of the
	    // content.


	    function updateScrollbarsInner(cm, measure) {
	      var d = cm.display;
	      var sizes = d.scrollbars.update(measure);
	      d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
	      d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
	      d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

	      if (sizes.right && sizes.bottom) {
	        d.scrollbarFiller.style.display = "block";
	        d.scrollbarFiller.style.height = sizes.bottom + "px";
	        d.scrollbarFiller.style.width = sizes.right + "px";
	      } else {
	        d.scrollbarFiller.style.display = "";
	      }

	      if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	        d.gutterFiller.style.display = "block";
	        d.gutterFiller.style.height = sizes.bottom + "px";
	        d.gutterFiller.style.width = measure.gutterWidth + "px";
	      } else {
	        d.gutterFiller.style.display = "";
	      }
	    }

	    var scrollbarModel = {
	      "native": NativeScrollbars,
	      "null": NullScrollbars
	    };

	    function initScrollbars(cm) {
	      if (cm.display.scrollbars) {
	        cm.display.scrollbars.clear();

	        if (cm.display.scrollbars.addClass) {
	          rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
	        }
	      }

	      cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
	        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller); // Prevent clicks in the scrollbars from killing focus

	        on(node, "mousedown", function () {
	          if (cm.state.focused) {
	            setTimeout(function () {
	              return cm.display.input.focus();
	            }, 0);
	          }
	        });
	        node.setAttribute("cm-not-content", "true");
	      }, function (pos, axis) {
	        if (axis == "horizontal") {
	          setScrollLeft(cm, pos);
	        } else {
	          updateScrollTop(cm, pos);
	        }
	      }, cm);

	      if (cm.display.scrollbars.addClass) {
	        addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
	      }
	    } // Operations are used to wrap a series of changes to the editor
	    // state in such a way that each change won't have to update the
	    // cursor and display (which would be awkward, slow, and
	    // error-prone). Instead, display updates are batched and then all
	    // combined and executed at once.


	    var nextOpId = 0; // Start a new operation.

	    function startOperation(cm) {
	      cm.curOp = {
	        cm: cm,
	        viewChanged: false,
	        // Flag that indicates that lines might need to be redrawn
	        startHeight: cm.doc.height,
	        // Used to detect need to update scrollbar
	        forceUpdate: false,
	        // Used to force a redraw
	        updateInput: 0,
	        // Whether to reset the input textarea
	        typing: false,
	        // Whether this reset should be careful to leave existing text (for compositing)
	        changeObjs: null,
	        // Accumulated changes, for firing change events
	        cursorActivityHandlers: null,
	        // Set of handlers to fire cursorActivity on
	        cursorActivityCalled: 0,
	        // Tracks which cursorActivity handlers have been called already
	        selectionChanged: false,
	        // Whether the selection needs to be redrawn
	        updateMaxLine: false,
	        // Set when the widest line needs to be determined anew
	        scrollLeft: null,
	        scrollTop: null,
	        // Intermediate scroll position, not pushed to DOM yet
	        scrollToPos: null,
	        // Used to scroll to a specific position
	        focus: false,
	        id: ++nextOpId // Unique ID

	      };
	      pushOperation(cm.curOp);
	    } // Finish an operation, updating the display and signalling delayed events


	    function endOperation(cm) {
	      var op = cm.curOp;

	      if (op) {
	        finishOperation(op, function (group) {
	          for (var i = 0; i < group.ops.length; i++) {
	            group.ops[i].cm.curOp = null;
	          }

	          endOperations(group);
	        });
	      }
	    } // The DOM updates done when an operation finishes are batched so
	    // that the minimum number of relayouts are required.


	    function endOperations(group) {
	      var ops = group.ops;

	      for (var i = 0; i < ops.length; i++) // Read DOM
	      {
	        endOperation_R1(ops[i]);
	      }

	      for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
	      {
	        endOperation_W1(ops[i$1]);
	      }

	      for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
	      {
	        endOperation_R2(ops[i$2]);
	      }

	      for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
	      {
	        endOperation_W2(ops[i$3]);
	      }

	      for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
	      {
	        endOperation_finish(ops[i$4]);
	      }
	    }

	    function endOperation_R1(op) {
	      var cm = op.cm,
	          display = cm.display;
	      maybeClipScrollbars(cm);

	      if (op.updateMaxLine) {
	        findMaxLine(cm);
	      }

	      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
	      op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
	        top: op.scrollTop,
	        ensure: op.scrollToPos
	      }, op.forceUpdate);
	    }

	    function endOperation_W1(op) {
	      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
	    }

	    function endOperation_R2(op) {
	      var cm = op.cm,
	          display = cm.display;

	      if (op.updatedDisplay) {
	        updateHeightsInViewport(cm);
	      }

	      op.barMeasure = measureForScrollbars(cm); // If the max line changed since it was last measured, measure it,
	      // and ensure the document's width matches it.
	      // updateDisplay_W2 will use these properties to do the actual resizing

	      if (display.maxLineChanged && !cm.options.lineWrapping) {
	        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
	        cm.display.sizerWidth = op.adjustWidthTo;
	        op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
	        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
	      }

	      if (op.updatedDisplay || op.selectionChanged) {
	        op.preparedSelection = display.input.prepareSelection();
	      }
	    }

	    function endOperation_W2(op) {
	      var cm = op.cm;

	      if (op.adjustWidthTo != null) {
	        cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";

	        if (op.maxScrollLeft < cm.doc.scrollLeft) {
	          setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
	        }

	        cm.display.maxLineChanged = false;
	      }

	      var takeFocus = op.focus && op.focus == activeElt();

	      if (op.preparedSelection) {
	        cm.display.input.showSelection(op.preparedSelection, takeFocus);
	      }

	      if (op.updatedDisplay || op.startHeight != cm.doc.height) {
	        updateScrollbars(cm, op.barMeasure);
	      }

	      if (op.updatedDisplay) {
	        setDocumentHeight(cm, op.barMeasure);
	      }

	      if (op.selectionChanged) {
	        restartBlink(cm);
	      }

	      if (cm.state.focused && op.updateInput) {
	        cm.display.input.reset(op.typing);
	      }

	      if (takeFocus) {
	        ensureFocus(op.cm);
	      }
	    }

	    function endOperation_finish(op) {
	      var cm = op.cm,
	          display = cm.display,
	          doc = cm.doc;

	      if (op.updatedDisplay) {
	        postUpdateDisplay(cm, op.update);
	      } // Abort mouse wheel delta measurement, when scrolling explicitly


	      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
	        display.wheelStartX = display.wheelStartY = null;
	      } // Propagate the scroll position to the actual DOM scroller


	      if (op.scrollTop != null) {
	        setScrollTop(cm, op.scrollTop, op.forceScroll);
	      }

	      if (op.scrollLeft != null) {
	        setScrollLeft(cm, op.scrollLeft, true, true);
	      } // If we need to scroll a specific position into view, do so.


	      if (op.scrollToPos) {
	        var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
	        maybeScrollWindow(cm, rect);
	      } // Fire events for markers that are hidden/unidden by editing or
	      // undoing


	      var hidden = op.maybeHiddenMarkers,
	          unhidden = op.maybeUnhiddenMarkers;

	      if (hidden) {
	        for (var i = 0; i < hidden.length; ++i) {
	          if (!hidden[i].lines.length) {
	            signal(hidden[i], "hide");
	          }
	        }
	      }

	      if (unhidden) {
	        for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
	          if (unhidden[i$1].lines.length) {
	            signal(unhidden[i$1], "unhide");
	          }
	        }
	      }

	      if (display.wrapper.offsetHeight) {
	        doc.scrollTop = cm.display.scroller.scrollTop;
	      } // Fire change events, and delayed event handlers


	      if (op.changeObjs) {
	        signal(cm, "changes", cm, op.changeObjs);
	      }

	      if (op.update) {
	        op.update.finish();
	      }
	    } // Run the given function in an operation


	    function runInOp(cm, f) {
	      if (cm.curOp) {
	        return f();
	      }

	      startOperation(cm);

	      try {
	        return f();
	      } finally {
	        endOperation(cm);
	      }
	    } // Wraps a function in an operation. Returns the wrapped function.


	    function operation(cm, f) {
	      return function () {
	        if (cm.curOp) {
	          return f.apply(cm, arguments);
	        }

	        startOperation(cm);

	        try {
	          return f.apply(cm, arguments);
	        } finally {
	          endOperation(cm);
	        }
	      };
	    } // Used to add methods to editor and doc instances, wrapping them in
	    // operations.


	    function methodOp(f) {
	      return function () {
	        if (this.curOp) {
	          return f.apply(this, arguments);
	        }

	        startOperation(this);

	        try {
	          return f.apply(this, arguments);
	        } finally {
	          endOperation(this);
	        }
	      };
	    }

	    function docMethodOp(f) {
	      return function () {
	        var cm = this.cm;

	        if (!cm || cm.curOp) {
	          return f.apply(this, arguments);
	        }

	        startOperation(cm);

	        try {
	          return f.apply(this, arguments);
	        } finally {
	          endOperation(cm);
	        }
	      };
	    } // HIGHLIGHT WORKER


	    function startWorker(cm, time) {
	      if (cm.doc.highlightFrontier < cm.display.viewTo) {
	        cm.state.highlight.set(time, bind(highlightWorker, cm));
	      }
	    }

	    function highlightWorker(cm) {
	      var doc = cm.doc;

	      if (doc.highlightFrontier >= cm.display.viewTo) {
	        return;
	      }

	      var end = +new Date() + cm.options.workTime;
	      var context = getContextBefore(cm, doc.highlightFrontier);
	      var changedLines = [];
	      doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
	        if (context.line >= cm.display.viewFrom) {
	          // Visible
	          var oldStyles = line.styles;
	          var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
	          var highlighted = highlightLine(cm, line, context, true);

	          if (resetState) {
	            context.state = resetState;
	          }

	          line.styles = highlighted.styles;
	          var oldCls = line.styleClasses,
	              newCls = highlighted.classes;

	          if (newCls) {
	            line.styleClasses = newCls;
	          } else if (oldCls) {
	            line.styleClasses = null;
	          }

	          var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);

	          for (var i = 0; !ischange && i < oldStyles.length; ++i) {
	            ischange = oldStyles[i] != line.styles[i];
	          }

	          if (ischange) {
	            changedLines.push(context.line);
	          }

	          line.stateAfter = context.save();
	          context.nextLine();
	        } else {
	          if (line.text.length <= cm.options.maxHighlightLength) {
	            processLine(cm, line.text, context);
	          }

	          line.stateAfter = context.line % 5 == 0 ? context.save() : null;
	          context.nextLine();
	        }

	        if (+new Date() > end) {
	          startWorker(cm, cm.options.workDelay);
	          return true;
	        }
	      });
	      doc.highlightFrontier = context.line;
	      doc.modeFrontier = Math.max(doc.modeFrontier, context.line);

	      if (changedLines.length) {
	        runInOp(cm, function () {
	          for (var i = 0; i < changedLines.length; i++) {
	            regLineChange(cm, changedLines[i], "text");
	          }
	        });
	      }
	    } // DISPLAY DRAWING


	    var DisplayUpdate = function (cm, viewport, force) {
	      var display = cm.display;
	      this.viewport = viewport; // Store some values that we'll need later (but don't want to force a relayout for)

	      this.visible = visibleLines(display, cm.doc, viewport);
	      this.editorIsHidden = !display.wrapper.offsetWidth;
	      this.wrapperHeight = display.wrapper.clientHeight;
	      this.wrapperWidth = display.wrapper.clientWidth;
	      this.oldDisplayWidth = displayWidth(cm);
	      this.force = force;
	      this.dims = getDimensions(cm);
	      this.events = [];
	    };

	    DisplayUpdate.prototype.signal = function (emitter, type) {
	      if (hasHandler(emitter, type)) {
	        this.events.push(arguments);
	      }
	    };

	    DisplayUpdate.prototype.finish = function () {
	      for (var i = 0; i < this.events.length; i++) {
	        signal.apply(null, this.events[i]);
	      }
	    };

	    function maybeClipScrollbars(cm) {
	      var display = cm.display;

	      if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
	        display.heightForcer.style.height = scrollGap(cm) + "px";
	        display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
	        display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
	        display.scrollbarsClipped = true;
	      }
	    }

	    function selectionSnapshot(cm) {
	      if (cm.hasFocus()) {
	        return null;
	      }

	      var active = activeElt();

	      if (!active || !contains(cm.display.lineDiv, active)) {
	        return null;
	      }

	      var result = {
	        activeElt: active
	      };

	      if (window.getSelection) {
	        var sel = window.getSelection();

	        if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
	          result.anchorNode = sel.anchorNode;
	          result.anchorOffset = sel.anchorOffset;
	          result.focusNode = sel.focusNode;
	          result.focusOffset = sel.focusOffset;
	        }
	      }

	      return result;
	    }

	    function restoreSelection(snapshot) {
	      if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
	        return;
	      }

	      snapshot.activeElt.focus();

	      if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
	        var sel = window.getSelection(),
	            range = document.createRange();
	        range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
	        range.collapse(false);
	        sel.removeAllRanges();
	        sel.addRange(range);
	        sel.extend(snapshot.focusNode, snapshot.focusOffset);
	      }
	    } // Does the actual updating of the line display. Bails out
	    // (returning false) when there is nothing to be done and forced is
	    // false.


	    function updateDisplayIfNeeded(cm, update) {
	      var display = cm.display,
	          doc = cm.doc;

	      if (update.editorIsHidden) {
	        resetView(cm);
	        return false;
	      } // Bail out if the visible area is already rendered and nothing changed.


	      if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
	        return false;
	      }

	      if (maybeUpdateLineNumberWidth(cm)) {
	        resetView(cm);
	        update.dims = getDimensions(cm);
	      } // Compute a suitable new viewport (from & to)


	      var end = doc.first + doc.size;
	      var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
	      var to = Math.min(end, update.visible.to + cm.options.viewportMargin);

	      if (display.viewFrom < from && from - display.viewFrom < 20) {
	        from = Math.max(doc.first, display.viewFrom);
	      }

	      if (display.viewTo > to && display.viewTo - to < 20) {
	        to = Math.min(end, display.viewTo);
	      }

	      if (sawCollapsedSpans) {
	        from = visualLineNo(cm.doc, from);
	        to = visualLineEndNo(cm.doc, to);
	      }

	      var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
	      adjustView(cm, from, to);
	      display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom)); // Position the mover div to align with the current scroll position

	      cm.display.mover.style.top = display.viewOffset + "px";
	      var toUpdate = countDirtyView(cm);

	      if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
	        return false;
	      } // For big changes, we hide the enclosing element during the
	      // update, since that speeds up the operations on most browsers.


	      var selSnapshot = selectionSnapshot(cm);

	      if (toUpdate > 4) {
	        display.lineDiv.style.display = "none";
	      }

	      patchDisplay(cm, display.updateLineNumbers, update.dims);

	      if (toUpdate > 4) {
	        display.lineDiv.style.display = "";
	      }

	      display.renderedView = display.view; // There might have been a widget with a focused element that got
	      // hidden or updated, if so re-focus it.

	      restoreSelection(selSnapshot); // Prevent selection and cursors from interfering with the scroll
	      // width and height.

	      removeChildren(display.cursorDiv);
	      removeChildren(display.selectionDiv);
	      display.gutters.style.height = display.sizer.style.minHeight = 0;

	      if (different) {
	        display.lastWrapHeight = update.wrapperHeight;
	        display.lastWrapWidth = update.wrapperWidth;
	        startWorker(cm, 400);
	      }

	      display.updateLineNumbers = null;
	      return true;
	    }

	    function postUpdateDisplay(cm, update) {
	      var viewport = update.viewport;

	      for (var first = true;; first = false) {
	        if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
	          // Clip forced viewport to actual scrollable area.
	          if (viewport && viewport.top != null) {
	            viewport = {
	              top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
	            };
	          } // Updated line heights might result in the drawn area not
	          // actually covering the viewport. Keep looping until it does.


	          update.visible = visibleLines(cm.display, cm.doc, viewport);

	          if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
	            break;
	          }
	        } else if (first) {
	          update.visible = visibleLines(cm.display, cm.doc, viewport);
	        }

	        if (!updateDisplayIfNeeded(cm, update)) {
	          break;
	        }

	        updateHeightsInViewport(cm);
	        var barMeasure = measureForScrollbars(cm);
	        updateSelection(cm);
	        updateScrollbars(cm, barMeasure);
	        setDocumentHeight(cm, barMeasure);
	        update.force = false;
	      }

	      update.signal(cm, "update", cm);

	      if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	        update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
	        cm.display.reportedViewFrom = cm.display.viewFrom;
	        cm.display.reportedViewTo = cm.display.viewTo;
	      }
	    }

	    function updateDisplaySimple(cm, viewport) {
	      var update = new DisplayUpdate(cm, viewport);

	      if (updateDisplayIfNeeded(cm, update)) {
	        updateHeightsInViewport(cm);
	        postUpdateDisplay(cm, update);
	        var barMeasure = measureForScrollbars(cm);
	        updateSelection(cm);
	        updateScrollbars(cm, barMeasure);
	        setDocumentHeight(cm, barMeasure);
	        update.finish();
	      }
	    } // Sync the actual display DOM structure with display.view, removing
	    // nodes for lines that are no longer in view, and creating the ones
	    // that are not there yet, and updating the ones that are out of
	    // date.


	    function patchDisplay(cm, updateNumbersFrom, dims) {
	      var display = cm.display,
	          lineNumbers = cm.options.lineNumbers;
	      var container = display.lineDiv,
	          cur = container.firstChild;

	      function rm(node) {
	        var next = node.nextSibling; // Works around a throw-scroll bug in OS X Webkit

	        if (webkit && mac && cm.display.currentWheelTarget == node) {
	          node.style.display = "none";
	        } else {
	          node.parentNode.removeChild(node);
	        }

	        return next;
	      }

	      var view = display.view,
	          lineN = display.viewFrom; // Loop over the elements in the view, syncing cur (the DOM nodes
	      // in display.lineDiv) with the view as we go.

	      for (var i = 0; i < view.length; i++) {
	        var lineView = view[i];
	        if (lineView.hidden) ;else if (!lineView.node || lineView.node.parentNode != container) {
	          // Not drawn yet
	          var node = buildLineElement(cm, lineView, lineN, dims);
	          container.insertBefore(node, cur);
	        } else {
	          // Already drawn
	          while (cur != lineView.node) {
	            cur = rm(cur);
	          }

	          var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;

	          if (lineView.changes) {
	            if (indexOf(lineView.changes, "gutter") > -1) {
	              updateNumber = false;
	            }

	            updateLineForChanges(cm, lineView, lineN, dims);
	          }

	          if (updateNumber) {
	            removeChildren(lineView.lineNumber);
	            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
	          }

	          cur = lineView.node.nextSibling;
	        }
	        lineN += lineView.size;
	      }

	      while (cur) {
	        cur = rm(cur);
	      }
	    }

	    function updateGutterSpace(display) {
	      var width = display.gutters.offsetWidth;
	      display.sizer.style.marginLeft = width + "px";
	    }

	    function setDocumentHeight(cm, measure) {
	      cm.display.sizer.style.minHeight = measure.docHeight + "px";
	      cm.display.heightForcer.style.top = measure.docHeight + "px";
	      cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
	    } // Re-align line numbers and gutter marks to compensate for
	    // horizontal scrolling.


	    function alignHorizontally(cm) {
	      var display = cm.display,
	          view = display.view;

	      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
	        return;
	      }

	      var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
	      var gutterW = display.gutters.offsetWidth,
	          left = comp + "px";

	      for (var i = 0; i < view.length; i++) {
	        if (!view[i].hidden) {
	          if (cm.options.fixedGutter) {
	            if (view[i].gutter) {
	              view[i].gutter.style.left = left;
	            }

	            if (view[i].gutterBackground) {
	              view[i].gutterBackground.style.left = left;
	            }
	          }

	          var align = view[i].alignable;

	          if (align) {
	            for (var j = 0; j < align.length; j++) {
	              align[j].style.left = left;
	            }
	          }
	        }
	      }

	      if (cm.options.fixedGutter) {
	        display.gutters.style.left = comp + gutterW + "px";
	      }
	    } // Used to ensure that the line number gutter is still the right
	    // size for the current document size. Returns true when an update
	    // is needed.


	    function maybeUpdateLineNumberWidth(cm) {
	      if (!cm.options.lineNumbers) {
	        return false;
	      }

	      var doc = cm.doc,
	          last = lineNumberFor(cm.options, doc.first + doc.size - 1),
	          display = cm.display;

	      if (last.length != display.lineNumChars) {
	        var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
	        var innerW = test.firstChild.offsetWidth,
	            padding = test.offsetWidth - innerW;
	        display.lineGutter.style.width = "";
	        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
	        display.lineNumWidth = display.lineNumInnerWidth + padding;
	        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
	        display.lineGutter.style.width = display.lineNumWidth + "px";
	        updateGutterSpace(cm.display);
	        return true;
	      }

	      return false;
	    }

	    function getGutters(gutters, lineNumbers) {
	      var result = [],
	          sawLineNumbers = false;

	      for (var i = 0; i < gutters.length; i++) {
	        var name = gutters[i],
	            style = null;

	        if (typeof name != "string") {
	          style = name.style;
	          name = name.className;
	        }

	        if (name == "CodeMirror-linenumbers") {
	          if (!lineNumbers) {
	            continue;
	          } else {
	            sawLineNumbers = true;
	          }
	        }

	        result.push({
	          className: name,
	          style: style
	        });
	      }

	      if (lineNumbers && !sawLineNumbers) {
	        result.push({
	          className: "CodeMirror-linenumbers",
	          style: null
	        });
	      }

	      return result;
	    } // Rebuild the gutter elements, ensure the margin to the left of the
	    // code matches their width.


	    function renderGutters(display) {
	      var gutters = display.gutters,
	          specs = display.gutterSpecs;
	      removeChildren(gutters);
	      display.lineGutter = null;

	      for (var i = 0; i < specs.length; ++i) {
	        var ref = specs[i];
	        var className = ref.className;
	        var style = ref.style;
	        var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));

	        if (style) {
	          gElt.style.cssText = style;
	        }

	        if (className == "CodeMirror-linenumbers") {
	          display.lineGutter = gElt;
	          gElt.style.width = (display.lineNumWidth || 1) + "px";
	        }
	      }

	      gutters.style.display = specs.length ? "" : "none";
	      updateGutterSpace(display);
	    }

	    function updateGutters(cm) {
	      renderGutters(cm.display);
	      regChange(cm);
	      alignHorizontally(cm);
	    } // The display handles the DOM integration, both for input reading
	    // and content drawing. It holds references to DOM nodes and
	    // display-related state.


	    function Display(place, doc, input, options) {
	      var d = this;
	      this.input = input; // Covers bottom-right square when both scrollbars are present.

	      d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
	      d.scrollbarFiller.setAttribute("cm-not-content", "true"); // Covers bottom of gutter when coverGutterNextToScrollbar is on
	      // and h scrollbar is present.

	      d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
	      d.gutterFiller.setAttribute("cm-not-content", "true"); // Will contain the actual code, positioned to cover the viewport.

	      d.lineDiv = eltP("div", null, "CodeMirror-code"); // Elements are added to these to represent selection and cursors.

	      d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
	      d.cursorDiv = elt("div", null, "CodeMirror-cursors"); // A visibility: hidden element used to find the size of things.

	      d.measure = elt("div", null, "CodeMirror-measure"); // When lines outside of the viewport are measured, they are drawn in this.

	      d.lineMeasure = elt("div", null, "CodeMirror-measure"); // Wraps everything that needs to exist inside the vertically-padded coordinate system

	      d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
	      var lines = eltP("div", [d.lineSpace], "CodeMirror-lines"); // Moved around its parent to cover visible view.

	      d.mover = elt("div", [lines], null, "position: relative"); // Set to the height of the document, allowing scrolling.

	      d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
	      d.sizerWidth = null; // Behavior of elts with overflow: auto and padding is
	      // inconsistent across browsers. This is used to ensure the
	      // scrollable area is big enough.

	      d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"); // Will contain the gutters, if any.

	      d.gutters = elt("div", null, "CodeMirror-gutters");
	      d.lineGutter = null; // Actual scrollable element.

	      d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
	      d.scroller.setAttribute("tabIndex", "-1"); // The element in which the editor lives.

	      d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror"); // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)

	      if (ie && ie_version < 8) {
	        d.gutters.style.zIndex = -1;
	        d.scroller.style.paddingRight = 0;
	      }

	      if (!webkit && !(gecko && mobile)) {
	        d.scroller.draggable = true;
	      }

	      if (place) {
	        if (place.appendChild) {
	          place.appendChild(d.wrapper);
	        } else {
	          place(d.wrapper);
	        }
	      } // Current rendered range (may be bigger than the view window).


	      d.viewFrom = d.viewTo = doc.first;
	      d.reportedViewFrom = d.reportedViewTo = doc.first; // Information about the rendered lines.

	      d.view = [];
	      d.renderedView = null; // Holds info about a single rendered line when it was rendered
	      // for measurement, while not in view.

	      d.externalMeasured = null; // Empty space (in pixels) above the view

	      d.viewOffset = 0;
	      d.lastWrapHeight = d.lastWrapWidth = 0;
	      d.updateLineNumbers = null;
	      d.nativeBarWidth = d.barHeight = d.barWidth = 0;
	      d.scrollbarsClipped = false; // Used to only resize the line number gutter when necessary (when
	      // the amount of lines crosses a boundary that makes its width change)

	      d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null; // Set to true when a non-horizontal-scrolling line widget is
	      // added. As an optimization, line widget aligning is skipped when
	      // this is false.

	      d.alignWidgets = false;
	      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null; // Tracks the maximum line length so that the horizontal scrollbar
	      // can be kept static when scrolling.

	      d.maxLine = null;
	      d.maxLineLength = 0;
	      d.maxLineChanged = false; // Used for measuring wheel scrolling granularity

	      d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null; // True when shift is held down.

	      d.shift = false; // Used to track whether anything happened since the context menu
	      // was opened.

	      d.selForContextMenu = null;
	      d.activeTouch = null;
	      d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
	      renderGutters(d);
	      input.init(d);
	    } // Since the delta values reported on mouse wheel events are
	    // unstandardized between browsers and even browser versions, and
	    // generally horribly unpredictable, this code starts by measuring
	    // the scroll effect that the first few mouse wheel events have,
	    // and, from that, detects the way it can convert deltas to pixel
	    // offsets afterwards.
	    //
	    // The reason we want to know the amount a wheel event will scroll
	    // is that it gives us a chance to update the display before the
	    // actual scrolling happens, reducing flickering.


	    var wheelSamples = 0,
	        wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we
	    // know one. These don't have to be accurate -- the result of them
	    // being wrong would just be a slight flicker on the first wheel
	    // scroll (if it is large enough).

	    if (ie) {
	      wheelPixelsPerUnit = -.53;
	    } else if (gecko) {
	      wheelPixelsPerUnit = 15;
	    } else if (chrome) {
	      wheelPixelsPerUnit = -.7;
	    } else if (safari) {
	      wheelPixelsPerUnit = -1 / 3;
	    }

	    function wheelEventDelta(e) {
	      var dx = e.wheelDeltaX,
	          dy = e.wheelDeltaY;

	      if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
	        dx = e.detail;
	      }

	      if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
	        dy = e.detail;
	      } else if (dy == null) {
	        dy = e.wheelDelta;
	      }

	      return {
	        x: dx,
	        y: dy
	      };
	    }

	    function wheelEventPixels(e) {
	      var delta = wheelEventDelta(e);
	      delta.x *= wheelPixelsPerUnit;
	      delta.y *= wheelPixelsPerUnit;
	      return delta;
	    }

	    function onScrollWheel(cm, e) {
	      var delta = wheelEventDelta(e),
	          dx = delta.x,
	          dy = delta.y;
	      var display = cm.display,
	          scroll = display.scroller; // Quit if there's nothing to scroll here

	      var canScrollX = scroll.scrollWidth > scroll.clientWidth;
	      var canScrollY = scroll.scrollHeight > scroll.clientHeight;

	      if (!(dx && canScrollX || dy && canScrollY)) {
	        return;
	      } // Webkit browsers on OS X abort momentum scrolls when the target
	      // of the scroll event is removed from the scrollable element.
	      // This hack (see related code in patchDisplay) makes sure the
	      // element is kept around.


	      if (dy && mac && webkit) {
	        outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	          for (var i = 0; i < view.length; i++) {
	            if (view[i].node == cur) {
	              cm.display.currentWheelTarget = cur;
	              break outer;
	            }
	          }
	        }
	      } // On some browsers, horizontal scrolling will cause redraws to
	      // happen before the gutter has been realigned, causing it to
	      // wriggle around in a most unseemly way. When we have an
	      // estimated pixels/delta value, we just handle horizontal
	      // scrolling entirely here. It'll be slightly off from native, but
	      // better than glitching out.


	      if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	        if (dy && canScrollY) {
	          updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
	        }

	        setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)); // Only prevent default scrolling if vertical scrolling is
	        // actually possible. Otherwise, it causes vertical scroll
	        // jitter on OSX trackpads when deltaX is small and deltaY
	        // is large (issue #3579)

	        if (!dy || dy && canScrollY) {
	          e_preventDefault(e);
	        }

	        display.wheelStartX = null; // Abort measurement, if in progress

	        return;
	      } // 'Project' the visible viewport to cover the area that is being
	      // scrolled into view (if we know enough to estimate it).


	      if (dy && wheelPixelsPerUnit != null) {
	        var pixels = dy * wheelPixelsPerUnit;
	        var top = cm.doc.scrollTop,
	            bot = top + display.wrapper.clientHeight;

	        if (pixels < 0) {
	          top = Math.max(0, top + pixels - 50);
	        } else {
	          bot = Math.min(cm.doc.height, bot + pixels + 50);
	        }

	        updateDisplaySimple(cm, {
	          top: top,
	          bottom: bot
	        });
	      }

	      if (wheelSamples < 20) {
	        if (display.wheelStartX == null) {
	          display.wheelStartX = scroll.scrollLeft;
	          display.wheelStartY = scroll.scrollTop;
	          display.wheelDX = dx;
	          display.wheelDY = dy;
	          setTimeout(function () {
	            if (display.wheelStartX == null) {
	              return;
	            }

	            var movedX = scroll.scrollLeft - display.wheelStartX;
	            var movedY = scroll.scrollTop - display.wheelStartY;
	            var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
	            display.wheelStartX = display.wheelStartY = null;

	            if (!sample) {
	              return;
	            }

	            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
	            ++wheelSamples;
	          }, 200);
	        } else {
	          display.wheelDX += dx;
	          display.wheelDY += dy;
	        }
	      }
	    } // Selection objects are immutable. A new one is created every time
	    // the selection changes. A selection is one or more non-overlapping
	    // (and non-touching) ranges, sorted, and an integer that indicates
	    // which one is the primary selection (the one that's scrolled into
	    // view, that getCursor returns, etc).


	    var Selection = function (ranges, primIndex) {
	      this.ranges = ranges;
	      this.primIndex = primIndex;
	    };

	    Selection.prototype.primary = function () {
	      return this.ranges[this.primIndex];
	    };

	    Selection.prototype.equals = function (other) {
	      if (other == this) {
	        return true;
	      }

	      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
	        return false;
	      }

	      for (var i = 0; i < this.ranges.length; i++) {
	        var here = this.ranges[i],
	            there = other.ranges[i];

	        if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
	          return false;
	        }
	      }

	      return true;
	    };

	    Selection.prototype.deepCopy = function () {
	      var out = [];

	      for (var i = 0; i < this.ranges.length; i++) {
	        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
	      }

	      return new Selection(out, this.primIndex);
	    };

	    Selection.prototype.somethingSelected = function () {
	      for (var i = 0; i < this.ranges.length; i++) {
	        if (!this.ranges[i].empty()) {
	          return true;
	        }
	      }

	      return false;
	    };

	    Selection.prototype.contains = function (pos, end) {
	      if (!end) {
	        end = pos;
	      }

	      for (var i = 0; i < this.ranges.length; i++) {
	        var range = this.ranges[i];

	        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
	          return i;
	        }
	      }

	      return -1;
	    };

	    var Range = function (anchor, head) {
	      this.anchor = anchor;
	      this.head = head;
	    };

	    Range.prototype.from = function () {
	      return minPos(this.anchor, this.head);
	    };

	    Range.prototype.to = function () {
	      return maxPos(this.anchor, this.head);
	    };

	    Range.prototype.empty = function () {
	      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
	    }; // Take an unsorted, potentially overlapping set of ranges, and
	    // build a selection out of it. 'Consumes' ranges array (modifying
	    // it).


	    function normalizeSelection(cm, ranges, primIndex) {
	      var mayTouch = cm && cm.options.selectionsMayTouch;
	      var prim = ranges[primIndex];
	      ranges.sort(function (a, b) {
	        return cmp(a.from(), b.from());
	      });
	      primIndex = indexOf(ranges, prim);

	      for (var i = 1; i < ranges.length; i++) {
	        var cur = ranges[i],
	            prev = ranges[i - 1];
	        var diff = cmp(prev.to(), cur.from());

	        if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
	          var from = minPos(prev.from(), cur.from()),
	              to = maxPos(prev.to(), cur.to());
	          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;

	          if (i <= primIndex) {
	            --primIndex;
	          }

	          ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
	        }
	      }

	      return new Selection(ranges, primIndex);
	    }

	    function simpleSelection(anchor, head) {
	      return new Selection([new Range(anchor, head || anchor)], 0);
	    } // Compute the position of the end of a change (its 'to' property
	    // refers to the pre-change end).


	    function changeEnd(change) {
	      if (!change.text) {
	        return change.to;
	      }

	      return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
	    } // Adjust a position to refer to the post-change position of the
	    // same text, or the end of the change if the change covers it.


	    function adjustForChange(pos, change) {
	      if (cmp(pos, change.from) < 0) {
	        return pos;
	      }

	      if (cmp(pos, change.to) <= 0) {
	        return changeEnd(change);
	      }

	      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
	          ch = pos.ch;

	      if (pos.line == change.to.line) {
	        ch += changeEnd(change).ch - change.to.ch;
	      }

	      return Pos(line, ch);
	    }

	    function computeSelAfterChange(doc, change) {
	      var out = [];

	      for (var i = 0; i < doc.sel.ranges.length; i++) {
	        var range = doc.sel.ranges[i];
	        out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
	      }

	      return normalizeSelection(doc.cm, out, doc.sel.primIndex);
	    }

	    function offsetPos(pos, old, nw) {
	      if (pos.line == old.line) {
	        return Pos(nw.line, pos.ch - old.ch + nw.ch);
	      } else {
	        return Pos(nw.line + (pos.line - old.line), pos.ch);
	      }
	    } // Used by replaceSelections to allow moving the selection to the
	    // start or around the replaced test. Hint may be "start" or "around".


	    function computeReplacedSel(doc, changes, hint) {
	      var out = [];
	      var oldPrev = Pos(doc.first, 0),
	          newPrev = oldPrev;

	      for (var i = 0; i < changes.length; i++) {
	        var change = changes[i];
	        var from = offsetPos(change.from, oldPrev, newPrev);
	        var to = offsetPos(changeEnd(change), oldPrev, newPrev);
	        oldPrev = change.to;
	        newPrev = to;

	        if (hint == "around") {
	          var range = doc.sel.ranges[i],
	              inv = cmp(range.head, range.anchor) < 0;
	          out[i] = new Range(inv ? to : from, inv ? from : to);
	        } else {
	          out[i] = new Range(from, from);
	        }
	      }

	      return new Selection(out, doc.sel.primIndex);
	    } // Used to get the editor into a consistent state again when options change.


	    function loadMode(cm) {
	      cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
	      resetModeState(cm);
	    }

	    function resetModeState(cm) {
	      cm.doc.iter(function (line) {
	        if (line.stateAfter) {
	          line.stateAfter = null;
	        }

	        if (line.styles) {
	          line.styles = null;
	        }
	      });
	      cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
	      startWorker(cm, 100);
	      cm.state.modeGen++;

	      if (cm.curOp) {
	        regChange(cm);
	      }
	    } // DOCUMENT DATA STRUCTURE
	    // By default, updates that start and end at the beginning of a line
	    // are treated specially, in order to make the association of line
	    // widgets and marker elements with the text behave more intuitive.


	    function isWholeLineUpdate(doc, change) {
	      return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
	    } // Perform a change on the document data structure.


	    function updateDoc(doc, change, markedSpans, estimateHeight) {
	      function spansFor(n) {
	        return markedSpans ? markedSpans[n] : null;
	      }

	      function update(line, text, spans) {
	        updateLine(line, text, spans, estimateHeight);
	        signalLater(line, "change", line, change);
	      }

	      function linesFor(start, end) {
	        var result = [];

	        for (var i = start; i < end; ++i) {
	          result.push(new Line(text[i], spansFor(i), estimateHeight));
	        }

	        return result;
	      }

	      var from = change.from,
	          to = change.to,
	          text = change.text;
	      var firstLine = getLine(doc, from.line),
	          lastLine = getLine(doc, to.line);
	      var lastText = lst(text),
	          lastSpans = spansFor(text.length - 1),
	          nlines = to.line - from.line; // Adjust the line structure

	      if (change.full) {
	        doc.insert(0, linesFor(0, text.length));
	        doc.remove(text.length, doc.size - text.length);
	      } else if (isWholeLineUpdate(doc, change)) {
	        // This is a whole-line replace. Treated specially to make
	        // sure line objects move the way they are supposed to.
	        var added = linesFor(0, text.length - 1);
	        update(lastLine, lastLine.text, lastSpans);

	        if (nlines) {
	          doc.remove(from.line, nlines);
	        }

	        if (added.length) {
	          doc.insert(from.line, added);
	        }
	      } else if (firstLine == lastLine) {
	        if (text.length == 1) {
	          update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
	        } else {
	          var added$1 = linesFor(1, text.length - 1);
	          added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
	          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	          doc.insert(from.line + 1, added$1);
	        }
	      } else if (text.length == 1) {
	        update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
	        doc.remove(from.line + 1, nlines);
	      } else {
	        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
	        var added$2 = linesFor(1, text.length - 1);

	        if (nlines > 1) {
	          doc.remove(from.line + 1, nlines - 1);
	        }

	        doc.insert(from.line + 1, added$2);
	      }

	      signalLater(doc, "change", doc, change);
	    } // Call f for all linked documents.


	    function linkedDocs(doc, f, sharedHistOnly) {
	      function propagate(doc, skip, sharedHist) {
	        if (doc.linked) {
	          for (var i = 0; i < doc.linked.length; ++i) {
	            var rel = doc.linked[i];

	            if (rel.doc == skip) {
	              continue;
	            }

	            var shared = sharedHist && rel.sharedHist;

	            if (sharedHistOnly && !shared) {
	              continue;
	            }

	            f(rel.doc, shared);
	            propagate(rel.doc, doc, shared);
	          }
	        }
	      }

	      propagate(doc, null, true);
	    } // Attach a document to an editor.


	    function attachDoc(cm, doc) {
	      if (doc.cm) {
	        throw new Error("This document is already in use.");
	      }

	      cm.doc = doc;
	      doc.cm = cm;
	      estimateLineHeights(cm);
	      loadMode(cm);
	      setDirectionClass(cm);

	      if (!cm.options.lineWrapping) {
	        findMaxLine(cm);
	      }

	      cm.options.mode = doc.modeOption;
	      regChange(cm);
	    }

	    function setDirectionClass(cm) {
	      (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
	    }

	    function directionChanged(cm) {
	      runInOp(cm, function () {
	        setDirectionClass(cm);
	        regChange(cm);
	      });
	    }

	    function History(startGen) {
	      // Arrays of change events and selections. Doing something adds an
	      // event to done and clears undo. Undoing moves events from done
	      // to undone, redoing moves them in the other direction.
	      this.done = [];
	      this.undone = [];
	      this.undoDepth = Infinity; // Used to track when changes can be merged into a single undo
	      // event

	      this.lastModTime = this.lastSelTime = 0;
	      this.lastOp = this.lastSelOp = null;
	      this.lastOrigin = this.lastSelOrigin = null; // Used by the isClean() method

	      this.generation = this.maxGeneration = startGen || 1;
	    } // Create a history change event from an updateDoc-style change
	    // object.


	    function historyChangeFromChange(doc, change) {
	      var histChange = {
	        from: copyPos(change.from),
	        to: changeEnd(change),
	        text: getBetween(doc, change.from, change.to)
	      };
	      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	      linkedDocs(doc, function (doc) {
	        return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	      }, true);
	      return histChange;
	    } // Pop all selection events off the end of a history array. Stop at
	    // a change event.


	    function clearSelectionEvents(array) {
	      while (array.length) {
	        var last = lst(array);

	        if (last.ranges) {
	          array.pop();
	        } else {
	          break;
	        }
	      }
	    } // Find the top change event in the history. Pop off selection
	    // events that are in the way.


	    function lastChangeEvent(hist, force) {
	      if (force) {
	        clearSelectionEvents(hist.done);
	        return lst(hist.done);
	      } else if (hist.done.length && !lst(hist.done).ranges) {
	        return lst(hist.done);
	      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	        hist.done.pop();
	        return lst(hist.done);
	      }
	    } // Register a change in the history. Merges changes that are within
	    // a single operation, or are close together with an origin that
	    // allows merging (starting with "+") into a single event.


	    function addChangeToHistory(doc, change, selAfter, opId) {
	      var hist = doc.history;
	      hist.undone.length = 0;
	      var time = +new Date(),
	          cur;
	      var last;

	      if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	        // Merge this change into the last event
	        last = lst(cur.changes);

	        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	          // Optimized case for simple insertion -- don't want to add
	          // new changesets for every character typed
	          last.to = changeEnd(change);
	        } else {
	          // Add new sub-event
	          cur.changes.push(historyChangeFromChange(doc, change));
	        }
	      } else {
	        // Can not be merged, start a new event.
	        var before = lst(hist.done);

	        if (!before || !before.ranges) {
	          pushSelectionToHistory(doc.sel, hist.done);
	        }

	        cur = {
	          changes: [historyChangeFromChange(doc, change)],
	          generation: hist.generation
	        };
	        hist.done.push(cur);

	        while (hist.done.length > hist.undoDepth) {
	          hist.done.shift();

	          if (!hist.done[0].ranges) {
	            hist.done.shift();
	          }
	        }
	      }

	      hist.done.push(selAfter);
	      hist.generation = ++hist.maxGeneration;
	      hist.lastModTime = hist.lastSelTime = time;
	      hist.lastOp = hist.lastSelOp = opId;
	      hist.lastOrigin = hist.lastSelOrigin = change.origin;

	      if (!last) {
	        signal(doc, "historyAdded");
	      }
	    }

	    function selectionEventCanBeMerged(doc, origin, prev, sel) {
	      var ch = origin.charAt(0);
	      return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
	    } // Called whenever the selection changes, sets the new selection as
	    // the pending selection in the history, and pushes the old pending
	    // selection into the 'done' array when it was significantly
	    // different (in number of selected ranges, emptiness, or time).


	    function addSelectionToHistory(doc, sel, opId, options) {
	      var hist = doc.history,
	          origin = options && options.origin; // A new event is started when the previous origin does not match
	      // the current, or the origins don't allow matching. Origins
	      // starting with * are always merged, those starting with + are
	      // merged when similar and close together in time.

	      if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
	        hist.done[hist.done.length - 1] = sel;
	      } else {
	        pushSelectionToHistory(sel, hist.done);
	      }

	      hist.lastSelTime = +new Date();
	      hist.lastSelOrigin = origin;
	      hist.lastSelOp = opId;

	      if (options && options.clearRedo !== false) {
	        clearSelectionEvents(hist.undone);
	      }
	    }

	    function pushSelectionToHistory(sel, dest) {
	      var top = lst(dest);

	      if (!(top && top.ranges && top.equals(sel))) {
	        dest.push(sel);
	      }
	    } // Used to store marked span information in the history.


	    function attachLocalSpans(doc, change, from, to) {
	      var existing = change["spans_" + doc.id],
	          n = 0;
	      doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
	        if (line.markedSpans) {
	          (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
	        }

	        ++n;
	      });
	    } // When un/re-doing restores text containing marked spans, those
	    // that have been explicitly cleared should not be restored.


	    function removeClearedSpans(spans) {
	      if (!spans) {
	        return null;
	      }

	      var out;

	      for (var i = 0; i < spans.length; ++i) {
	        if (spans[i].marker.explicitlyCleared) {
	          if (!out) {
	            out = spans.slice(0, i);
	          }
	        } else if (out) {
	          out.push(spans[i]);
	        }
	      }

	      return !out ? spans : out.length ? out : null;
	    } // Retrieve and filter the old marked spans stored in a change event.


	    function getOldSpans(doc, change) {
	      var found = change["spans_" + doc.id];

	      if (!found) {
	        return null;
	      }

	      var nw = [];

	      for (var i = 0; i < change.text.length; ++i) {
	        nw.push(removeClearedSpans(found[i]));
	      }

	      return nw;
	    } // Used for un/re-doing changes from the history. Combines the
	    // result of computing the existing spans with the set of spans that
	    // existed in the history (so that deleting around a span and then
	    // undoing brings back the span).


	    function mergeOldSpans(doc, change) {
	      var old = getOldSpans(doc, change);
	      var stretched = stretchSpansOverChange(doc, change);

	      if (!old) {
	        return stretched;
	      }

	      if (!stretched) {
	        return old;
	      }

	      for (var i = 0; i < old.length; ++i) {
	        var oldCur = old[i],
	            stretchCur = stretched[i];

	        if (oldCur && stretchCur) {
	          spans: for (var j = 0; j < stretchCur.length; ++j) {
	            var span = stretchCur[j];

	            for (var k = 0; k < oldCur.length; ++k) {
	              if (oldCur[k].marker == span.marker) {
	                continue spans;
	              }
	            }

	            oldCur.push(span);
	          }
	        } else if (stretchCur) {
	          old[i] = stretchCur;
	        }
	      }

	      return old;
	    } // Used both to provide a JSON-safe object in .getHistory, and, when
	    // detaching a document, to split the history in two


	    function copyHistoryArray(events, newGroup, instantiateSel) {
	      var copy = [];

	      for (var i = 0; i < events.length; ++i) {
	        var event = events[i];

	        if (event.ranges) {
	          copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
	          continue;
	        }

	        var changes = event.changes,
	            newChanges = [];
	        copy.push({
	          changes: newChanges
	        });

	        for (var j = 0; j < changes.length; ++j) {
	          var change = changes[j],
	              m = void 0;
	          newChanges.push({
	            from: change.from,
	            to: change.to,
	            text: change.text
	          });

	          if (newGroup) {
	            for (var prop in change) {
	              if (m = prop.match(/^spans_(\d+)$/)) {
	                if (indexOf(newGroup, Number(m[1])) > -1) {
	                  lst(newChanges)[prop] = change[prop];
	                  delete change[prop];
	                }
	              }
	            }
	          }
	        }
	      }

	      return copy;
	    } // The 'scroll' parameter given to many of these indicated whether
	    // the new cursor position should be scrolled into view after
	    // modifying the selection.
	    // If shift is held or the extend flag is set, extends a range to
	    // include a given position (and optionally a second position).
	    // Otherwise, simply returns the range between the given positions.
	    // Used for cursor motion and such.


	    function extendRange(range, head, other, extend) {
	      if (extend) {
	        var anchor = range.anchor;

	        if (other) {
	          var posBefore = cmp(head, anchor) < 0;

	          if (posBefore != cmp(other, anchor) < 0) {
	            anchor = head;
	            head = other;
	          } else if (posBefore != cmp(head, other) < 0) {
	            head = other;
	          }
	        }

	        return new Range(anchor, head);
	      } else {
	        return new Range(other || head, head);
	      }
	    } // Extend the primary selection range, discard the rest.


	    function extendSelection(doc, head, other, options, extend) {
	      if (extend == null) {
	        extend = doc.cm && (doc.cm.display.shift || doc.extend);
	      }

	      setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
	    } // Extend all selections (pos is an array of selections with length
	    // equal the number of selections)


	    function extendSelections(doc, heads, options) {
	      var out = [];
	      var extend = doc.cm && (doc.cm.display.shift || doc.extend);

	      for (var i = 0; i < doc.sel.ranges.length; i++) {
	        out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
	      }

	      var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
	      setSelection(doc, newSel, options);
	    } // Updates a single range in the selection.


	    function replaceOneSelection(doc, i, range, options) {
	      var ranges = doc.sel.ranges.slice(0);
	      ranges[i] = range;
	      setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
	    } // Reset the selection to a single range.


	    function setSimpleSelection(doc, anchor, head, options) {
	      setSelection(doc, simpleSelection(anchor, head), options);
	    } // Give beforeSelectionChange handlers a change to influence a
	    // selection update.


	    function filterSelectionChange(doc, sel, options) {
	      var obj = {
	        ranges: sel.ranges,
	        update: function (ranges) {
	          this.ranges = [];

	          for (var i = 0; i < ranges.length; i++) {
	            this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
	          }
	        },
	        origin: options && options.origin
	      };
	      signal(doc, "beforeSelectionChange", doc, obj);

	      if (doc.cm) {
	        signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
	      }

	      if (obj.ranges != sel.ranges) {
	        return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
	      } else {
	        return sel;
	      }
	    }

	    function setSelectionReplaceHistory(doc, sel, options) {
	      var done = doc.history.done,
	          last = lst(done);

	      if (last && last.ranges) {
	        done[done.length - 1] = sel;
	        setSelectionNoUndo(doc, sel, options);
	      } else {
	        setSelection(doc, sel, options);
	      }
	    } // Set a new selection.


	    function setSelection(doc, sel, options) {
	      setSelectionNoUndo(doc, sel, options);
	      addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
	    }

	    function setSelectionNoUndo(doc, sel, options) {
	      if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
	        sel = filterSelectionChange(doc, sel, options);
	      }

	      var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
	      setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

	      if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {
	        ensureCursorVisible(doc.cm);
	      }
	    }

	    function setSelectionInner(doc, sel) {
	      if (sel.equals(doc.sel)) {
	        return;
	      }

	      doc.sel = sel;

	      if (doc.cm) {
	        doc.cm.curOp.updateInput = 1;
	        doc.cm.curOp.selectionChanged = true;
	        signalCursorActivity(doc.cm);
	      }

	      signalLater(doc, "cursorActivity", doc);
	    } // Verify that the selection does not partially select any atomic
	    // marked ranges.


	    function reCheckSelection(doc) {
	      setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
	    } // Return a selection that does not partially select any atomic
	    // ranges.


	    function skipAtomicInSelection(doc, sel, bias, mayClear) {
	      var out;

	      for (var i = 0; i < sel.ranges.length; i++) {
	        var range = sel.ranges[i];
	        var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
	        var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
	        var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);

	        if (out || newAnchor != range.anchor || newHead != range.head) {
	          if (!out) {
	            out = sel.ranges.slice(0, i);
	          }

	          out[i] = new Range(newAnchor, newHead);
	        }
	      }

	      return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
	    }

	    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
	      var line = getLine(doc, pos.line);

	      if (line.markedSpans) {
	        for (var i = 0; i < line.markedSpans.length; ++i) {
	          var sp = line.markedSpans[i],
	              m = sp.marker; // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
	          // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
	          // is with selectLeft/Right

	          var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
	          var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;

	          if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
	            if (mayClear) {
	              signal(m, "beforeCursorEnter");

	              if (m.explicitlyCleared) {
	                if (!line.markedSpans) {
	                  break;
	                } else {
	                  --i;
	                  continue;
	                }
	              }
	            }

	            if (!m.atomic) {
	              continue;
	            }

	            if (oldPos) {
	              var near = m.find(dir < 0 ? 1 : -1),
	                  diff = void 0;

	              if (dir < 0 ? preventCursorRight : preventCursorLeft) {
	                near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
	              }

	              if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
	                return skipAtomicInner(doc, near, pos, dir, mayClear);
	              }
	            }

	            var far = m.find(dir < 0 ? -1 : 1);

	            if (dir < 0 ? preventCursorLeft : preventCursorRight) {
	              far = movePos(doc, far, dir, far.line == pos.line ? line : null);
	            }

	            return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
	          }
	        }
	      }

	      return pos;
	    } // Ensure a given position is not inside an atomic range.


	    function skipAtomic(doc, pos, oldPos, bias, mayClear) {
	      var dir = bias || 1;
	      var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);

	      if (!found) {
	        doc.cantEdit = true;
	        return Pos(doc.first, 0);
	      }

	      return found;
	    }

	    function movePos(doc, pos, dir, line) {
	      if (dir < 0 && pos.ch == 0) {
	        if (pos.line > doc.first) {
	          return clipPos(doc, Pos(pos.line - 1));
	        } else {
	          return null;
	        }
	      } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
	        if (pos.line < doc.first + doc.size - 1) {
	          return Pos(pos.line + 1, 0);
	        } else {
	          return null;
	        }
	      } else {
	        return new Pos(pos.line, pos.ch + dir);
	      }
	    }

	    function selectAll(cm) {
	      cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
	    } // UPDATING
	    // Allow "beforeChange" event handlers to influence a change


	    function filterChange(doc, change, update) {
	      var obj = {
	        canceled: false,
	        from: change.from,
	        to: change.to,
	        text: change.text,
	        origin: change.origin,
	        cancel: function () {
	          return obj.canceled = true;
	        }
	      };

	      if (update) {
	        obj.update = function (from, to, text, origin) {
	          if (from) {
	            obj.from = clipPos(doc, from);
	          }

	          if (to) {
	            obj.to = clipPos(doc, to);
	          }

	          if (text) {
	            obj.text = text;
	          }

	          if (origin !== undefined) {
	            obj.origin = origin;
	          }
	        };
	      }

	      signal(doc, "beforeChange", doc, obj);

	      if (doc.cm) {
	        signal(doc.cm, "beforeChange", doc.cm, obj);
	      }

	      if (obj.canceled) {
	        if (doc.cm) {
	          doc.cm.curOp.updateInput = 2;
	        }

	        return null;
	      }

	      return {
	        from: obj.from,
	        to: obj.to,
	        text: obj.text,
	        origin: obj.origin
	      };
	    } // Apply a change to a document, and add it to the document's
	    // history, and propagating it to all linked documents.


	    function makeChange(doc, change, ignoreReadOnly) {
	      if (doc.cm) {
	        if (!doc.cm.curOp) {
	          return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
	        }

	        if (doc.cm.state.suppressEdits) {
	          return;
	        }
	      }

	      if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	        change = filterChange(doc, change, true);

	        if (!change) {
	          return;
	        }
	      } // Possibly split or suppress the update based on the presence
	      // of read-only spans in its range.


	      var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);

	      if (split) {
	        for (var i = split.length - 1; i >= 0; --i) {
	          makeChangeInner(doc, {
	            from: split[i].from,
	            to: split[i].to,
	            text: i ? [""] : change.text,
	            origin: change.origin
	          });
	        }
	      } else {
	        makeChangeInner(doc, change);
	      }
	    }

	    function makeChangeInner(doc, change) {
	      if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
	        return;
	      }

	      var selAfter = computeSelAfterChange(doc, change);
	      addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
	      makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
	      var rebased = [];
	      linkedDocs(doc, function (doc, sharedHist) {
	        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	          rebaseHist(doc.history, change);
	          rebased.push(doc.history);
	        }

	        makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
	      });
	    } // Revert a change stored in a document's history.


	    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	      var suppress = doc.cm && doc.cm.state.suppressEdits;

	      if (suppress && !allowSelectionOnly) {
	        return;
	      }

	      var hist = doc.history,
	          event,
	          selAfter = doc.sel;
	      var source = type == "undo" ? hist.done : hist.undone,
	          dest = type == "undo" ? hist.undone : hist.done; // Verify that there is a useable event (so that ctrl-z won't
	      // needlessly clear selection events)

	      var i = 0;

	      for (; i < source.length; i++) {
	        event = source[i];

	        if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
	          break;
	        }
	      }

	      if (i == source.length) {
	        return;
	      }

	      hist.lastOrigin = hist.lastSelOrigin = null;

	      for (;;) {
	        event = source.pop();

	        if (event.ranges) {
	          pushSelectionToHistory(event, dest);

	          if (allowSelectionOnly && !event.equals(doc.sel)) {
	            setSelection(doc, event, {
	              clearRedo: false
	            });
	            return;
	          }

	          selAfter = event;
	        } else if (suppress) {
	          source.push(event);
	          return;
	        } else {
	          break;
	        }
	      } // Build up a reverse change object to add to the opposite history
	      // stack (redo when undoing, and vice versa).


	      var antiChanges = [];
	      pushSelectionToHistory(selAfter, dest);
	      dest.push({
	        changes: antiChanges,
	        generation: hist.generation
	      });
	      hist.generation = event.generation || ++hist.maxGeneration;
	      var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

	      var loop = function (i) {
	        var change = event.changes[i];
	        change.origin = type;

	        if (filter && !filterChange(doc, change, false)) {
	          source.length = 0;
	          return {};
	        }

	        antiChanges.push(historyChangeFromChange(doc, change));
	        var after = i ? computeSelAfterChange(doc, change) : lst(source);
	        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));

	        if (!i && doc.cm) {
	          doc.cm.scrollIntoView({
	            from: change.from,
	            to: changeEnd(change)
	          });
	        }

	        var rebased = []; // Propagate to the linked documents

	        linkedDocs(doc, function (doc, sharedHist) {
	          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	            rebaseHist(doc.history, change);
	            rebased.push(doc.history);
	          }

	          makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
	        });
	      };

	      for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
	        var returned = loop(i$1);
	        if (returned) return returned.v;
	      }
	    } // Sub-views need their line numbers shifted when text is added
	    // above or below them in the parent document.


	    function shiftDoc(doc, distance) {
	      if (distance == 0) {
	        return;
	      }

	      doc.first += distance;
	      doc.sel = new Selection(map(doc.sel.ranges, function (range) {
	        return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
	      }), doc.sel.primIndex);

	      if (doc.cm) {
	        regChange(doc.cm, doc.first, doc.first - distance, distance);

	        for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
	          regLineChange(doc.cm, l, "gutter");
	        }
	      }
	    } // More lower-level change function, handling only a single document
	    // (not linked ones).


	    function makeChangeSingleDoc(doc, change, selAfter, spans) {
	      if (doc.cm && !doc.cm.curOp) {
	        return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
	      }

	      if (change.to.line < doc.first) {
	        shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
	        return;
	      }

	      if (change.from.line > doc.lastLine()) {
	        return;
	      } // Clip the change to the size of this doc


	      if (change.from.line < doc.first) {
	        var shift = change.text.length - 1 - (doc.first - change.from.line);
	        shiftDoc(doc, shift);
	        change = {
	          from: Pos(doc.first, 0),
	          to: Pos(change.to.line + shift, change.to.ch),
	          text: [lst(change.text)],
	          origin: change.origin
	        };
	      }

	      var last = doc.lastLine();

	      if (change.to.line > last) {
	        change = {
	          from: change.from,
	          to: Pos(last, getLine(doc, last).text.length),
	          text: [change.text[0]],
	          origin: change.origin
	        };
	      }

	      change.removed = getBetween(doc, change.from, change.to);

	      if (!selAfter) {
	        selAfter = computeSelAfterChange(doc, change);
	      }

	      if (doc.cm) {
	        makeChangeSingleDocInEditor(doc.cm, change, spans);
	      } else {
	        updateDoc(doc, change, spans);
	      }

	      setSelectionNoUndo(doc, selAfter, sel_dontScroll);

	      if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
	        doc.cantEdit = false;
	      }
	    } // Handle the interaction of a change to a document with the editor
	    // that this document is part of.


	    function makeChangeSingleDocInEditor(cm, change, spans) {
	      var doc = cm.doc,
	          display = cm.display,
	          from = change.from,
	          to = change.to;
	      var recomputeMaxLength = false,
	          checkWidthStart = from.line;

	      if (!cm.options.lineWrapping) {
	        checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
	        doc.iter(checkWidthStart, to.line + 1, function (line) {
	          if (line == display.maxLine) {
	            recomputeMaxLength = true;
	            return true;
	          }
	        });
	      }

	      if (doc.sel.contains(change.from, change.to) > -1) {
	        signalCursorActivity(cm);
	      }

	      updateDoc(doc, change, spans, estimateHeight(cm));

	      if (!cm.options.lineWrapping) {
	        doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
	          var len = lineLength(line);

	          if (len > display.maxLineLength) {
	            display.maxLine = line;
	            display.maxLineLength = len;
	            display.maxLineChanged = true;
	            recomputeMaxLength = false;
	          }
	        });

	        if (recomputeMaxLength) {
	          cm.curOp.updateMaxLine = true;
	        }
	      }

	      retreatFrontier(doc, from.line);
	      startWorker(cm, 400);
	      var lendiff = change.text.length - (to.line - from.line) - 1; // Remember that these lines changed, for updating the display

	      if (change.full) {
	        regChange(cm);
	      } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
	        regLineChange(cm, from.line, "text");
	      } else {
	        regChange(cm, from.line, to.line + 1, lendiff);
	      }

	      var changesHandler = hasHandler(cm, "changes"),
	          changeHandler = hasHandler(cm, "change");

	      if (changeHandler || changesHandler) {
	        var obj = {
	          from: from,
	          to: to,
	          text: change.text,
	          removed: change.removed,
	          origin: change.origin
	        };

	        if (changeHandler) {
	          signalLater(cm, "change", cm, obj);
	        }

	        if (changesHandler) {
	          (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
	        }
	      }

	      cm.display.selForContextMenu = null;
	    }

	    function replaceRange(doc, code, from, to, origin) {
	      var assign;

	      if (!to) {
	        to = from;
	      }

	      if (cmp(to, from) < 0) {
	        assign = [to, from], from = assign[0], to = assign[1];
	      }

	      if (typeof code == "string") {
	        code = doc.splitLines(code);
	      }

	      makeChange(doc, {
	        from: from,
	        to: to,
	        text: code,
	        origin: origin
	      });
	    } // Rebasing/resetting history to deal with externally-sourced changes


	    function rebaseHistSelSingle(pos, from, to, diff) {
	      if (to < pos.line) {
	        pos.line += diff;
	      } else if (from < pos.line) {
	        pos.line = from;
	        pos.ch = 0;
	      }
	    } // Tries to rebase an array of history events given a change in the
	    // document. If the change touches the same lines as the event, the
	    // event, and everything 'behind' it, is discarded. If the change is
	    // before the event, the event's positions are updated. Uses a
	    // copy-on-write scheme for the positions, to avoid having to
	    // reallocate them all on every rebase, but also avoid problems with
	    // shared position objects being unsafely updated.


	    function rebaseHistArray(array, from, to, diff) {
	      for (var i = 0; i < array.length; ++i) {
	        var sub = array[i],
	            ok = true;

	        if (sub.ranges) {
	          if (!sub.copied) {
	            sub = array[i] = sub.deepCopy();
	            sub.copied = true;
	          }

	          for (var j = 0; j < sub.ranges.length; j++) {
	            rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
	            rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
	          }

	          continue;
	        }

	        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
	          var cur = sub.changes[j$1];

	          if (to < cur.from.line) {
	            cur.from = Pos(cur.from.line + diff, cur.from.ch);
	            cur.to = Pos(cur.to.line + diff, cur.to.ch);
	          } else if (from <= cur.to.line) {
	            ok = false;
	            break;
	          }
	        }

	        if (!ok) {
	          array.splice(0, i + 1);
	          i = 0;
	        }
	      }
	    }

	    function rebaseHist(hist, change) {
	      var from = change.from.line,
	          to = change.to.line,
	          diff = change.text.length - (to - from) - 1;
	      rebaseHistArray(hist.done, from, to, diff);
	      rebaseHistArray(hist.undone, from, to, diff);
	    } // Utility for applying a change to a line by handle or number,
	    // returning the number and optionally registering the line as
	    // changed.


	    function changeLine(doc, handle, changeType, op) {
	      var no = handle,
	          line = handle;

	      if (typeof handle == "number") {
	        line = getLine(doc, clipLine(doc, handle));
	      } else {
	        no = lineNo(handle);
	      }

	      if (no == null) {
	        return null;
	      }

	      if (op(line, no) && doc.cm) {
	        regLineChange(doc.cm, no, changeType);
	      }

	      return line;
	    } // The document is represented as a BTree consisting of leaves, with
	    // chunk of lines in them, and branches, with up to ten leaves or
	    // other branch nodes below them. The top node is always a branch
	    // node, and is the document object itself (meaning it has
	    // additional methods and properties).
	    //
	    // All nodes have parent links. The tree is used both to go from
	    // line numbers to line objects, and to go from objects to numbers.
	    // It also indexes by height, and is used to convert between height
	    // and line object, and to find the total height of the document.
	    //
	    // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html


	    function LeafChunk(lines) {
	      this.lines = lines;
	      this.parent = null;
	      var height = 0;

	      for (var i = 0; i < lines.length; ++i) {
	        lines[i].parent = this;
	        height += lines[i].height;
	      }

	      this.height = height;
	    }

	    LeafChunk.prototype = {
	      chunkSize: function () {
	        return this.lines.length;
	      },
	      // Remove the n lines at offset 'at'.
	      removeInner: function (at, n) {
	        for (var i = at, e = at + n; i < e; ++i) {
	          var line = this.lines[i];
	          this.height -= line.height;
	          cleanUpLine(line);
	          signalLater(line, "delete");
	        }

	        this.lines.splice(at, n);
	      },
	      // Helper used to collapse a small branch into a single leaf.
	      collapse: function (lines) {
	        lines.push.apply(lines, this.lines);
	      },
	      // Insert the given array of lines at offset 'at', count them as
	      // having the given height.
	      insertInner: function (at, lines, height) {
	        this.height += height;
	        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));

	        for (var i = 0; i < lines.length; ++i) {
	          lines[i].parent = this;
	        }
	      },
	      // Used to iterate over a part of the tree.
	      iterN: function (at, n, op) {
	        for (var e = at + n; at < e; ++at) {
	          if (op(this.lines[at])) {
	            return true;
	          }
	        }
	      }
	    };

	    function BranchChunk(children) {
	      this.children = children;
	      var size = 0,
	          height = 0;

	      for (var i = 0; i < children.length; ++i) {
	        var ch = children[i];
	        size += ch.chunkSize();
	        height += ch.height;
	        ch.parent = this;
	      }

	      this.size = size;
	      this.height = height;
	      this.parent = null;
	    }

	    BranchChunk.prototype = {
	      chunkSize: function () {
	        return this.size;
	      },
	      removeInner: function (at, n) {
	        this.size -= n;

	        for (var i = 0; i < this.children.length; ++i) {
	          var child = this.children[i],
	              sz = child.chunkSize();

	          if (at < sz) {
	            var rm = Math.min(n, sz - at),
	                oldHeight = child.height;
	            child.removeInner(at, rm);
	            this.height -= oldHeight - child.height;

	            if (sz == rm) {
	              this.children.splice(i--, 1);
	              child.parent = null;
	            }

	            if ((n -= rm) == 0) {
	              break;
	            }

	            at = 0;
	          } else {
	            at -= sz;
	          }
	        } // If the result is smaller than 25 lines, ensure that it is a
	        // single leaf node.


	        if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	          var lines = [];
	          this.collapse(lines);
	          this.children = [new LeafChunk(lines)];
	          this.children[0].parent = this;
	        }
	      },
	      collapse: function (lines) {
	        for (var i = 0; i < this.children.length; ++i) {
	          this.children[i].collapse(lines);
	        }
	      },
	      insertInner: function (at, lines, height) {
	        this.size += lines.length;
	        this.height += height;

	        for (var i = 0; i < this.children.length; ++i) {
	          var child = this.children[i],
	              sz = child.chunkSize();

	          if (at <= sz) {
	            child.insertInner(at, lines, height);

	            if (child.lines && child.lines.length > 50) {
	              // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
	              // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
	              var remaining = child.lines.length % 25 + 25;

	              for (var pos = remaining; pos < child.lines.length;) {
	                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
	                child.height -= leaf.height;
	                this.children.splice(++i, 0, leaf);
	                leaf.parent = this;
	              }

	              child.lines = child.lines.slice(0, remaining);
	              this.maybeSpill();
	            }

	            break;
	          }

	          at -= sz;
	        }
	      },
	      // When a node has grown, check whether it should be split.
	      maybeSpill: function () {
	        if (this.children.length <= 10) {
	          return;
	        }

	        var me = this;

	        do {
	          var spilled = me.children.splice(me.children.length - 5, 5);
	          var sibling = new BranchChunk(spilled);

	          if (!me.parent) {
	            // Become the parent node
	            var copy = new BranchChunk(me.children);
	            copy.parent = me;
	            me.children = [copy, sibling];
	            me = copy;
	          } else {
	            me.size -= sibling.size;
	            me.height -= sibling.height;
	            var myIndex = indexOf(me.parent.children, me);
	            me.parent.children.splice(myIndex + 1, 0, sibling);
	          }

	          sibling.parent = me.parent;
	        } while (me.children.length > 10);

	        me.parent.maybeSpill();
	      },
	      iterN: function (at, n, op) {
	        for (var i = 0; i < this.children.length; ++i) {
	          var child = this.children[i],
	              sz = child.chunkSize();

	          if (at < sz) {
	            var used = Math.min(n, sz - at);

	            if (child.iterN(at, used, op)) {
	              return true;
	            }

	            if ((n -= used) == 0) {
	              break;
	            }

	            at = 0;
	          } else {
	            at -= sz;
	          }
	        }
	      }
	    }; // Line widgets are block elements displayed above or below a line.

	    var LineWidget = function (doc, node, options) {
	      if (options) {
	        for (var opt in options) {
	          if (options.hasOwnProperty(opt)) {
	            this[opt] = options[opt];
	          }
	        }
	      }

	      this.doc = doc;
	      this.node = node;
	    };

	    LineWidget.prototype.clear = function () {
	      var cm = this.doc.cm,
	          ws = this.line.widgets,
	          line = this.line,
	          no = lineNo(line);

	      if (no == null || !ws) {
	        return;
	      }

	      for (var i = 0; i < ws.length; ++i) {
	        if (ws[i] == this) {
	          ws.splice(i--, 1);
	        }
	      }

	      if (!ws.length) {
	        line.widgets = null;
	      }

	      var height = widgetHeight(this);
	      updateLineHeight(line, Math.max(0, line.height - height));

	      if (cm) {
	        runInOp(cm, function () {
	          adjustScrollWhenAboveVisible(cm, line, -height);
	          regLineChange(cm, no, "widget");
	        });
	        signalLater(cm, "lineWidgetCleared", cm, this, no);
	      }
	    };

	    LineWidget.prototype.changed = function () {
	      var this$1 = this;
	      var oldH = this.height,
	          cm = this.doc.cm,
	          line = this.line;
	      this.height = null;
	      var diff = widgetHeight(this) - oldH;

	      if (!diff) {
	        return;
	      }

	      if (!lineIsHidden(this.doc, line)) {
	        updateLineHeight(line, line.height + diff);
	      }

	      if (cm) {
	        runInOp(cm, function () {
	          cm.curOp.forceUpdate = true;
	          adjustScrollWhenAboveVisible(cm, line, diff);
	          signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
	        });
	      }
	    };

	    eventMixin(LineWidget);

	    function adjustScrollWhenAboveVisible(cm, line, diff) {
	      if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
	        addToScrollTop(cm, diff);
	      }
	    }

	    function addLineWidget(doc, handle, node, options) {
	      var widget = new LineWidget(doc, node, options);
	      var cm = doc.cm;

	      if (cm && widget.noHScroll) {
	        cm.display.alignWidgets = true;
	      }

	      changeLine(doc, handle, "widget", function (line) {
	        var widgets = line.widgets || (line.widgets = []);

	        if (widget.insertAt == null) {
	          widgets.push(widget);
	        } else {
	          widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
	        }

	        widget.line = line;

	        if (cm && !lineIsHidden(doc, line)) {
	          var aboveVisible = heightAtLine(line) < doc.scrollTop;
	          updateLineHeight(line, line.height + widgetHeight(widget));

	          if (aboveVisible) {
	            addToScrollTop(cm, widget.height);
	          }

	          cm.curOp.forceUpdate = true;
	        }

	        return true;
	      });

	      if (cm) {
	        signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
	      }

	      return widget;
	    } // TEXTMARKERS
	    // Created with markText and setBookmark methods. A TextMarker is a
	    // handle that can be used to clear or find a marked position in the
	    // document. Line objects hold arrays (markedSpans) containing
	    // {from, to, marker} object pointing to such marker objects, and
	    // indicating that such a marker is present on that line. Multiple
	    // lines may point to the same marker when it spans across lines.
	    // The spans will have null for their from/to properties when the
	    // marker continues beyond the start/end of the line. Markers have
	    // links back to the lines they currently touch.
	    // Collapsed markers have unique ids, in order to be able to order
	    // them, which is needed for uniquely determining an outer marker
	    // when they overlap (they may nest, but not partially overlap).


	    var nextMarkerId = 0;

	    var TextMarker = function (doc, type) {
	      this.lines = [];
	      this.type = type;
	      this.doc = doc;
	      this.id = ++nextMarkerId;
	    }; // Clear the marker.


	    TextMarker.prototype.clear = function () {
	      if (this.explicitlyCleared) {
	        return;
	      }

	      var cm = this.doc.cm,
	          withOp = cm && !cm.curOp;

	      if (withOp) {
	        startOperation(cm);
	      }

	      if (hasHandler(this, "clear")) {
	        var found = this.find();

	        if (found) {
	          signalLater(this, "clear", found.from, found.to);
	        }
	      }

	      var min = null,
	          max = null;

	      for (var i = 0; i < this.lines.length; ++i) {
	        var line = this.lines[i];
	        var span = getMarkedSpanFor(line.markedSpans, this);

	        if (cm && !this.collapsed) {
	          regLineChange(cm, lineNo(line), "text");
	        } else if (cm) {
	          if (span.to != null) {
	            max = lineNo(line);
	          }

	          if (span.from != null) {
	            min = lineNo(line);
	          }
	        }

	        line.markedSpans = removeMarkedSpan(line.markedSpans, span);

	        if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
	          updateLineHeight(line, textHeight(cm.display));
	        }
	      }

	      if (cm && this.collapsed && !cm.options.lineWrapping) {
	        for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
	          var visual = visualLine(this.lines[i$1]),
	              len = lineLength(visual);

	          if (len > cm.display.maxLineLength) {
	            cm.display.maxLine = visual;
	            cm.display.maxLineLength = len;
	            cm.display.maxLineChanged = true;
	          }
	        }
	      }

	      if (min != null && cm && this.collapsed) {
	        regChange(cm, min, max + 1);
	      }

	      this.lines.length = 0;
	      this.explicitlyCleared = true;

	      if (this.atomic && this.doc.cantEdit) {
	        this.doc.cantEdit = false;

	        if (cm) {
	          reCheckSelection(cm.doc);
	        }
	      }

	      if (cm) {
	        signalLater(cm, "markerCleared", cm, this, min, max);
	      }

	      if (withOp) {
	        endOperation(cm);
	      }

	      if (this.parent) {
	        this.parent.clear();
	      }
	    }; // Find the position of the marker in the document. Returns a {from,
	    // to} object by default. Side can be passed to get a specific side
	    // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	    // Pos objects returned contain a line object, rather than a line
	    // number (used to prevent looking up the same line twice).


	    TextMarker.prototype.find = function (side, lineObj) {
	      if (side == null && this.type == "bookmark") {
	        side = 1;
	      }

	      var from, to;

	      for (var i = 0; i < this.lines.length; ++i) {
	        var line = this.lines[i];
	        var span = getMarkedSpanFor(line.markedSpans, this);

	        if (span.from != null) {
	          from = Pos(lineObj ? line : lineNo(line), span.from);

	          if (side == -1) {
	            return from;
	          }
	        }

	        if (span.to != null) {
	          to = Pos(lineObj ? line : lineNo(line), span.to);

	          if (side == 1) {
	            return to;
	          }
	        }
	      }

	      return from && {
	        from: from,
	        to: to
	      };
	    }; // Signals that the marker's widget changed, and surrounding layout
	    // should be recomputed.


	    TextMarker.prototype.changed = function () {
	      var this$1 = this;
	      var pos = this.find(-1, true),
	          widget = this,
	          cm = this.doc.cm;

	      if (!pos || !cm) {
	        return;
	      }

	      runInOp(cm, function () {
	        var line = pos.line,
	            lineN = lineNo(pos.line);
	        var view = findViewForLine(cm, lineN);

	        if (view) {
	          clearLineMeasurementCacheFor(view);
	          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
	        }

	        cm.curOp.updateMaxLine = true;

	        if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	          var oldHeight = widget.height;
	          widget.height = null;
	          var dHeight = widgetHeight(widget) - oldHeight;

	          if (dHeight) {
	            updateLineHeight(line, line.height + dHeight);
	          }
	        }

	        signalLater(cm, "markerChanged", cm, this$1);
	      });
	    };

	    TextMarker.prototype.attachLine = function (line) {
	      if (!this.lines.length && this.doc.cm) {
	        var op = this.doc.cm.curOp;

	        if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
	          (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
	        }
	      }

	      this.lines.push(line);
	    };

	    TextMarker.prototype.detachLine = function (line) {
	      this.lines.splice(indexOf(this.lines, line), 1);

	      if (!this.lines.length && this.doc.cm) {
	        var op = this.doc.cm.curOp;
	        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
	      }
	    };

	    eventMixin(TextMarker); // Create a marker, wire it up to the right lines, and

	    function markText(doc, from, to, options, type) {
	      // Shared markers (across linked documents) are handled separately
	      // (markTextShared will call out to this again, once per
	      // document).
	      if (options && options.shared) {
	        return markTextShared(doc, from, to, options, type);
	      } // Ensure we are in an operation.


	      if (doc.cm && !doc.cm.curOp) {
	        return operation(doc.cm, markText)(doc, from, to, options, type);
	      }

	      var marker = new TextMarker(doc, type),
	          diff = cmp(from, to);

	      if (options) {
	        copyObj(options, marker, false);
	      } // Don't connect empty markers unless clearWhenEmpty is false


	      if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
	        return marker;
	      }

	      if (marker.replacedWith) {
	        // Showing up as a widget implies collapsed (widget replaces text)
	        marker.collapsed = true;
	        marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");

	        if (!options.handleMouseEvents) {
	          marker.widgetNode.setAttribute("cm-ignore-events", "true");
	        }

	        if (options.insertLeft) {
	          marker.widgetNode.insertLeft = true;
	        }
	      }

	      if (marker.collapsed) {
	        if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
	          throw new Error("Inserting collapsed marker partially overlapping an existing one");
	        }

	        seeCollapsedSpans();
	      }

	      if (marker.addToHistory) {
	        addChangeToHistory(doc, {
	          from: from,
	          to: to,
	          origin: "markText"
	        }, doc.sel, NaN);
	      }

	      var curLine = from.line,
	          cm = doc.cm,
	          updateMaxLine;
	      doc.iter(curLine, to.line + 1, function (line) {
	        if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
	          updateMaxLine = true;
	        }

	        if (marker.collapsed && curLine != from.line) {
	          updateLineHeight(line, 0);
	        }

	        addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
	        ++curLine;
	      }); // lineIsHidden depends on the presence of the spans, so needs a second pass

	      if (marker.collapsed) {
	        doc.iter(from.line, to.line + 1, function (line) {
	          if (lineIsHidden(doc, line)) {
	            updateLineHeight(line, 0);
	          }
	        });
	      }

	      if (marker.clearOnEnter) {
	        on(marker, "beforeCursorEnter", function () {
	          return marker.clear();
	        });
	      }

	      if (marker.readOnly) {
	        seeReadOnlySpans();

	        if (doc.history.done.length || doc.history.undone.length) {
	          doc.clearHistory();
	        }
	      }

	      if (marker.collapsed) {
	        marker.id = ++nextMarkerId;
	        marker.atomic = true;
	      }

	      if (cm) {
	        // Sync editor state
	        if (updateMaxLine) {
	          cm.curOp.updateMaxLine = true;
	        }

	        if (marker.collapsed) {
	          regChange(cm, from.line, to.line + 1);
	        } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
	          for (var i = from.line; i <= to.line; i++) {
	            regLineChange(cm, i, "text");
	          }
	        }

	        if (marker.atomic) {
	          reCheckSelection(cm.doc);
	        }

	        signalLater(cm, "markerAdded", cm, marker);
	      }

	      return marker;
	    } // SHARED TEXTMARKERS
	    // A shared marker spans multiple linked documents. It is
	    // implemented as a meta-marker-object controlling multiple normal
	    // markers.


	    var SharedTextMarker = function (markers, primary) {
	      this.markers = markers;
	      this.primary = primary;

	      for (var i = 0; i < markers.length; ++i) {
	        markers[i].parent = this;
	      }
	    };

	    SharedTextMarker.prototype.clear = function () {
	      if (this.explicitlyCleared) {
	        return;
	      }

	      this.explicitlyCleared = true;

	      for (var i = 0; i < this.markers.length; ++i) {
	        this.markers[i].clear();
	      }

	      signalLater(this, "clear");
	    };

	    SharedTextMarker.prototype.find = function (side, lineObj) {
	      return this.primary.find(side, lineObj);
	    };

	    eventMixin(SharedTextMarker);

	    function markTextShared(doc, from, to, options, type) {
	      options = copyObj(options);
	      options.shared = false;
	      var markers = [markText(doc, from, to, options, type)],
	          primary = markers[0];
	      var widget = options.widgetNode;
	      linkedDocs(doc, function (doc) {
	        if (widget) {
	          options.widgetNode = widget.cloneNode(true);
	        }

	        markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));

	        for (var i = 0; i < doc.linked.length; ++i) {
	          if (doc.linked[i].isParent) {
	            return;
	          }
	        }

	        primary = lst(markers);
	      });
	      return new SharedTextMarker(markers, primary);
	    }

	    function findSharedMarkers(doc) {
	      return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
	        return m.parent;
	      });
	    }

	    function copySharedMarkers(doc, markers) {
	      for (var i = 0; i < markers.length; i++) {
	        var marker = markers[i],
	            pos = marker.find();
	        var mFrom = doc.clipPos(pos.from),
	            mTo = doc.clipPos(pos.to);

	        if (cmp(mFrom, mTo)) {
	          var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
	          marker.markers.push(subMark);
	          subMark.parent = marker;
	        }
	      }
	    }

	    function detachSharedMarkers(markers) {
	      var loop = function (i) {
	        var marker = markers[i],
	            linked = [marker.primary.doc];
	        linkedDocs(marker.primary.doc, function (d) {
	          return linked.push(d);
	        });

	        for (var j = 0; j < marker.markers.length; j++) {
	          var subMarker = marker.markers[j];

	          if (indexOf(linked, subMarker.doc) == -1) {
	            subMarker.parent = null;
	            marker.markers.splice(j--, 1);
	          }
	        }
	      };

	      for (var i = 0; i < markers.length; i++) loop(i);
	    }

	    var nextDocId = 0;

	    var Doc = function (text, mode, firstLine, lineSep, direction) {
	      if (!(this instanceof Doc)) {
	        return new Doc(text, mode, firstLine, lineSep, direction);
	      }

	      if (firstLine == null) {
	        firstLine = 0;
	      }

	      BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
	      this.first = firstLine;
	      this.scrollTop = this.scrollLeft = 0;
	      this.cantEdit = false;
	      this.cleanGeneration = 1;
	      this.modeFrontier = this.highlightFrontier = firstLine;
	      var start = Pos(firstLine, 0);
	      this.sel = simpleSelection(start);
	      this.history = new History(null);
	      this.id = ++nextDocId;
	      this.modeOption = mode;
	      this.lineSep = lineSep;
	      this.direction = direction == "rtl" ? "rtl" : "ltr";
	      this.extend = false;

	      if (typeof text == "string") {
	        text = this.splitLines(text);
	      }

	      updateDoc(this, {
	        from: start,
	        to: start,
	        text: text
	      });
	      setSelection(this, simpleSelection(start), sel_dontScroll);
	    };

	    Doc.prototype = createObj(BranchChunk.prototype, {
	      constructor: Doc,
	      // Iterate over the document. Supports two forms -- with only one
	      // argument, it calls that for each line in the document. With
	      // three, it iterates over the range given by the first two (with
	      // the second being non-inclusive).
	      iter: function (from, to, op) {
	        if (op) {
	          this.iterN(from - this.first, to - from, op);
	        } else {
	          this.iterN(this.first, this.first + this.size, from);
	        }
	      },
	      // Non-public interface for adding and removing lines.
	      insert: function (at, lines) {
	        var height = 0;

	        for (var i = 0; i < lines.length; ++i) {
	          height += lines[i].height;
	        }

	        this.insertInner(at - this.first, lines, height);
	      },
	      remove: function (at, n) {
	        this.removeInner(at - this.first, n);
	      },
	      // From here, the methods are part of the public interface. Most
	      // are also available from CodeMirror (editor) instances.
	      getValue: function (lineSep) {
	        var lines = getLines(this, this.first, this.first + this.size);

	        if (lineSep === false) {
	          return lines;
	        }

	        return lines.join(lineSep || this.lineSeparator());
	      },
	      setValue: docMethodOp(function (code) {
	        var top = Pos(this.first, 0),
	            last = this.first + this.size - 1;
	        makeChange(this, {
	          from: top,
	          to: Pos(last, getLine(this, last).text.length),
	          text: this.splitLines(code),
	          origin: "setValue",
	          full: true
	        }, true);

	        if (this.cm) {
	          scrollToCoords(this.cm, 0, 0);
	        }

	        setSelection(this, simpleSelection(top), sel_dontScroll);
	      }),
	      replaceRange: function (code, from, to, origin) {
	        from = clipPos(this, from);
	        to = to ? clipPos(this, to) : from;
	        replaceRange(this, code, from, to, origin);
	      },
	      getRange: function (from, to, lineSep) {
	        var lines = getBetween(this, clipPos(this, from), clipPos(this, to));

	        if (lineSep === false) {
	          return lines;
	        }

	        return lines.join(lineSep || this.lineSeparator());
	      },
	      getLine: function (line) {
	        var l = this.getLineHandle(line);
	        return l && l.text;
	      },
	      getLineHandle: function (line) {
	        if (isLine(this, line)) {
	          return getLine(this, line);
	        }
	      },
	      getLineNumber: function (line) {
	        return lineNo(line);
	      },
	      getLineHandleVisualStart: function (line) {
	        if (typeof line == "number") {
	          line = getLine(this, line);
	        }

	        return visualLine(line);
	      },
	      lineCount: function () {
	        return this.size;
	      },
	      firstLine: function () {
	        return this.first;
	      },
	      lastLine: function () {
	        return this.first + this.size - 1;
	      },
	      clipPos: function (pos) {
	        return clipPos(this, pos);
	      },
	      getCursor: function (start) {
	        var range = this.sel.primary(),
	            pos;

	        if (start == null || start == "head") {
	          pos = range.head;
	        } else if (start == "anchor") {
	          pos = range.anchor;
	        } else if (start == "end" || start == "to" || start === false) {
	          pos = range.to();
	        } else {
	          pos = range.from();
	        }

	        return pos;
	      },
	      listSelections: function () {
	        return this.sel.ranges;
	      },
	      somethingSelected: function () {
	        return this.sel.somethingSelected();
	      },
	      setCursor: docMethodOp(function (line, ch, options) {
	        setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
	      }),
	      setSelection: docMethodOp(function (anchor, head, options) {
	        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
	      }),
	      extendSelection: docMethodOp(function (head, other, options) {
	        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
	      }),
	      extendSelections: docMethodOp(function (heads, options) {
	        extendSelections(this, clipPosArray(this, heads), options);
	      }),
	      extendSelectionsBy: docMethodOp(function (f, options) {
	        var heads = map(this.sel.ranges, f);
	        extendSelections(this, clipPosArray(this, heads), options);
	      }),
	      setSelections: docMethodOp(function (ranges, primary, options) {
	        if (!ranges.length) {
	          return;
	        }

	        var out = [];

	        for (var i = 0; i < ranges.length; i++) {
	          out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head));
	        }

	        if (primary == null) {
	          primary = Math.min(ranges.length - 1, this.sel.primIndex);
	        }

	        setSelection(this, normalizeSelection(this.cm, out, primary), options);
	      }),
	      addSelection: docMethodOp(function (anchor, head, options) {
	        var ranges = this.sel.ranges.slice(0);
	        ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
	        setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
	      }),
	      getSelection: function (lineSep) {
	        var ranges = this.sel.ranges,
	            lines;

	        for (var i = 0; i < ranges.length; i++) {
	          var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	          lines = lines ? lines.concat(sel) : sel;
	        }

	        if (lineSep === false) {
	          return lines;
	        } else {
	          return lines.join(lineSep || this.lineSeparator());
	        }
	      },
	      getSelections: function (lineSep) {
	        var parts = [],
	            ranges = this.sel.ranges;

	        for (var i = 0; i < ranges.length; i++) {
	          var sel = getBetween(this, ranges[i].from(), ranges[i].to());

	          if (lineSep !== false) {
	            sel = sel.join(lineSep || this.lineSeparator());
	          }

	          parts[i] = sel;
	        }

	        return parts;
	      },
	      replaceSelection: function (code, collapse, origin) {
	        var dup = [];

	        for (var i = 0; i < this.sel.ranges.length; i++) {
	          dup[i] = code;
	        }

	        this.replaceSelections(dup, collapse, origin || "+input");
	      },
	      replaceSelections: docMethodOp(function (code, collapse, origin) {
	        var changes = [],
	            sel = this.sel;

	        for (var i = 0; i < sel.ranges.length; i++) {
	          var range = sel.ranges[i];
	          changes[i] = {
	            from: range.from(),
	            to: range.to(),
	            text: this.splitLines(code[i]),
	            origin: origin
	          };
	        }

	        var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);

	        for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
	          makeChange(this, changes[i$1]);
	        }

	        if (newSel) {
	          setSelectionReplaceHistory(this, newSel);
	        } else if (this.cm) {
	          ensureCursorVisible(this.cm);
	        }
	      }),
	      undo: docMethodOp(function () {
	        makeChangeFromHistory(this, "undo");
	      }),
	      redo: docMethodOp(function () {
	        makeChangeFromHistory(this, "redo");
	      }),
	      undoSelection: docMethodOp(function () {
	        makeChangeFromHistory(this, "undo", true);
	      }),
	      redoSelection: docMethodOp(function () {
	        makeChangeFromHistory(this, "redo", true);
	      }),
	      setExtending: function (val) {
	        this.extend = val;
	      },
	      getExtending: function () {
	        return this.extend;
	      },
	      historySize: function () {
	        var hist = this.history,
	            done = 0,
	            undone = 0;

	        for (var i = 0; i < hist.done.length; i++) {
	          if (!hist.done[i].ranges) {
	            ++done;
	          }
	        }

	        for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
	          if (!hist.undone[i$1].ranges) {
	            ++undone;
	          }
	        }

	        return {
	          undo: done,
	          redo: undone
	        };
	      },
	      clearHistory: function () {
	        var this$1 = this;
	        this.history = new History(this.history.maxGeneration);
	        linkedDocs(this, function (doc) {
	          return doc.history = this$1.history;
	        }, true);
	      },
	      markClean: function () {
	        this.cleanGeneration = this.changeGeneration(true);
	      },
	      changeGeneration: function (forceSplit) {
	        if (forceSplit) {
	          this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
	        }

	        return this.history.generation;
	      },
	      isClean: function (gen) {
	        return this.history.generation == (gen || this.cleanGeneration);
	      },
	      getHistory: function () {
	        return {
	          done: copyHistoryArray(this.history.done),
	          undone: copyHistoryArray(this.history.undone)
	        };
	      },
	      setHistory: function (histData) {
	        var hist = this.history = new History(this.history.maxGeneration);
	        hist.done = copyHistoryArray(histData.done.slice(0), null, true);
	        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
	      },
	      setGutterMarker: docMethodOp(function (line, gutterID, value) {
	        return changeLine(this, line, "gutter", function (line) {
	          var markers = line.gutterMarkers || (line.gutterMarkers = {});
	          markers[gutterID] = value;

	          if (!value && isEmpty(markers)) {
	            line.gutterMarkers = null;
	          }

	          return true;
	        });
	      }),
	      clearGutter: docMethodOp(function (gutterID) {
	        var this$1 = this;
	        this.iter(function (line) {
	          if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	            changeLine(this$1, line, "gutter", function () {
	              line.gutterMarkers[gutterID] = null;

	              if (isEmpty(line.gutterMarkers)) {
	                line.gutterMarkers = null;
	              }

	              return true;
	            });
	          }
	        });
	      }),
	      lineInfo: function (line) {
	        var n;

	        if (typeof line == "number") {
	          if (!isLine(this, line)) {
	            return null;
	          }

	          n = line;
	          line = getLine(this, line);

	          if (!line) {
	            return null;
	          }
	        } else {
	          n = lineNo(line);

	          if (n == null) {
	            return null;
	          }
	        }

	        return {
	          line: n,
	          handle: line,
	          text: line.text,
	          gutterMarkers: line.gutterMarkers,
	          textClass: line.textClass,
	          bgClass: line.bgClass,
	          wrapClass: line.wrapClass,
	          widgets: line.widgets
	        };
	      },
	      addLineClass: docMethodOp(function (handle, where, cls) {
	        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	          var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";

	          if (!line[prop]) {
	            line[prop] = cls;
	          } else if (classTest(cls).test(line[prop])) {
	            return false;
	          } else {
	            line[prop] += " " + cls;
	          }

	          return true;
	        });
	      }),
	      removeLineClass: docMethodOp(function (handle, where, cls) {
	        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	          var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
	          var cur = line[prop];

	          if (!cur) {
	            return false;
	          } else if (cls == null) {
	            line[prop] = null;
	          } else {
	            var found = cur.match(classTest(cls));

	            if (!found) {
	              return false;
	            }

	            var end = found.index + found[0].length;
	            line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
	          }

	          return true;
	        });
	      }),
	      addLineWidget: docMethodOp(function (handle, node, options) {
	        return addLineWidget(this, handle, node, options);
	      }),
	      removeLineWidget: function (widget) {
	        widget.clear();
	      },
	      markText: function (from, to, options) {
	        return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
	      },
	      setBookmark: function (pos, options) {
	        var realOpts = {
	          replacedWith: options && (options.nodeType == null ? options.widget : options),
	          insertLeft: options && options.insertLeft,
	          clearWhenEmpty: false,
	          shared: options && options.shared,
	          handleMouseEvents: options && options.handleMouseEvents
	        };
	        pos = clipPos(this, pos);
	        return markText(this, pos, pos, realOpts, "bookmark");
	      },
	      findMarksAt: function (pos) {
	        pos = clipPos(this, pos);
	        var markers = [],
	            spans = getLine(this, pos.line).markedSpans;

	        if (spans) {
	          for (var i = 0; i < spans.length; ++i) {
	            var span = spans[i];

	            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
	              markers.push(span.marker.parent || span.marker);
	            }
	          }
	        }

	        return markers;
	      },
	      findMarks: function (from, to, filter) {
	        from = clipPos(this, from);
	        to = clipPos(this, to);
	        var found = [],
	            lineNo = from.line;
	        this.iter(from.line, to.line + 1, function (line) {
	          var spans = line.markedSpans;

	          if (spans) {
	            for (var i = 0; i < spans.length; i++) {
	              var span = spans[i];

	              if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
	                found.push(span.marker.parent || span.marker);
	              }
	            }
	          }

	          ++lineNo;
	        });
	        return found;
	      },
	      getAllMarks: function () {
	        var markers = [];
	        this.iter(function (line) {
	          var sps = line.markedSpans;

	          if (sps) {
	            for (var i = 0; i < sps.length; ++i) {
	              if (sps[i].from != null) {
	                markers.push(sps[i].marker);
	              }
	            }
	          }
	        });
	        return markers;
	      },
	      posFromIndex: function (off) {
	        var ch,
	            lineNo = this.first,
	            sepSize = this.lineSeparator().length;
	        this.iter(function (line) {
	          var sz = line.text.length + sepSize;

	          if (sz > off) {
	            ch = off;
	            return true;
	          }

	          off -= sz;
	          ++lineNo;
	        });
	        return clipPos(this, Pos(lineNo, ch));
	      },
	      indexFromPos: function (coords) {
	        coords = clipPos(this, coords);
	        var index = coords.ch;

	        if (coords.line < this.first || coords.ch < 0) {
	          return 0;
	        }

	        var sepSize = this.lineSeparator().length;
	        this.iter(this.first, coords.line, function (line) {
	          // iter aborts when callback returns a truthy value
	          index += line.text.length + sepSize;
	        });
	        return index;
	      },
	      copy: function (copyHistory) {
	        var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
	        doc.scrollTop = this.scrollTop;
	        doc.scrollLeft = this.scrollLeft;
	        doc.sel = this.sel;
	        doc.extend = false;

	        if (copyHistory) {
	          doc.history.undoDepth = this.history.undoDepth;
	          doc.setHistory(this.getHistory());
	        }

	        return doc;
	      },
	      linkedDoc: function (options) {
	        if (!options) {
	          options = {};
	        }

	        var from = this.first,
	            to = this.first + this.size;

	        if (options.from != null && options.from > from) {
	          from = options.from;
	        }

	        if (options.to != null && options.to < to) {
	          to = options.to;
	        }

	        var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);

	        if (options.sharedHist) {
	          copy.history = this.history;
	        }

	        (this.linked || (this.linked = [])).push({
	          doc: copy,
	          sharedHist: options.sharedHist
	        });
	        copy.linked = [{
	          doc: this,
	          isParent: true,
	          sharedHist: options.sharedHist
	        }];
	        copySharedMarkers(copy, findSharedMarkers(this));
	        return copy;
	      },
	      unlinkDoc: function (other) {
	        if (other instanceof CodeMirror) {
	          other = other.doc;
	        }

	        if (this.linked) {
	          for (var i = 0; i < this.linked.length; ++i) {
	            var link = this.linked[i];

	            if (link.doc != other) {
	              continue;
	            }

	            this.linked.splice(i, 1);
	            other.unlinkDoc(this);
	            detachSharedMarkers(findSharedMarkers(this));
	            break;
	          }
	        } // If the histories were shared, split them again


	        if (other.history == this.history) {
	          var splitIds = [other.id];
	          linkedDocs(other, function (doc) {
	            return splitIds.push(doc.id);
	          }, true);
	          other.history = new History(null);
	          other.history.done = copyHistoryArray(this.history.done, splitIds);
	          other.history.undone = copyHistoryArray(this.history.undone, splitIds);
	        }
	      },
	      iterLinkedDocs: function (f) {
	        linkedDocs(this, f);
	      },
	      getMode: function () {
	        return this.mode;
	      },
	      getEditor: function () {
	        return this.cm;
	      },
	      splitLines: function (str) {
	        if (this.lineSep) {
	          return str.split(this.lineSep);
	        }

	        return splitLinesAuto(str);
	      },
	      lineSeparator: function () {
	        return this.lineSep || "\n";
	      },
	      setDirection: docMethodOp(function (dir) {
	        if (dir != "rtl") {
	          dir = "ltr";
	        }

	        if (dir == this.direction) {
	          return;
	        }

	        this.direction = dir;
	        this.iter(function (line) {
	          return line.order = null;
	        });

	        if (this.cm) {
	          directionChanged(this.cm);
	        }
	      })
	    }); // Public alias.

	    Doc.prototype.eachLine = Doc.prototype.iter; // Kludge to work around strange IE behavior where it'll sometimes
	    // re-fire a series of drag-related events right after the drop (#1551)

	    var lastDrop = 0;

	    function onDrop(e) {
	      var cm = this;
	      clearDragCursor(cm);

	      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
	        return;
	      }

	      e_preventDefault(e);

	      if (ie) {
	        lastDrop = +new Date();
	      }

	      var pos = posFromMouse(cm, e, true),
	          files = e.dataTransfer.files;

	      if (!pos || cm.isReadOnly()) {
	        return;
	      } // Might be a file drop, in which case we simply extract the text
	      // and insert it.


	      if (files && files.length && window.FileReader && window.File) {
	        var n = files.length,
	            text = Array(n),
	            read = 0;

	        var markAsReadAndPasteIfAllFilesAreRead = function () {
	          if (++read == n) {
	            operation(cm, function () {
	              pos = clipPos(cm.doc, pos);
	              var change = {
	                from: pos,
	                to: pos,
	                text: cm.doc.splitLines(text.filter(function (t) {
	                  return t != null;
	                }).join(cm.doc.lineSeparator())),
	                origin: "paste"
	              };
	              makeChange(cm.doc, change);
	              setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
	            })();
	          }
	        };

	        var readTextFromFile = function (file, i) {
	          if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
	            markAsReadAndPasteIfAllFilesAreRead();
	            return;
	          }

	          var reader = new FileReader();

	          reader.onerror = function () {
	            return markAsReadAndPasteIfAllFilesAreRead();
	          };

	          reader.onload = function () {
	            var content = reader.result;

	            if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
	              markAsReadAndPasteIfAllFilesAreRead();
	              return;
	            }

	            text[i] = content;
	            markAsReadAndPasteIfAllFilesAreRead();
	          };

	          reader.readAsText(file);
	        };

	        for (var i = 0; i < files.length; i++) {
	          readTextFromFile(files[i], i);
	        }
	      } else {
	        // Normal drop
	        // Don't do a replace if the drop happened inside of the selected text.
	        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	          cm.state.draggingText(e); // Ensure the editor is re-focused

	          setTimeout(function () {
	            return cm.display.input.focus();
	          }, 20);
	          return;
	        }

	        try {
	          var text$1 = e.dataTransfer.getData("Text");

	          if (text$1) {
	            var selected;

	            if (cm.state.draggingText && !cm.state.draggingText.copy) {
	              selected = cm.listSelections();
	            }

	            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));

	            if (selected) {
	              for (var i$1 = 0; i$1 < selected.length; ++i$1) {
	                replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
	              }
	            }

	            cm.replaceSelection(text$1, "around", "paste");
	            cm.display.input.focus();
	          }
	        } catch (e$1) {}
	      }
	    }

	    function onDragStart(cm, e) {
	      if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
	        e_stop(e);
	        return;
	      }

	      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
	        return;
	      }

	      e.dataTransfer.setData("Text", cm.getSelection());
	      e.dataTransfer.effectAllowed = "copyMove"; // Use dummy image instead of default browsers image.
	      // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.

	      if (e.dataTransfer.setDragImage && !safari) {
	        var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
	        img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";

	        if (presto) {
	          img.width = img.height = 1;
	          cm.display.wrapper.appendChild(img); // Force a relayout, or Opera won't use our image for some obscure reason

	          img._top = img.offsetTop;
	        }

	        e.dataTransfer.setDragImage(img, 0, 0);

	        if (presto) {
	          img.parentNode.removeChild(img);
	        }
	      }
	    }

	    function onDragOver(cm, e) {
	      var pos = posFromMouse(cm, e);

	      if (!pos) {
	        return;
	      }

	      var frag = document.createDocumentFragment();
	      drawSelectionCursor(cm, pos, frag);

	      if (!cm.display.dragCursor) {
	        cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
	        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
	      }

	      removeChildrenAndAdd(cm.display.dragCursor, frag);
	    }

	    function clearDragCursor(cm) {
	      if (cm.display.dragCursor) {
	        cm.display.lineSpace.removeChild(cm.display.dragCursor);
	        cm.display.dragCursor = null;
	      }
	    } // These must be handled carefully, because naively registering a
	    // handler for each editor will cause the editors to never be
	    // garbage collected.


	    function forEachCodeMirror(f) {
	      if (!document.getElementsByClassName) {
	        return;
	      }

	      var byClass = document.getElementsByClassName("CodeMirror"),
	          editors = [];

	      for (var i = 0; i < byClass.length; i++) {
	        var cm = byClass[i].CodeMirror;

	        if (cm) {
	          editors.push(cm);
	        }
	      }

	      if (editors.length) {
	        editors[0].operation(function () {
	          for (var i = 0; i < editors.length; i++) {
	            f(editors[i]);
	          }
	        });
	      }
	    }

	    var globalsRegistered = false;

	    function ensureGlobalHandlers() {
	      if (globalsRegistered) {
	        return;
	      }

	      registerGlobalHandlers();
	      globalsRegistered = true;
	    }

	    function registerGlobalHandlers() {
	      // When the window resizes, we need to refresh active editors.
	      var resizeTimer;
	      on(window, "resize", function () {
	        if (resizeTimer == null) {
	          resizeTimer = setTimeout(function () {
	            resizeTimer = null;
	            forEachCodeMirror(onResize);
	          }, 100);
	        }
	      }); // When the window loses focus, we want to show the editor as blurred

	      on(window, "blur", function () {
	        return forEachCodeMirror(onBlur);
	      });
	    } // Called when the window resizes


	    function onResize(cm) {
	      var d = cm.display; // Might be a text scaling operation, clear size caches.

	      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	      d.scrollbarsClipped = false;
	      cm.setSize();
	    }

	    var keyNames = {
	      3: "Pause",
	      8: "Backspace",
	      9: "Tab",
	      13: "Enter",
	      16: "Shift",
	      17: "Ctrl",
	      18: "Alt",
	      19: "Pause",
	      20: "CapsLock",
	      27: "Esc",
	      32: "Space",
	      33: "PageUp",
	      34: "PageDown",
	      35: "End",
	      36: "Home",
	      37: "Left",
	      38: "Up",
	      39: "Right",
	      40: "Down",
	      44: "PrintScrn",
	      45: "Insert",
	      46: "Delete",
	      59: ";",
	      61: "=",
	      91: "Mod",
	      92: "Mod",
	      93: "Mod",
	      106: "*",
	      107: "=",
	      109: "-",
	      110: ".",
	      111: "/",
	      145: "ScrollLock",
	      173: "-",
	      186: ";",
	      187: "=",
	      188: ",",
	      189: "-",
	      190: ".",
	      191: "/",
	      192: "`",
	      219: "[",
	      220: "\\",
	      221: "]",
	      222: "'",
	      224: "Mod",
	      63232: "Up",
	      63233: "Down",
	      63234: "Left",
	      63235: "Right",
	      63272: "Delete",
	      63273: "Home",
	      63275: "End",
	      63276: "PageUp",
	      63277: "PageDown",
	      63302: "Insert"
	    }; // Number keys

	    for (var i = 0; i < 10; i++) {
	      keyNames[i + 48] = keyNames[i + 96] = String(i);
	    } // Alphabetic keys


	    for (var i$1 = 65; i$1 <= 90; i$1++) {
	      keyNames[i$1] = String.fromCharCode(i$1);
	    } // Function keys


	    for (var i$2 = 1; i$2 <= 12; i$2++) {
	      keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
	    }

	    var keyMap = {};
	    keyMap.basic = {
	      "Left": "goCharLeft",
	      "Right": "goCharRight",
	      "Up": "goLineUp",
	      "Down": "goLineDown",
	      "End": "goLineEnd",
	      "Home": "goLineStartSmart",
	      "PageUp": "goPageUp",
	      "PageDown": "goPageDown",
	      "Delete": "delCharAfter",
	      "Backspace": "delCharBefore",
	      "Shift-Backspace": "delCharBefore",
	      "Tab": "defaultTab",
	      "Shift-Tab": "indentAuto",
	      "Enter": "newlineAndIndent",
	      "Insert": "toggleOverwrite",
	      "Esc": "singleSelection"
	    }; // Note that the save and find-related commands aren't defined by
	    // default. User code or addons can define them. Unknown commands
	    // are simply ignored.

	    keyMap.pcDefault = {
	      "Ctrl-A": "selectAll",
	      "Ctrl-D": "deleteLine",
	      "Ctrl-Z": "undo",
	      "Shift-Ctrl-Z": "redo",
	      "Ctrl-Y": "redo",
	      "Ctrl-Home": "goDocStart",
	      "Ctrl-End": "goDocEnd",
	      "Ctrl-Up": "goLineUp",
	      "Ctrl-Down": "goLineDown",
	      "Ctrl-Left": "goGroupLeft",
	      "Ctrl-Right": "goGroupRight",
	      "Alt-Left": "goLineStart",
	      "Alt-Right": "goLineEnd",
	      "Ctrl-Backspace": "delGroupBefore",
	      "Ctrl-Delete": "delGroupAfter",
	      "Ctrl-S": "save",
	      "Ctrl-F": "find",
	      "Ctrl-G": "findNext",
	      "Shift-Ctrl-G": "findPrev",
	      "Shift-Ctrl-F": "replace",
	      "Shift-Ctrl-R": "replaceAll",
	      "Ctrl-[": "indentLess",
	      "Ctrl-]": "indentMore",
	      "Ctrl-U": "undoSelection",
	      "Shift-Ctrl-U": "redoSelection",
	      "Alt-U": "redoSelection",
	      "fallthrough": "basic"
	    }; // Very basic readline/emacs-style bindings, which are standard on Mac.

	    keyMap.emacsy = {
	      "Ctrl-F": "goCharRight",
	      "Ctrl-B": "goCharLeft",
	      "Ctrl-P": "goLineUp",
	      "Ctrl-N": "goLineDown",
	      "Alt-F": "goWordRight",
	      "Alt-B": "goWordLeft",
	      "Ctrl-A": "goLineStart",
	      "Ctrl-E": "goLineEnd",
	      "Ctrl-V": "goPageDown",
	      "Shift-Ctrl-V": "goPageUp",
	      "Ctrl-D": "delCharAfter",
	      "Ctrl-H": "delCharBefore",
	      "Alt-D": "delWordAfter",
	      "Alt-Backspace": "delWordBefore",
	      "Ctrl-K": "killLine",
	      "Ctrl-T": "transposeChars",
	      "Ctrl-O": "openLine"
	    };
	    keyMap.macDefault = {
	      "Cmd-A": "selectAll",
	      "Cmd-D": "deleteLine",
	      "Cmd-Z": "undo",
	      "Shift-Cmd-Z": "redo",
	      "Cmd-Y": "redo",
	      "Cmd-Home": "goDocStart",
	      "Cmd-Up": "goDocStart",
	      "Cmd-End": "goDocEnd",
	      "Cmd-Down": "goDocEnd",
	      "Alt-Left": "goGroupLeft",
	      "Alt-Right": "goGroupRight",
	      "Cmd-Left": "goLineLeft",
	      "Cmd-Right": "goLineRight",
	      "Alt-Backspace": "delGroupBefore",
	      "Ctrl-Alt-Backspace": "delGroupAfter",
	      "Alt-Delete": "delGroupAfter",
	      "Cmd-S": "save",
	      "Cmd-F": "find",
	      "Cmd-G": "findNext",
	      "Shift-Cmd-G": "findPrev",
	      "Cmd-Alt-F": "replace",
	      "Shift-Cmd-Alt-F": "replaceAll",
	      "Cmd-[": "indentLess",
	      "Cmd-]": "indentMore",
	      "Cmd-Backspace": "delWrappedLineLeft",
	      "Cmd-Delete": "delWrappedLineRight",
	      "Cmd-U": "undoSelection",
	      "Shift-Cmd-U": "redoSelection",
	      "Ctrl-Up": "goDocStart",
	      "Ctrl-Down": "goDocEnd",
	      "fallthrough": ["basic", "emacsy"]
	    };
	    keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault; // KEYMAP DISPATCH

	    function normalizeKeyName(name) {
	      var parts = name.split(/-(?!$)/);
	      name = parts[parts.length - 1];
	      var alt, ctrl, shift, cmd;

	      for (var i = 0; i < parts.length - 1; i++) {
	        var mod = parts[i];

	        if (/^(cmd|meta|m)$/i.test(mod)) {
	          cmd = true;
	        } else if (/^a(lt)?$/i.test(mod)) {
	          alt = true;
	        } else if (/^(c|ctrl|control)$/i.test(mod)) {
	          ctrl = true;
	        } else if (/^s(hift)?$/i.test(mod)) {
	          shift = true;
	        } else {
	          throw new Error("Unrecognized modifier name: " + mod);
	        }
	      }

	      if (alt) {
	        name = "Alt-" + name;
	      }

	      if (ctrl) {
	        name = "Ctrl-" + name;
	      }

	      if (cmd) {
	        name = "Cmd-" + name;
	      }

	      if (shift) {
	        name = "Shift-" + name;
	      }

	      return name;
	    } // This is a kludge to keep keymaps mostly working as raw objects
	    // (backwards compatibility) while at the same time support features
	    // like normalization and multi-stroke key bindings. It compiles a
	    // new normalized keymap, and then updates the old object to reflect
	    // this.


	    function normalizeKeyMap(keymap) {
	      var copy = {};

	      for (var keyname in keymap) {
	        if (keymap.hasOwnProperty(keyname)) {
	          var value = keymap[keyname];

	          if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
	            continue;
	          }

	          if (value == "...") {
	            delete keymap[keyname];
	            continue;
	          }

	          var keys = map(keyname.split(" "), normalizeKeyName);

	          for (var i = 0; i < keys.length; i++) {
	            var val = void 0,
	                name = void 0;

	            if (i == keys.length - 1) {
	              name = keys.join(" ");
	              val = value;
	            } else {
	              name = keys.slice(0, i + 1).join(" ");
	              val = "...";
	            }

	            var prev = copy[name];

	            if (!prev) {
	              copy[name] = val;
	            } else if (prev != val) {
	              throw new Error("Inconsistent bindings for " + name);
	            }
	          }

	          delete keymap[keyname];
	        }
	      }

	      for (var prop in copy) {
	        keymap[prop] = copy[prop];
	      }

	      return keymap;
	    }

	    function lookupKey(key, map, handle, context) {
	      map = getKeyMap(map);
	      var found = map.call ? map.call(key, context) : map[key];

	      if (found === false) {
	        return "nothing";
	      }

	      if (found === "...") {
	        return "multi";
	      }

	      if (found != null && handle(found)) {
	        return "handled";
	      }

	      if (map.fallthrough) {
	        if (Object.prototype.toString.call(map.fallthrough) != "[object Array]") {
	          return lookupKey(key, map.fallthrough, handle, context);
	        }

	        for (var i = 0; i < map.fallthrough.length; i++) {
	          var result = lookupKey(key, map.fallthrough[i], handle, context);

	          if (result) {
	            return result;
	          }
	        }
	      }
	    } // Modifier key presses don't count as 'real' key presses for the
	    // purpose of keymap fallthrough.


	    function isModifierKey(value) {
	      var name = typeof value == "string" ? value : keyNames[value.keyCode];
	      return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
	    }

	    function addModifierNames(name, event, noShift) {
	      var base = name;

	      if (event.altKey && base != "Alt") {
	        name = "Alt-" + name;
	      }

	      if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
	        name = "Ctrl-" + name;
	      }

	      if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
	        name = "Cmd-" + name;
	      }

	      if (!noShift && event.shiftKey && base != "Shift") {
	        name = "Shift-" + name;
	      }

	      return name;
	    } // Look up the name of a key as indicated by an event object.


	    function keyName(event, noShift) {
	      if (presto && event.keyCode == 34 && event["char"]) {
	        return false;
	      }

	      var name = keyNames[event.keyCode];

	      if (name == null || event.altGraphKey) {
	        return false;
	      } // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
	      // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)


	      if (event.keyCode == 3 && event.code) {
	        name = event.code;
	      }

	      return addModifierNames(name, event, noShift);
	    }

	    function getKeyMap(val) {
	      return typeof val == "string" ? keyMap[val] : val;
	    } // Helper for deleting text near the selection(s), used to implement
	    // backspace, delete, and similar functionality.


	    function deleteNearSelection(cm, compute) {
	      var ranges = cm.doc.sel.ranges,
	          kill = []; // Build up a set of ranges to kill first, merging overlapping
	      // ranges.

	      for (var i = 0; i < ranges.length; i++) {
	        var toKill = compute(ranges[i]);

	        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	          var replaced = kill.pop();

	          if (cmp(replaced.from, toKill.from) < 0) {
	            toKill.from = replaced.from;
	            break;
	          }
	        }

	        kill.push(toKill);
	      } // Next, remove those actual ranges.


	      runInOp(cm, function () {
	        for (var i = kill.length - 1; i >= 0; i--) {
	          replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
	        }

	        ensureCursorVisible(cm);
	      });
	    }

	    function moveCharLogically(line, ch, dir) {
	      var target = skipExtendingChars(line.text, ch + dir, dir);
	      return target < 0 || target > line.text.length ? null : target;
	    }

	    function moveLogically(line, start, dir) {
	      var ch = moveCharLogically(line, start.ch, dir);
	      return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
	    }

	    function endOfLine(visually, cm, lineObj, lineNo, dir) {
	      if (visually) {
	        if (cm.doc.direction == "rtl") {
	          dir = -dir;
	        }

	        var order = getOrder(lineObj, cm.doc.direction);

	        if (order) {
	          var part = dir < 0 ? lst(order) : order[0];
	          var moveInStorageOrder = dir < 0 == (part.level == 1);
	          var sticky = moveInStorageOrder ? "after" : "before";
	          var ch; // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
	          // it could be that the last bidi part is not on the last visual line,
	          // since visual lines contain content order-consecutive chunks.
	          // Thus, in rtl, we are looking for the first (content-order) character
	          // in the rtl chunk that is on the last line (that is, the same line
	          // as the last (content-order) character).

	          if (part.level > 0 || cm.doc.direction == "rtl") {
	            var prep = prepareMeasureForLine(cm, lineObj);
	            ch = dir < 0 ? lineObj.text.length - 1 : 0;
	            var targetTop = measureCharPrepared(cm, prep, ch).top;
	            ch = findFirst(function (ch) {
	              return measureCharPrepared(cm, prep, ch).top == targetTop;
	            }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);

	            if (sticky == "before") {
	              ch = moveCharLogically(lineObj, ch, 1);
	            }
	          } else {
	            ch = dir < 0 ? part.to : part.from;
	          }

	          return new Pos(lineNo, ch, sticky);
	        }
	      }

	      return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
	    }

	    function moveVisually(cm, line, start, dir) {
	      var bidi = getOrder(line, cm.doc.direction);

	      if (!bidi) {
	        return moveLogically(line, start, dir);
	      }

	      if (start.ch >= line.text.length) {
	        start.ch = line.text.length;
	        start.sticky = "before";
	      } else if (start.ch <= 0) {
	        start.ch = 0;
	        start.sticky = "after";
	      }

	      var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
	          part = bidi[partPos];

	      if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
	        // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
	        // nothing interesting happens.
	        return moveLogically(line, start, dir);
	      }

	      var mv = function (pos, dir) {
	        return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
	      };

	      var prep;

	      var getWrappedLineExtent = function (ch) {
	        if (!cm.options.lineWrapping) {
	          return {
	            begin: 0,
	            end: line.text.length
	          };
	        }

	        prep = prep || prepareMeasureForLine(cm, line);
	        return wrappedLineExtentChar(cm, line, prep, ch);
	      };

	      var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

	      if (cm.doc.direction == "rtl" || part.level == 1) {
	        var moveInStorageOrder = part.level == 1 == dir < 0;
	        var ch = mv(start, moveInStorageOrder ? 1 : -1);

	        if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
	          // Case 2: We move within an rtl part or in an rtl editor on the same visual line
	          var sticky = moveInStorageOrder ? "before" : "after";
	          return new Pos(start.line, ch, sticky);
	        }
	      } // Case 3: Could not move within this bidi part in this visual line, so leave
	      // the current bidi part


	      var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
	        var getRes = function (ch, moveInStorageOrder) {
	          return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
	        };

	        for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
	          var part = bidi[partPos];
	          var moveInStorageOrder = dir > 0 == (part.level != 1);
	          var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);

	          if (part.from <= ch && ch < part.to) {
	            return getRes(ch, moveInStorageOrder);
	          }

	          ch = moveInStorageOrder ? part.from : mv(part.to, -1);

	          if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {
	            return getRes(ch, moveInStorageOrder);
	          }
	        }
	      }; // Case 3a: Look for other bidi parts on the same visual line


	      var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);

	      if (res) {
	        return res;
	      } // Case 3b: Look for other bidi parts on the next visual line


	      var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);

	      if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
	        res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));

	        if (res) {
	          return res;
	        }
	      } // Case 4: Nowhere to move


	      return null;
	    } // Commands are parameter-less actions that can be performed on an
	    // editor, mostly used for keybindings.


	    var commands = {
	      selectAll: selectAll,
	      singleSelection: function (cm) {
	        return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
	      },
	      killLine: function (cm) {
	        return deleteNearSelection(cm, function (range) {
	          if (range.empty()) {
	            var len = getLine(cm.doc, range.head.line).text.length;

	            if (range.head.ch == len && range.head.line < cm.lastLine()) {
	              return {
	                from: range.head,
	                to: Pos(range.head.line + 1, 0)
	              };
	            } else {
	              return {
	                from: range.head,
	                to: Pos(range.head.line, len)
	              };
	            }
	          } else {
	            return {
	              from: range.from(),
	              to: range.to()
	            };
	          }
	        });
	      },
	      deleteLine: function (cm) {
	        return deleteNearSelection(cm, function (range) {
	          return {
	            from: Pos(range.from().line, 0),
	            to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
	          };
	        });
	      },
	      delLineLeft: function (cm) {
	        return deleteNearSelection(cm, function (range) {
	          return {
	            from: Pos(range.from().line, 0),
	            to: range.from()
	          };
	        });
	      },
	      delWrappedLineLeft: function (cm) {
	        return deleteNearSelection(cm, function (range) {
	          var top = cm.charCoords(range.head, "div").top + 5;
	          var leftPos = cm.coordsChar({
	            left: 0,
	            top: top
	          }, "div");
	          return {
	            from: leftPos,
	            to: range.from()
	          };
	        });
	      },
	      delWrappedLineRight: function (cm) {
	        return deleteNearSelection(cm, function (range) {
	          var top = cm.charCoords(range.head, "div").top + 5;
	          var rightPos = cm.coordsChar({
	            left: cm.display.lineDiv.offsetWidth + 100,
	            top: top
	          }, "div");
	          return {
	            from: range.from(),
	            to: rightPos
	          };
	        });
	      },
	      undo: function (cm) {
	        return cm.undo();
	      },
	      redo: function (cm) {
	        return cm.redo();
	      },
	      undoSelection: function (cm) {
	        return cm.undoSelection();
	      },
	      redoSelection: function (cm) {
	        return cm.redoSelection();
	      },
	      goDocStart: function (cm) {
	        return cm.extendSelection(Pos(cm.firstLine(), 0));
	      },
	      goDocEnd: function (cm) {
	        return cm.extendSelection(Pos(cm.lastLine()));
	      },
	      goLineStart: function (cm) {
	        return cm.extendSelectionsBy(function (range) {
	          return lineStart(cm, range.head.line);
	        }, {
	          origin: "+move",
	          bias: 1
	        });
	      },
	      goLineStartSmart: function (cm) {
	        return cm.extendSelectionsBy(function (range) {
	          return lineStartSmart(cm, range.head);
	        }, {
	          origin: "+move",
	          bias: 1
	        });
	      },
	      goLineEnd: function (cm) {
	        return cm.extendSelectionsBy(function (range) {
	          return lineEnd(cm, range.head.line);
	        }, {
	          origin: "+move",
	          bias: -1
	        });
	      },
	      goLineRight: function (cm) {
	        return cm.extendSelectionsBy(function (range) {
	          var top = cm.cursorCoords(range.head, "div").top + 5;
	          return cm.coordsChar({
	            left: cm.display.lineDiv.offsetWidth + 100,
	            top: top
	          }, "div");
	        }, sel_move);
	      },
	      goLineLeft: function (cm) {
	        return cm.extendSelectionsBy(function (range) {
	          var top = cm.cursorCoords(range.head, "div").top + 5;
	          return cm.coordsChar({
	            left: 0,
	            top: top
	          }, "div");
	        }, sel_move);
	      },
	      goLineLeftSmart: function (cm) {
	        return cm.extendSelectionsBy(function (range) {
	          var top = cm.cursorCoords(range.head, "div").top + 5;
	          var pos = cm.coordsChar({
	            left: 0,
	            top: top
	          }, "div");

	          if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
	            return lineStartSmart(cm, range.head);
	          }

	          return pos;
	        }, sel_move);
	      },
	      goLineUp: function (cm) {
	        return cm.moveV(-1, "line");
	      },
	      goLineDown: function (cm) {
	        return cm.moveV(1, "line");
	      },
	      goPageUp: function (cm) {
	        return cm.moveV(-1, "page");
	      },
	      goPageDown: function (cm) {
	        return cm.moveV(1, "page");
	      },
	      goCharLeft: function (cm) {
	        return cm.moveH(-1, "char");
	      },
	      goCharRight: function (cm) {
	        return cm.moveH(1, "char");
	      },
	      goColumnLeft: function (cm) {
	        return cm.moveH(-1, "column");
	      },
	      goColumnRight: function (cm) {
	        return cm.moveH(1, "column");
	      },
	      goWordLeft: function (cm) {
	        return cm.moveH(-1, "word");
	      },
	      goGroupRight: function (cm) {
	        return cm.moveH(1, "group");
	      },
	      goGroupLeft: function (cm) {
	        return cm.moveH(-1, "group");
	      },
	      goWordRight: function (cm) {
	        return cm.moveH(1, "word");
	      },
	      delCharBefore: function (cm) {
	        return cm.deleteH(-1, "codepoint");
	      },
	      delCharAfter: function (cm) {
	        return cm.deleteH(1, "char");
	      },
	      delWordBefore: function (cm) {
	        return cm.deleteH(-1, "word");
	      },
	      delWordAfter: function (cm) {
	        return cm.deleteH(1, "word");
	      },
	      delGroupBefore: function (cm) {
	        return cm.deleteH(-1, "group");
	      },
	      delGroupAfter: function (cm) {
	        return cm.deleteH(1, "group");
	      },
	      indentAuto: function (cm) {
	        return cm.indentSelection("smart");
	      },
	      indentMore: function (cm) {
	        return cm.indentSelection("add");
	      },
	      indentLess: function (cm) {
	        return cm.indentSelection("subtract");
	      },
	      insertTab: function (cm) {
	        return cm.replaceSelection("\t");
	      },
	      insertSoftTab: function (cm) {
	        var spaces = [],
	            ranges = cm.listSelections(),
	            tabSize = cm.options.tabSize;

	        for (var i = 0; i < ranges.length; i++) {
	          var pos = ranges[i].from();
	          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
	          spaces.push(spaceStr(tabSize - col % tabSize));
	        }

	        cm.replaceSelections(spaces);
	      },
	      defaultTab: function (cm) {
	        if (cm.somethingSelected()) {
	          cm.indentSelection("add");
	        } else {
	          cm.execCommand("insertTab");
	        }
	      },
	      // Swap the two chars left and right of each selection's head.
	      // Move cursor behind the two swapped characters afterwards.
	      //
	      // Doesn't consider line feeds a character.
	      // Doesn't scan more than one line above to find a character.
	      // Doesn't do anything on an empty line.
	      // Doesn't do anything with non-empty selections.
	      transposeChars: function (cm) {
	        return runInOp(cm, function () {
	          var ranges = cm.listSelections(),
	              newSel = [];

	          for (var i = 0; i < ranges.length; i++) {
	            if (!ranges[i].empty()) {
	              continue;
	            }

	            var cur = ranges[i].head,
	                line = getLine(cm.doc, cur.line).text;

	            if (line) {
	              if (cur.ch == line.length) {
	                cur = new Pos(cur.line, cur.ch - 1);
	              }

	              if (cur.ch > 0) {
	                cur = new Pos(cur.line, cur.ch + 1);
	                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
	              } else if (cur.line > cm.doc.first) {
	                var prev = getLine(cm.doc, cur.line - 1).text;

	                if (prev) {
	                  cur = new Pos(cur.line, 1);
	                  cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
	                }
	              }
	            }

	            newSel.push(new Range(cur, cur));
	          }

	          cm.setSelections(newSel);
	        });
	      },
	      newlineAndIndent: function (cm) {
	        return runInOp(cm, function () {
	          var sels = cm.listSelections();

	          for (var i = sels.length - 1; i >= 0; i--) {
	            cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
	          }

	          sels = cm.listSelections();

	          for (var i$1 = 0; i$1 < sels.length; i$1++) {
	            cm.indentLine(sels[i$1].from().line, null, true);
	          }

	          ensureCursorVisible(cm);
	        });
	      },
	      openLine: function (cm) {
	        return cm.replaceSelection("\n", "start");
	      },
	      toggleOverwrite: function (cm) {
	        return cm.toggleOverwrite();
	      }
	    };

	    function lineStart(cm, lineN) {
	      var line = getLine(cm.doc, lineN);
	      var visual = visualLine(line);

	      if (visual != line) {
	        lineN = lineNo(visual);
	      }

	      return endOfLine(true, cm, visual, lineN, 1);
	    }

	    function lineEnd(cm, lineN) {
	      var line = getLine(cm.doc, lineN);
	      var visual = visualLineEnd(line);

	      if (visual != line) {
	        lineN = lineNo(visual);
	      }

	      return endOfLine(true, cm, line, lineN, -1);
	    }

	    function lineStartSmart(cm, pos) {
	      var start = lineStart(cm, pos.line);
	      var line = getLine(cm.doc, start.line);
	      var order = getOrder(line, cm.doc.direction);

	      if (!order || order[0].level == 0) {
	        var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
	        var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
	        return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
	      }

	      return start;
	    } // Run a handler that was bound to a key.


	    function doHandleBinding(cm, bound, dropShift) {
	      if (typeof bound == "string") {
	        bound = commands[bound];

	        if (!bound) {
	          return false;
	        }
	      } // Ensure previous input has been read, so that the handler sees a
	      // consistent view of the document


	      cm.display.input.ensurePolled();
	      var prevShift = cm.display.shift,
	          done = false;

	      try {
	        if (cm.isReadOnly()) {
	          cm.state.suppressEdits = true;
	        }

	        if (dropShift) {
	          cm.display.shift = false;
	        }

	        done = bound(cm) != Pass;
	      } finally {
	        cm.display.shift = prevShift;
	        cm.state.suppressEdits = false;
	      }

	      return done;
	    }

	    function lookupKeyForEditor(cm, name, handle) {
	      for (var i = 0; i < cm.state.keyMaps.length; i++) {
	        var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);

	        if (result) {
	          return result;
	        }
	      }

	      return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
	    } // Note that, despite the name, this function is also used to check
	    // for bound mouse clicks.


	    var stopSeq = new Delayed();

	    function dispatchKey(cm, name, e, handle) {
	      var seq = cm.state.keySeq;

	      if (seq) {
	        if (isModifierKey(name)) {
	          return "handled";
	        }

	        if (/\'$/.test(name)) {
	          cm.state.keySeq = null;
	        } else {
	          stopSeq.set(50, function () {
	            if (cm.state.keySeq == seq) {
	              cm.state.keySeq = null;
	              cm.display.input.reset();
	            }
	          });
	        }

	        if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
	          return true;
	        }
	      }

	      return dispatchKeyInner(cm, name, e, handle);
	    }

	    function dispatchKeyInner(cm, name, e, handle) {
	      var result = lookupKeyForEditor(cm, name, handle);

	      if (result == "multi") {
	        cm.state.keySeq = name;
	      }

	      if (result == "handled") {
	        signalLater(cm, "keyHandled", cm, name, e);
	      }

	      if (result == "handled" || result == "multi") {
	        e_preventDefault(e);
	        restartBlink(cm);
	      }

	      return !!result;
	    } // Handle a key from the keydown event.


	    function handleKeyBinding(cm, e) {
	      var name = keyName(e, true);

	      if (!name) {
	        return false;
	      }

	      if (e.shiftKey && !cm.state.keySeq) {
	        // First try to resolve full name (including 'Shift-'). Failing
	        // that, see if there is a cursor-motion command (starting with
	        // 'go') bound to the keyname without 'Shift-'.
	        return dispatchKey(cm, "Shift-" + name, e, function (b) {
	          return doHandleBinding(cm, b, true);
	        }) || dispatchKey(cm, name, e, function (b) {
	          if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
	            return doHandleBinding(cm, b);
	          }
	        });
	      } else {
	        return dispatchKey(cm, name, e, function (b) {
	          return doHandleBinding(cm, b);
	        });
	      }
	    } // Handle a key from the keypress event


	    function handleCharBinding(cm, e, ch) {
	      return dispatchKey(cm, "'" + ch + "'", e, function (b) {
	        return doHandleBinding(cm, b, true);
	      });
	    }

	    var lastStoppedKey = null;

	    function onKeyDown(e) {
	      var cm = this;

	      if (e.target && e.target != cm.display.input.getField()) {
	        return;
	      }

	      cm.curOp.focus = activeElt();

	      if (signalDOMEvent(cm, e)) {
	        return;
	      } // IE does strange things with escape.


	      if (ie && ie_version < 11 && e.keyCode == 27) {
	        e.returnValue = false;
	      }

	      var code = e.keyCode;
	      cm.display.shift = code == 16 || e.shiftKey;
	      var handled = handleKeyBinding(cm, e);

	      if (presto) {
	        lastStoppedKey = handled ? code : null; // Opera has no cut event... we try to at least catch the key combo

	        if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
	          cm.replaceSelection("", null, "cut");
	        }
	      }

	      if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
	        document.execCommand("cut");
	      } // Turn mouse into crosshair when Alt is held on Mac.


	      if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
	        showCrossHair(cm);
	      }
	    }

	    function showCrossHair(cm) {
	      var lineDiv = cm.display.lineDiv;
	      addClass(lineDiv, "CodeMirror-crosshair");

	      function up(e) {
	        if (e.keyCode == 18 || !e.altKey) {
	          rmClass(lineDiv, "CodeMirror-crosshair");
	          off(document, "keyup", up);
	          off(document, "mouseover", up);
	        }
	      }

	      on(document, "keyup", up);
	      on(document, "mouseover", up);
	    }

	    function onKeyUp(e) {
	      if (e.keyCode == 16) {
	        this.doc.sel.shift = false;
	      }

	      signalDOMEvent(this, e);
	    }

	    function onKeyPress(e) {
	      var cm = this;

	      if (e.target && e.target != cm.display.input.getField()) {
	        return;
	      }

	      if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
	        return;
	      }

	      var keyCode = e.keyCode,
	          charCode = e.charCode;

	      if (presto && keyCode == lastStoppedKey) {
	        lastStoppedKey = null;
	        e_preventDefault(e);
	        return;
	      }

	      if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
	        return;
	      }

	      var ch = String.fromCharCode(charCode == null ? keyCode : charCode); // Some browsers fire keypress events for backspace

	      if (ch == "\x08") {
	        return;
	      }

	      if (handleCharBinding(cm, e, ch)) {
	        return;
	      }

	      cm.display.input.onKeyPress(e);
	    }

	    var DOUBLECLICK_DELAY = 400;

	    var PastClick = function (time, pos, button) {
	      this.time = time;
	      this.pos = pos;
	      this.button = button;
	    };

	    PastClick.prototype.compare = function (time, pos, button) {
	      return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
	    };

	    var lastClick, lastDoubleClick;

	    function clickRepeat(pos, button) {
	      var now = +new Date();

	      if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
	        lastClick = lastDoubleClick = null;
	        return "triple";
	      } else if (lastClick && lastClick.compare(now, pos, button)) {
	        lastDoubleClick = new PastClick(now, pos, button);
	        lastClick = null;
	        return "double";
	      } else {
	        lastClick = new PastClick(now, pos, button);
	        lastDoubleClick = null;
	        return "single";
	      }
	    } // A mouse down can be a single click, double click, triple click,
	    // start of selection drag, start of text drag, new cursor
	    // (ctrl-click), rectangle drag (alt-drag), or xwin
	    // middle-click-paste. Or it might be a click on something we should
	    // not interfere with, such as a scrollbar or widget.


	    function onMouseDown(e) {
	      var cm = this,
	          display = cm.display;

	      if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
	        return;
	      }

	      display.input.ensurePolled();
	      display.shift = e.shiftKey;

	      if (eventInWidget(display, e)) {
	        if (!webkit) {
	          // Briefly turn off draggability, to allow widgets to do
	          // normal dragging things.
	          display.scroller.draggable = false;
	          setTimeout(function () {
	            return display.scroller.draggable = true;
	          }, 100);
	        }

	        return;
	      }

	      if (clickInGutter(cm, e)) {
	        return;
	      }

	      var pos = posFromMouse(cm, e),
	          button = e_button(e),
	          repeat = pos ? clickRepeat(pos, button) : "single";
	      window.focus(); // #3261: make sure, that we're not starting a second selection

	      if (button == 1 && cm.state.selectingText) {
	        cm.state.selectingText(e);
	      }

	      if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
	        return;
	      }

	      if (button == 1) {
	        if (pos) {
	          leftButtonDown(cm, pos, repeat, e);
	        } else if (e_target(e) == display.scroller) {
	          e_preventDefault(e);
	        }
	      } else if (button == 2) {
	        if (pos) {
	          extendSelection(cm.doc, pos);
	        }

	        setTimeout(function () {
	          return display.input.focus();
	        }, 20);
	      } else if (button == 3) {
	        if (captureRightClick) {
	          cm.display.input.onContextMenu(e);
	        } else {
	          delayBlurEvent(cm);
	        }
	      }
	    }

	    function handleMappedButton(cm, button, pos, repeat, event) {
	      var name = "Click";

	      if (repeat == "double") {
	        name = "Double" + name;
	      } else if (repeat == "triple") {
	        name = "Triple" + name;
	      }

	      name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
	      return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {
	        if (typeof bound == "string") {
	          bound = commands[bound];
	        }

	        if (!bound) {
	          return false;
	        }

	        var done = false;

	        try {
	          if (cm.isReadOnly()) {
	            cm.state.suppressEdits = true;
	          }

	          done = bound(cm, pos) != Pass;
	        } finally {
	          cm.state.suppressEdits = false;
	        }

	        return done;
	      });
	    }

	    function configureMouse(cm, repeat, event) {
	      var option = cm.getOption("configureMouse");
	      var value = option ? option(cm, repeat, event) : {};

	      if (value.unit == null) {
	        var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
	        value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
	      }

	      if (value.extend == null || cm.doc.extend) {
	        value.extend = cm.doc.extend || event.shiftKey;
	      }

	      if (value.addNew == null) {
	        value.addNew = mac ? event.metaKey : event.ctrlKey;
	      }

	      if (value.moveOnDrag == null) {
	        value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
	      }

	      return value;
	    }

	    function leftButtonDown(cm, pos, repeat, event) {
	      if (ie) {
	        setTimeout(bind(ensureFocus, cm), 0);
	      } else {
	        cm.curOp.focus = activeElt();
	      }

	      var behavior = configureMouse(cm, repeat, event);
	      var sel = cm.doc.sel,
	          contained;

	      if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
	        leftButtonStartDrag(cm, event, pos, behavior);
	      } else {
	        leftButtonSelect(cm, event, pos, behavior);
	      }
	    } // Start a text drag. When it ends, see if any dragging actually
	    // happen, and treat as a click if it didn't.


	    function leftButtonStartDrag(cm, event, pos, behavior) {
	      var display = cm.display,
	          moved = false;
	      var dragEnd = operation(cm, function (e) {
	        if (webkit) {
	          display.scroller.draggable = false;
	        }

	        cm.state.draggingText = false;

	        if (cm.state.delayingBlurEvent) {
	          if (cm.hasFocus()) {
	            cm.state.delayingBlurEvent = false;
	          } else {
	            delayBlurEvent(cm);
	          }
	        }

	        off(display.wrapper.ownerDocument, "mouseup", dragEnd);
	        off(display.wrapper.ownerDocument, "mousemove", mouseMove);
	        off(display.scroller, "dragstart", dragStart);
	        off(display.scroller, "drop", dragEnd);

	        if (!moved) {
	          e_preventDefault(e);

	          if (!behavior.addNew) {
	            extendSelection(cm.doc, pos, null, null, behavior.extend);
	          } // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)


	          if (webkit && !safari || ie && ie_version == 9) {
	            setTimeout(function () {
	              display.wrapper.ownerDocument.body.focus({
	                preventScroll: true
	              });
	              display.input.focus();
	            }, 20);
	          } else {
	            display.input.focus();
	          }
	        }
	      });

	      var mouseMove = function (e2) {
	        moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
	      };

	      var dragStart = function () {
	        return moved = true;
	      }; // Let the drag handler handle this.


	      if (webkit) {
	        display.scroller.draggable = true;
	      }

	      cm.state.draggingText = dragEnd;
	      dragEnd.copy = !behavior.moveOnDrag;
	      on(display.wrapper.ownerDocument, "mouseup", dragEnd);
	      on(display.wrapper.ownerDocument, "mousemove", mouseMove);
	      on(display.scroller, "dragstart", dragStart);
	      on(display.scroller, "drop", dragEnd);
	      cm.state.delayingBlurEvent = true;
	      setTimeout(function () {
	        return display.input.focus();
	      }, 20); // IE's approach to draggable

	      if (display.scroller.dragDrop) {
	        display.scroller.dragDrop();
	      }
	    }

	    function rangeForUnit(cm, pos, unit) {
	      if (unit == "char") {
	        return new Range(pos, pos);
	      }

	      if (unit == "word") {
	        return cm.findWordAt(pos);
	      }

	      if (unit == "line") {
	        return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
	      }

	      var result = unit(cm, pos);
	      return new Range(result.from, result.to);
	    } // Normal selection, as opposed to text dragging.


	    function leftButtonSelect(cm, event, start, behavior) {
	      if (ie) {
	        delayBlurEvent(cm);
	      }

	      var display = cm.display,
	          doc = cm.doc;
	      e_preventDefault(event);
	      var ourRange,
	          ourIndex,
	          startSel = doc.sel,
	          ranges = startSel.ranges;

	      if (behavior.addNew && !behavior.extend) {
	        ourIndex = doc.sel.contains(start);

	        if (ourIndex > -1) {
	          ourRange = ranges[ourIndex];
	        } else {
	          ourRange = new Range(start, start);
	        }
	      } else {
	        ourRange = doc.sel.primary();
	        ourIndex = doc.sel.primIndex;
	      }

	      if (behavior.unit == "rectangle") {
	        if (!behavior.addNew) {
	          ourRange = new Range(start, start);
	        }

	        start = posFromMouse(cm, event, true, true);
	        ourIndex = -1;
	      } else {
	        var range = rangeForUnit(cm, start, behavior.unit);

	        if (behavior.extend) {
	          ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend);
	        } else {
	          ourRange = range;
	        }
	      }

	      if (!behavior.addNew) {
	        ourIndex = 0;
	        setSelection(doc, new Selection([ourRange], 0), sel_mouse);
	        startSel = doc.sel;
	      } else if (ourIndex == -1) {
	        ourIndex = ranges.length;
	        setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), {
	          scroll: false,
	          origin: "*mouse"
	        });
	      } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
	        setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
	          scroll: false,
	          origin: "*mouse"
	        });
	        startSel = doc.sel;
	      } else {
	        replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
	      }

	      var lastPos = start;

	      function extendTo(pos) {
	        if (cmp(lastPos, pos) == 0) {
	          return;
	        }

	        lastPos = pos;

	        if (behavior.unit == "rectangle") {
	          var ranges = [],
	              tabSize = cm.options.tabSize;
	          var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
	          var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
	          var left = Math.min(startCol, posCol),
	              right = Math.max(startCol, posCol);

	          for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
	            var text = getLine(doc, line).text,
	                leftPos = findColumn(text, left, tabSize);

	            if (left == right) {
	              ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
	            } else if (text.length > leftPos) {
	              ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
	            }
	          }

	          if (!ranges.length) {
	            ranges.push(new Range(start, start));
	          }

	          setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
	            origin: "*mouse",
	            scroll: false
	          });
	          cm.scrollIntoView(pos);
	        } else {
	          var oldRange = ourRange;
	          var range = rangeForUnit(cm, pos, behavior.unit);
	          var anchor = oldRange.anchor,
	              head;

	          if (cmp(range.anchor, anchor) > 0) {
	            head = range.head;
	            anchor = minPos(oldRange.from(), range.anchor);
	          } else {
	            head = range.anchor;
	            anchor = maxPos(oldRange.to(), range.head);
	          }

	          var ranges$1 = startSel.ranges.slice(0);
	          ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
	          setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
	        }
	      }

	      var editorSize = display.wrapper.getBoundingClientRect(); // Used to ensure timeout re-tries don't fire when another extend
	      // happened in the meantime (clearTimeout isn't reliable -- at
	      // least on Chrome, the timeouts still happen even when cleared,
	      // if the clear happens after their scheduled firing time).

	      var counter = 0;

	      function extend(e) {
	        var curCount = ++counter;
	        var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");

	        if (!cur) {
	          return;
	        }

	        if (cmp(cur, lastPos) != 0) {
	          cm.curOp.focus = activeElt();
	          extendTo(cur);
	          var visible = visibleLines(display, doc);

	          if (cur.line >= visible.to || cur.line < visible.from) {
	            setTimeout(operation(cm, function () {
	              if (counter == curCount) {
	                extend(e);
	              }
	            }), 150);
	          }
	        } else {
	          var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;

	          if (outside) {
	            setTimeout(operation(cm, function () {
	              if (counter != curCount) {
	                return;
	              }

	              display.scroller.scrollTop += outside;
	              extend(e);
	            }), 50);
	          }
	        }
	      }

	      function done(e) {
	        cm.state.selectingText = false;
	        counter = Infinity; // If e is null or undefined we interpret this as someone trying
	        // to explicitly cancel the selection rather than the user
	        // letting go of the mouse button.

	        if (e) {
	          e_preventDefault(e);
	          display.input.focus();
	        }

	        off(display.wrapper.ownerDocument, "mousemove", move);
	        off(display.wrapper.ownerDocument, "mouseup", up);
	        doc.history.lastSelOrigin = null;
	      }

	      var move = operation(cm, function (e) {
	        if (e.buttons === 0 || !e_button(e)) {
	          done(e);
	        } else {
	          extend(e);
	        }
	      });
	      var up = operation(cm, done);
	      cm.state.selectingText = up;
	      on(display.wrapper.ownerDocument, "mousemove", move);
	      on(display.wrapper.ownerDocument, "mouseup", up);
	    } // Used when mouse-selecting to adjust the anchor to the proper side
	    // of a bidi jump depending on the visual position of the head.


	    function bidiSimplify(cm, range) {
	      var anchor = range.anchor;
	      var head = range.head;
	      var anchorLine = getLine(cm.doc, anchor.line);

	      if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
	        return range;
	      }

	      var order = getOrder(anchorLine);

	      if (!order) {
	        return range;
	      }

	      var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
	          part = order[index];

	      if (part.from != anchor.ch && part.to != anchor.ch) {
	        return range;
	      }

	      var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);

	      if (boundary == 0 || boundary == order.length) {
	        return range;
	      } // Compute the relative visual position of the head compared to the
	      // anchor (<0 is to the left, >0 to the right)


	      var leftSide;

	      if (head.line != anchor.line) {
	        leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
	      } else {
	        var headIndex = getBidiPartAt(order, head.ch, head.sticky);
	        var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);

	        if (headIndex == boundary - 1 || headIndex == boundary) {
	          leftSide = dir < 0;
	        } else {
	          leftSide = dir > 0;
	        }
	      }

	      var usePart = order[boundary + (leftSide ? -1 : 0)];
	      var from = leftSide == (usePart.level == 1);
	      var ch = from ? usePart.from : usePart.to,
	          sticky = from ? "after" : "before";
	      return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head);
	    } // Determines whether an event happened in the gutter, and fires the
	    // handlers for the corresponding event.


	    function gutterEvent(cm, e, type, prevent) {
	      var mX, mY;

	      if (e.touches) {
	        mX = e.touches[0].clientX;
	        mY = e.touches[0].clientY;
	      } else {
	        try {
	          mX = e.clientX;
	          mY = e.clientY;
	        } catch (e$1) {
	          return false;
	        }
	      }

	      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
	        return false;
	      }

	      if (prevent) {
	        e_preventDefault(e);
	      }

	      var display = cm.display;
	      var lineBox = display.lineDiv.getBoundingClientRect();

	      if (mY > lineBox.bottom || !hasHandler(cm, type)) {
	        return e_defaultPrevented(e);
	      }

	      mY -= lineBox.top - display.viewOffset;

	      for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
	        var g = display.gutters.childNodes[i];

	        if (g && g.getBoundingClientRect().right >= mX) {
	          var line = lineAtHeight(cm.doc, mY);
	          var gutter = cm.display.gutterSpecs[i];
	          signal(cm, type, cm, line, gutter.className, e);
	          return e_defaultPrevented(e);
	        }
	      }
	    }

	    function clickInGutter(cm, e) {
	      return gutterEvent(cm, e, "gutterClick", true);
	    } // CONTEXT MENU HANDLING
	    // To make the context menu work, we need to briefly unhide the
	    // textarea (making it as unobtrusive as possible) to let the
	    // right-click take effect on it.


	    function onContextMenu(cm, e) {
	      if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
	        return;
	      }

	      if (signalDOMEvent(cm, e, "contextmenu")) {
	        return;
	      }

	      if (!captureRightClick) {
	        cm.display.input.onContextMenu(e);
	      }
	    }

	    function contextMenuInGutter(cm, e) {
	      if (!hasHandler(cm, "gutterContextMenu")) {
	        return false;
	      }

	      return gutterEvent(cm, e, "gutterContextMenu", false);
	    }

	    function themeChanged(cm) {
	      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
	      clearCaches(cm);
	    }

	    var Init = {
	      toString: function () {
	        return "CodeMirror.Init";
	      }
	    };
	    var defaults = {};
	    var optionHandlers = {};

	    function defineOptions(CodeMirror) {
	      var optionHandlers = CodeMirror.optionHandlers;

	      function option(name, deflt, handle, notOnInit) {
	        CodeMirror.defaults[name] = deflt;

	        if (handle) {
	          optionHandlers[name] = notOnInit ? function (cm, val, old) {
	            if (old != Init) {
	              handle(cm, val, old);
	            }
	          } : handle;
	        }
	      }

	      CodeMirror.defineOption = option; // Passed to option handlers when there is no old value.

	      CodeMirror.Init = Init; // These two are, on init, called from the constructor because they
	      // have to be initialized before the editor can start at all.

	      option("value", "", function (cm, val) {
	        return cm.setValue(val);
	      }, true);
	      option("mode", null, function (cm, val) {
	        cm.doc.modeOption = val;
	        loadMode(cm);
	      }, true);
	      option("indentUnit", 2, loadMode, true);
	      option("indentWithTabs", false);
	      option("smartIndent", true);
	      option("tabSize", 4, function (cm) {
	        resetModeState(cm);
	        clearCaches(cm);
	        regChange(cm);
	      }, true);
	      option("lineSeparator", null, function (cm, val) {
	        cm.doc.lineSep = val;

	        if (!val) {
	          return;
	        }

	        var newBreaks = [],
	            lineNo = cm.doc.first;
	        cm.doc.iter(function (line) {
	          for (var pos = 0;;) {
	            var found = line.text.indexOf(val, pos);

	            if (found == -1) {
	              break;
	            }

	            pos = found + val.length;
	            newBreaks.push(Pos(lineNo, found));
	          }

	          lineNo++;
	        });

	        for (var i = newBreaks.length - 1; i >= 0; i--) {
	          replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
	        }
	      });
	      option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200c\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
	        cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");

	        if (old != Init) {
	          cm.refresh();
	        }
	      });
	      option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
	        return cm.refresh();
	      }, true);
	      option("electricChars", true);
	      option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
	        throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
	      }, true);
	      option("spellcheck", false, function (cm, val) {
	        return cm.getInputField().spellcheck = val;
	      }, true);
	      option("autocorrect", false, function (cm, val) {
	        return cm.getInputField().autocorrect = val;
	      }, true);
	      option("autocapitalize", false, function (cm, val) {
	        return cm.getInputField().autocapitalize = val;
	      }, true);
	      option("rtlMoveVisually", !windows);
	      option("wholeLineUpdateBefore", true);
	      option("theme", "default", function (cm) {
	        themeChanged(cm);
	        updateGutters(cm);
	      }, true);
	      option("keyMap", "default", function (cm, val, old) {
	        var next = getKeyMap(val);
	        var prev = old != Init && getKeyMap(old);

	        if (prev && prev.detach) {
	          prev.detach(cm, next);
	        }

	        if (next.attach) {
	          next.attach(cm, prev || null);
	        }
	      });
	      option("extraKeys", null);
	      option("configureMouse", null);
	      option("lineWrapping", false, wrappingChanged, true);
	      option("gutters", [], function (cm, val) {
	        cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
	        updateGutters(cm);
	      }, true);
	      option("fixedGutter", true, function (cm, val) {
	        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
	        cm.refresh();
	      }, true);
	      option("coverGutterNextToScrollbar", false, function (cm) {
	        return updateScrollbars(cm);
	      }, true);
	      option("scrollbarStyle", "native", function (cm) {
	        initScrollbars(cm);
	        updateScrollbars(cm);
	        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
	        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
	      }, true);
	      option("lineNumbers", false, function (cm, val) {
	        cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
	        updateGutters(cm);
	      }, true);
	      option("firstLineNumber", 1, updateGutters, true);
	      option("lineNumberFormatter", function (integer) {
	        return integer;
	      }, updateGutters, true);
	      option("showCursorWhenSelecting", false, updateSelection, true);
	      option("resetSelectionOnContextMenu", true);
	      option("lineWiseCopyCut", true);
	      option("pasteLinesPerSelection", true);
	      option("selectionsMayTouch", false);
	      option("readOnly", false, function (cm, val) {
	        if (val == "nocursor") {
	          onBlur(cm);
	          cm.display.input.blur();
	        }

	        cm.display.input.readOnlyChanged(val);
	      });
	      option("screenReaderLabel", null, function (cm, val) {
	        val = val === '' ? null : val;
	        cm.display.input.screenReaderLabelChanged(val);
	      });
	      option("disableInput", false, function (cm, val) {
	        if (!val) {
	          cm.display.input.reset();
	        }
	      }, true);
	      option("dragDrop", true, dragDropChanged);
	      option("allowDropFileTypes", null);
	      option("cursorBlinkRate", 530);
	      option("cursorScrollMargin", 0);
	      option("cursorHeight", 1, updateSelection, true);
	      option("singleCursorHeightPerLine", true, updateSelection, true);
	      option("workTime", 100);
	      option("workDelay", 100);
	      option("flattenSpans", true, resetModeState, true);
	      option("addModeClass", false, resetModeState, true);
	      option("pollInterval", 100);
	      option("undoDepth", 200, function (cm, val) {
	        return cm.doc.history.undoDepth = val;
	      });
	      option("historyEventDelay", 1250);
	      option("viewportMargin", 10, function (cm) {
	        return cm.refresh();
	      }, true);
	      option("maxHighlightLength", 10000, resetModeState, true);
	      option("moveInputWithCursor", true, function (cm, val) {
	        if (!val) {
	          cm.display.input.resetPosition();
	        }
	      });
	      option("tabindex", null, function (cm, val) {
	        return cm.display.input.getField().tabIndex = val || "";
	      });
	      option("autofocus", null);
	      option("direction", "ltr", function (cm, val) {
	        return cm.doc.setDirection(val);
	      }, true);
	      option("phrases", null);
	    }

	    function dragDropChanged(cm, value, old) {
	      var wasOn = old && old != Init;

	      if (!value != !wasOn) {
	        var funcs = cm.display.dragFunctions;
	        var toggle = value ? on : off;
	        toggle(cm.display.scroller, "dragstart", funcs.start);
	        toggle(cm.display.scroller, "dragenter", funcs.enter);
	        toggle(cm.display.scroller, "dragover", funcs.over);
	        toggle(cm.display.scroller, "dragleave", funcs.leave);
	        toggle(cm.display.scroller, "drop", funcs.drop);
	      }
	    }

	    function wrappingChanged(cm) {
	      if (cm.options.lineWrapping) {
	        addClass(cm.display.wrapper, "CodeMirror-wrap");
	        cm.display.sizer.style.minWidth = "";
	        cm.display.sizerWidth = null;
	      } else {
	        rmClass(cm.display.wrapper, "CodeMirror-wrap");
	        findMaxLine(cm);
	      }

	      estimateLineHeights(cm);
	      regChange(cm);
	      clearCaches(cm);
	      setTimeout(function () {
	        return updateScrollbars(cm);
	      }, 100);
	    } // A CodeMirror instance represents an editor. This is the object
	    // that user code is usually dealing with.


	    function CodeMirror(place, options) {
	      var this$1 = this;

	      if (!(this instanceof CodeMirror)) {
	        return new CodeMirror(place, options);
	      }

	      this.options = options = options ? copyObj(options) : {}; // Determine effective options based on given values and defaults.

	      copyObj(defaults, options, false);
	      var doc = options.value;

	      if (typeof doc == "string") {
	        doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
	      } else if (options.mode) {
	        doc.modeOption = options.mode;
	      }

	      this.doc = doc;
	      var input = new CodeMirror.inputStyles[options.inputStyle](this);
	      var display = this.display = new Display(place, doc, input, options);
	      display.wrapper.CodeMirror = this;
	      themeChanged(this);

	      if (options.lineWrapping) {
	        this.display.wrapper.className += " CodeMirror-wrap";
	      }

	      initScrollbars(this);
	      this.state = {
	        keyMaps: [],
	        // stores maps added by addKeyMap
	        overlays: [],
	        // highlighting overlays, as added by addOverlay
	        modeGen: 0,
	        // bumped when mode/overlay changes, used to invalidate highlighting info
	        overwrite: false,
	        delayingBlurEvent: false,
	        focused: false,
	        suppressEdits: false,
	        // used to disable editing during key handlers when in readOnly mode
	        pasteIncoming: -1,
	        cutIncoming: -1,
	        // help recognize paste/cut edits in input.poll
	        selectingText: false,
	        draggingText: false,
	        highlight: new Delayed(),
	        // stores highlight worker timeout
	        keySeq: null,
	        // Unfinished key sequence
	        specialChars: null
	      };

	      if (options.autofocus && !mobile) {
	        display.input.focus();
	      } // Override magic textarea content restore that IE sometimes does
	      // on our hidden textarea on reload


	      if (ie && ie_version < 11) {
	        setTimeout(function () {
	          return this$1.display.input.reset(true);
	        }, 20);
	      }

	      registerEventHandlers(this);
	      ensureGlobalHandlers();
	      startOperation(this);
	      this.curOp.forceUpdate = true;
	      attachDoc(this, doc);

	      if (options.autofocus && !mobile || this.hasFocus()) {
	        setTimeout(function () {
	          if (this$1.hasFocus() && !this$1.state.focused) {
	            onFocus(this$1);
	          }
	        }, 20);
	      } else {
	        onBlur(this);
	      }

	      for (var opt in optionHandlers) {
	        if (optionHandlers.hasOwnProperty(opt)) {
	          optionHandlers[opt](this, options[opt], Init);
	        }
	      }

	      maybeUpdateLineNumberWidth(this);

	      if (options.finishInit) {
	        options.finishInit(this);
	      }

	      for (var i = 0; i < initHooks.length; ++i) {
	        initHooks[i](this);
	      }

	      endOperation(this); // Suppress optimizelegibility in Webkit, since it breaks text
	      // measuring on line wrapping boundaries.

	      if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
	        display.lineDiv.style.textRendering = "auto";
	      }
	    } // The default configuration options.


	    CodeMirror.defaults = defaults; // Functions to run when options are changed.

	    CodeMirror.optionHandlers = optionHandlers; // Attach the necessary event handlers when initializing the editor

	    function registerEventHandlers(cm) {
	      var d = cm.display;
	      on(d.scroller, "mousedown", operation(cm, onMouseDown)); // Older IE's will not fire a second mousedown for a double click

	      if (ie && ie_version < 11) {
	        on(d.scroller, "dblclick", operation(cm, function (e) {
	          if (signalDOMEvent(cm, e)) {
	            return;
	          }

	          var pos = posFromMouse(cm, e);

	          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
	            return;
	          }

	          e_preventDefault(e);
	          var word = cm.findWordAt(pos);
	          extendSelection(cm.doc, word.anchor, word.head);
	        }));
	      } else {
	        on(d.scroller, "dblclick", function (e) {
	          return signalDOMEvent(cm, e) || e_preventDefault(e);
	        });
	      } // Some browsers fire contextmenu *after* opening the menu, at
	      // which point we can't mess with it anymore. Context menu is
	      // handled in onMouseDown for these browsers.


	      on(d.scroller, "contextmenu", function (e) {
	        return onContextMenu(cm, e);
	      });
	      on(d.input.getField(), "contextmenu", function (e) {
	        if (!d.scroller.contains(e.target)) {
	          onContextMenu(cm, e);
	        }
	      }); // Used to suppress mouse event handling when a touch happens

	      var touchFinished,
	          prevTouch = {
	        end: 0
	      };

	      function finishTouch() {
	        if (d.activeTouch) {
	          touchFinished = setTimeout(function () {
	            return d.activeTouch = null;
	          }, 1000);
	          prevTouch = d.activeTouch;
	          prevTouch.end = +new Date();
	        }
	      }

	      function isMouseLikeTouchEvent(e) {
	        if (e.touches.length != 1) {
	          return false;
	        }

	        var touch = e.touches[0];
	        return touch.radiusX <= 1 && touch.radiusY <= 1;
	      }

	      function farAway(touch, other) {
	        if (other.left == null) {
	          return true;
	        }

	        var dx = other.left - touch.left,
	            dy = other.top - touch.top;
	        return dx * dx + dy * dy > 20 * 20;
	      }

	      on(d.scroller, "touchstart", function (e) {
	        if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
	          d.input.ensurePolled();
	          clearTimeout(touchFinished);
	          var now = +new Date();
	          d.activeTouch = {
	            start: now,
	            moved: false,
	            prev: now - prevTouch.end <= 300 ? prevTouch : null
	          };

	          if (e.touches.length == 1) {
	            d.activeTouch.left = e.touches[0].pageX;
	            d.activeTouch.top = e.touches[0].pageY;
	          }
	        }
	      });
	      on(d.scroller, "touchmove", function () {
	        if (d.activeTouch) {
	          d.activeTouch.moved = true;
	        }
	      });
	      on(d.scroller, "touchend", function (e) {
	        var touch = d.activeTouch;

	        if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
	          var pos = cm.coordsChar(d.activeTouch, "page"),
	              range;

	          if (!touch.prev || farAway(touch, touch.prev)) // Single tap
	            {
	              range = new Range(pos, pos);
	            } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
	            {
	              range = cm.findWordAt(pos);
	            } else // Triple tap
	            {
	              range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
	            }

	          cm.setSelection(range.anchor, range.head);
	          cm.focus();
	          e_preventDefault(e);
	        }

	        finishTouch();
	      });
	      on(d.scroller, "touchcancel", finishTouch); // Sync scrolling between fake scrollbars and real scrollable
	      // area, ensure viewport is updated when scrolling.

	      on(d.scroller, "scroll", function () {
	        if (d.scroller.clientHeight) {
	          updateScrollTop(cm, d.scroller.scrollTop);
	          setScrollLeft(cm, d.scroller.scrollLeft, true);
	          signal(cm, "scroll", cm);
	        }
	      }); // Listen to wheel events in order to try and update the viewport on time.

	      on(d.scroller, "mousewheel", function (e) {
	        return onScrollWheel(cm, e);
	      });
	      on(d.scroller, "DOMMouseScroll", function (e) {
	        return onScrollWheel(cm, e);
	      }); // Prevent wrapper from ever scrolling

	      on(d.wrapper, "scroll", function () {
	        return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
	      });
	      d.dragFunctions = {
	        enter: function (e) {
	          if (!signalDOMEvent(cm, e)) {
	            e_stop(e);
	          }
	        },
	        over: function (e) {
	          if (!signalDOMEvent(cm, e)) {
	            onDragOver(cm, e);
	            e_stop(e);
	          }
	        },
	        start: function (e) {
	          return onDragStart(cm, e);
	        },
	        drop: operation(cm, onDrop),
	        leave: function (e) {
	          if (!signalDOMEvent(cm, e)) {
	            clearDragCursor(cm);
	          }
	        }
	      };
	      var inp = d.input.getField();
	      on(inp, "keyup", function (e) {
	        return onKeyUp.call(cm, e);
	      });
	      on(inp, "keydown", operation(cm, onKeyDown));
	      on(inp, "keypress", operation(cm, onKeyPress));
	      on(inp, "focus", function (e) {
	        return onFocus(cm, e);
	      });
	      on(inp, "blur", function (e) {
	        return onBlur(cm, e);
	      });
	    }

	    var initHooks = [];

	    CodeMirror.defineInitHook = function (f) {
	      return initHooks.push(f);
	    }; // Indent the given line. The how parameter can be "smart",
	    // "add"/null, "subtract", or "prev". When aggressive is false
	    // (typically set to true for forced single-line indents), empty
	    // lines are not indented, and places where the mode returns Pass
	    // are left alone.


	    function indentLine(cm, n, how, aggressive) {
	      var doc = cm.doc,
	          state;

	      if (how == null) {
	        how = "add";
	      }

	      if (how == "smart") {
	        // Fall back to "prev" when the mode doesn't have an indentation
	        // method.
	        if (!doc.mode.indent) {
	          how = "prev";
	        } else {
	          state = getContextBefore(cm, n).state;
	        }
	      }

	      var tabSize = cm.options.tabSize;
	      var line = getLine(doc, n),
	          curSpace = countColumn(line.text, null, tabSize);

	      if (line.stateAfter) {
	        line.stateAfter = null;
	      }

	      var curSpaceString = line.text.match(/^\s*/)[0],
	          indentation;

	      if (!aggressive && !/\S/.test(line.text)) {
	        indentation = 0;
	        how = "not";
	      } else if (how == "smart") {
	        indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);

	        if (indentation == Pass || indentation > 150) {
	          if (!aggressive) {
	            return;
	          }

	          how = "prev";
	        }
	      }

	      if (how == "prev") {
	        if (n > doc.first) {
	          indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
	        } else {
	          indentation = 0;
	        }
	      } else if (how == "add") {
	        indentation = curSpace + cm.options.indentUnit;
	      } else if (how == "subtract") {
	        indentation = curSpace - cm.options.indentUnit;
	      } else if (typeof how == "number") {
	        indentation = curSpace + how;
	      }

	      indentation = Math.max(0, indentation);
	      var indentString = "",
	          pos = 0;

	      if (cm.options.indentWithTabs) {
	        for (var i = Math.floor(indentation / tabSize); i; --i) {
	          pos += tabSize;
	          indentString += "\t";
	        }
	      }

	      if (pos < indentation) {
	        indentString += spaceStr(indentation - pos);
	      }

	      if (indentString != curSpaceString) {
	        replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
	        line.stateAfter = null;
	        return true;
	      } else {
	        // Ensure that, if the cursor was in the whitespace at the start
	        // of the line, it is moved to the end of that space.
	        for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
	          var range = doc.sel.ranges[i$1];

	          if (range.head.line == n && range.head.ch < curSpaceString.length) {
	            var pos$1 = Pos(n, curSpaceString.length);
	            replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
	            break;
	          }
	        }
	      }
	    } // This will be set to a {lineWise: bool, text: [string]} object, so
	    // that, when pasting, we know what kind of selections the copied
	    // text was made out of.


	    var lastCopied = null;

	    function setLastCopied(newLastCopied) {
	      lastCopied = newLastCopied;
	    }

	    function applyTextInput(cm, inserted, deleted, sel, origin) {
	      var doc = cm.doc;
	      cm.display.shift = false;

	      if (!sel) {
	        sel = doc.sel;
	      }

	      var recent = +new Date() - 200;
	      var paste = origin == "paste" || cm.state.pasteIncoming > recent;
	      var textLines = splitLinesAuto(inserted),
	          multiPaste = null; // When pasting N lines into N selections, insert one line per selection

	      if (paste && sel.ranges.length > 1) {
	        if (lastCopied && lastCopied.text.join("\n") == inserted) {
	          if (sel.ranges.length % lastCopied.text.length == 0) {
	            multiPaste = [];

	            for (var i = 0; i < lastCopied.text.length; i++) {
	              multiPaste.push(doc.splitLines(lastCopied.text[i]));
	            }
	          }
	        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
	          multiPaste = map(textLines, function (l) {
	            return [l];
	          });
	        }
	      }

	      var updateInput = cm.curOp.updateInput; // Normal behavior is to insert the new text into every selection

	      for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
	        var range = sel.ranges[i$1];
	        var from = range.from(),
	            to = range.to();

	        if (range.empty()) {
	          if (deleted && deleted > 0) // Handle deletion
	            {
	              from = Pos(from.line, from.ch - deleted);
	            } else if (cm.state.overwrite && !paste) // Handle overwrite
	            {
	              to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
	            } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
	            from = to = Pos(from.line, 0);
	          }
	        }

	        var changeEvent = {
	          from: from,
	          to: to,
	          text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
	          origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
	        };
	        makeChange(cm.doc, changeEvent);
	        signalLater(cm, "inputRead", cm, changeEvent);
	      }

	      if (inserted && !paste) {
	        triggerElectric(cm, inserted);
	      }

	      ensureCursorVisible(cm);

	      if (cm.curOp.updateInput < 2) {
	        cm.curOp.updateInput = updateInput;
	      }

	      cm.curOp.typing = true;
	      cm.state.pasteIncoming = cm.state.cutIncoming = -1;
	    }

	    function handlePaste(e, cm) {
	      var pasted = e.clipboardData && e.clipboardData.getData("Text");

	      if (pasted) {
	        e.preventDefault();

	        if (!cm.isReadOnly() && !cm.options.disableInput) {
	          runInOp(cm, function () {
	            return applyTextInput(cm, pasted, 0, null, "paste");
	          });
	        }

	        return true;
	      }
	    }

	    function triggerElectric(cm, inserted) {
	      // When an 'electric' character is inserted, immediately trigger a reindent
	      if (!cm.options.electricChars || !cm.options.smartIndent) {
	        return;
	      }

	      var sel = cm.doc.sel;

	      for (var i = sel.ranges.length - 1; i >= 0; i--) {
	        var range = sel.ranges[i];

	        if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line) {
	          continue;
	        }

	        var mode = cm.getModeAt(range.head);
	        var indented = false;

	        if (mode.electricChars) {
	          for (var j = 0; j < mode.electricChars.length; j++) {
	            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	              indented = indentLine(cm, range.head.line, "smart");
	              break;
	            }
	          }
	        } else if (mode.electricInput) {
	          if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) {
	            indented = indentLine(cm, range.head.line, "smart");
	          }
	        }

	        if (indented) {
	          signalLater(cm, "electricInput", cm, range.head.line);
	        }
	      }
	    }

	    function copyableRanges(cm) {
	      var text = [],
	          ranges = [];

	      for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	        var line = cm.doc.sel.ranges[i].head.line;
	        var lineRange = {
	          anchor: Pos(line, 0),
	          head: Pos(line + 1, 0)
	        };
	        ranges.push(lineRange);
	        text.push(cm.getRange(lineRange.anchor, lineRange.head));
	      }

	      return {
	        text: text,
	        ranges: ranges
	      };
	    }

	    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
	      field.setAttribute("autocorrect", autocorrect ? "" : "off");
	      field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
	      field.setAttribute("spellcheck", !!spellcheck);
	    }

	    function hiddenTextarea() {
	      var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
	      var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"); // The textarea is kept positioned near the cursor to prevent the
	      // fact that it'll be scrolled into view on input from scrolling
	      // our fake cursor out of view. On webkit, when wrap=off, paste is
	      // very slow. So make the area wide instead.

	      if (webkit) {
	        te.style.width = "1000px";
	      } else {
	        te.setAttribute("wrap", "off");
	      } // If border: 0; -- iOS fails to open keyboard (issue #1287)


	      if (ios) {
	        te.style.border = "1px solid black";
	      }

	      disableBrowserMagic(te);
	      return div;
	    } // The publicly visible API. Note that methodOp(f) means
	    // 'wrap f in an operation, performed on its `this` parameter'.
	    // This is not the complete set of editor methods. Most of the
	    // methods defined on the Doc type are also injected into
	    // CodeMirror.prototype, for backwards compatibility and
	    // convenience.


	    function addEditorMethods(CodeMirror) {
	      var optionHandlers = CodeMirror.optionHandlers;
	      var helpers = CodeMirror.helpers = {};
	      CodeMirror.prototype = {
	        constructor: CodeMirror,
	        focus: function () {
	          window.focus();
	          this.display.input.focus();
	        },
	        setOption: function (option, value) {
	          var options = this.options,
	              old = options[option];

	          if (options[option] == value && option != "mode") {
	            return;
	          }

	          options[option] = value;

	          if (optionHandlers.hasOwnProperty(option)) {
	            operation(this, optionHandlers[option])(this, value, old);
	          }

	          signal(this, "optionChange", this, option);
	        },
	        getOption: function (option) {
	          return this.options[option];
	        },
	        getDoc: function () {
	          return this.doc;
	        },
	        addKeyMap: function (map, bottom) {
	          this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
	        },
	        removeKeyMap: function (map) {
	          var maps = this.state.keyMaps;

	          for (var i = 0; i < maps.length; ++i) {
	            if (maps[i] == map || maps[i].name == map) {
	              maps.splice(i, 1);
	              return true;
	            }
	          }
	        },
	        addOverlay: methodOp(function (spec, options) {
	          var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);

	          if (mode.startState) {
	            throw new Error("Overlays may not be stateful.");
	          }

	          insertSorted(this.state.overlays, {
	            mode: mode,
	            modeSpec: spec,
	            opaque: options && options.opaque,
	            priority: options && options.priority || 0
	          }, function (overlay) {
	            return overlay.priority;
	          });
	          this.state.modeGen++;
	          regChange(this);
	        }),
	        removeOverlay: methodOp(function (spec) {
	          var overlays = this.state.overlays;

	          for (var i = 0; i < overlays.length; ++i) {
	            var cur = overlays[i].modeSpec;

	            if (cur == spec || typeof spec == "string" && cur.name == spec) {
	              overlays.splice(i, 1);
	              this.state.modeGen++;
	              regChange(this);
	              return;
	            }
	          }
	        }),
	        indentLine: methodOp(function (n, dir, aggressive) {
	          if (typeof dir != "string" && typeof dir != "number") {
	            if (dir == null) {
	              dir = this.options.smartIndent ? "smart" : "prev";
	            } else {
	              dir = dir ? "add" : "subtract";
	            }
	          }

	          if (isLine(this.doc, n)) {
	            indentLine(this, n, dir, aggressive);
	          }
	        }),
	        indentSelection: methodOp(function (how) {
	          var ranges = this.doc.sel.ranges,
	              end = -1;

	          for (var i = 0; i < ranges.length; i++) {
	            var range = ranges[i];

	            if (!range.empty()) {
	              var from = range.from(),
	                  to = range.to();
	              var start = Math.max(end, from.line);
	              end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;

	              for (var j = start; j < end; ++j) {
	                indentLine(this, j, how);
	              }

	              var newRanges = this.doc.sel.ranges;

	              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
	                replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
	              }
	            } else if (range.head.line > end) {
	              indentLine(this, range.head.line, how, true);
	              end = range.head.line;

	              if (i == this.doc.sel.primIndex) {
	                ensureCursorVisible(this);
	              }
	            }
	          }
	        }),
	        // Fetch the parser token for a given character. Useful for hacks
	        // that want to inspect the mode state (say, for completion).
	        getTokenAt: function (pos, precise) {
	          return takeToken(this, pos, precise);
	        },
	        getLineTokens: function (line, precise) {
	          return takeToken(this, Pos(line), precise, true);
	        },
	        getTokenTypeAt: function (pos) {
	          pos = clipPos(this.doc, pos);
	          var styles = getLineStyles(this, getLine(this.doc, pos.line));
	          var before = 0,
	              after = (styles.length - 1) / 2,
	              ch = pos.ch;
	          var type;

	          if (ch == 0) {
	            type = styles[2];
	          } else {
	            for (;;) {
	              var mid = before + after >> 1;

	              if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
	                after = mid;
	              } else if (styles[mid * 2 + 1] < ch) {
	                before = mid + 1;
	              } else {
	                type = styles[mid * 2 + 2];
	                break;
	              }
	            }
	          }

	          var cut = type ? type.indexOf("overlay ") : -1;
	          return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
	        },
	        getModeAt: function (pos) {
	          var mode = this.doc.mode;

	          if (!mode.innerMode) {
	            return mode;
	          }

	          return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
	        },
	        getHelper: function (pos, type) {
	          return this.getHelpers(pos, type)[0];
	        },
	        getHelpers: function (pos, type) {
	          var found = [];

	          if (!helpers.hasOwnProperty(type)) {
	            return found;
	          }

	          var help = helpers[type],
	              mode = this.getModeAt(pos);

	          if (typeof mode[type] == "string") {
	            if (help[mode[type]]) {
	              found.push(help[mode[type]]);
	            }
	          } else if (mode[type]) {
	            for (var i = 0; i < mode[type].length; i++) {
	              var val = help[mode[type][i]];

	              if (val) {
	                found.push(val);
	              }
	            }
	          } else if (mode.helperType && help[mode.helperType]) {
	            found.push(help[mode.helperType]);
	          } else if (help[mode.name]) {
	            found.push(help[mode.name]);
	          }

	          for (var i$1 = 0; i$1 < help._global.length; i$1++) {
	            var cur = help._global[i$1];

	            if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
	              found.push(cur.val);
	            }
	          }

	          return found;
	        },
	        getStateAfter: function (line, precise) {
	          var doc = this.doc;
	          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
	          return getContextBefore(this, line + 1, precise).state;
	        },
	        cursorCoords: function (start, mode) {
	          var pos,
	              range = this.doc.sel.primary();

	          if (start == null) {
	            pos = range.head;
	          } else if (typeof start == "object") {
	            pos = clipPos(this.doc, start);
	          } else {
	            pos = start ? range.from() : range.to();
	          }

	          return cursorCoords(this, pos, mode || "page");
	        },
	        charCoords: function (pos, mode) {
	          return charCoords(this, clipPos(this.doc, pos), mode || "page");
	        },
	        coordsChar: function (coords, mode) {
	          coords = fromCoordSystem(this, coords, mode || "page");
	          return coordsChar(this, coords.left, coords.top);
	        },
	        lineAtHeight: function (height, mode) {
	          height = fromCoordSystem(this, {
	            top: height,
	            left: 0
	          }, mode || "page").top;
	          return lineAtHeight(this.doc, height + this.display.viewOffset);
	        },
	        heightAtLine: function (line, mode, includeWidgets) {
	          var end = false,
	              lineObj;

	          if (typeof line == "number") {
	            var last = this.doc.first + this.doc.size - 1;

	            if (line < this.doc.first) {
	              line = this.doc.first;
	            } else if (line > last) {
	              line = last;
	              end = true;
	            }

	            lineObj = getLine(this.doc, line);
	          } else {
	            lineObj = line;
	          }

	          return intoCoordSystem(this, lineObj, {
	            top: 0,
	            left: 0
	          }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
	        },
	        defaultTextHeight: function () {
	          return textHeight(this.display);
	        },
	        defaultCharWidth: function () {
	          return charWidth(this.display);
	        },
	        getViewport: function () {
	          return {
	            from: this.display.viewFrom,
	            to: this.display.viewTo
	          };
	        },
	        addWidget: function (pos, node, scroll, vert, horiz) {
	          var display = this.display;
	          pos = cursorCoords(this, clipPos(this.doc, pos));
	          var top = pos.bottom,
	              left = pos.left;
	          node.style.position = "absolute";
	          node.setAttribute("cm-ignore-events", "true");
	          this.display.input.setUneditable(node);
	          display.sizer.appendChild(node);

	          if (vert == "over") {
	            top = pos.top;
	          } else if (vert == "above" || vert == "near") {
	            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	                hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below

	            if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
	              top = pos.top - node.offsetHeight;
	            } else if (pos.bottom + node.offsetHeight <= vspace) {
	              top = pos.bottom;
	            }

	            if (left + node.offsetWidth > hspace) {
	              left = hspace - node.offsetWidth;
	            }
	          }

	          node.style.top = top + "px";
	          node.style.left = node.style.right = "";

	          if (horiz == "right") {
	            left = display.sizer.clientWidth - node.offsetWidth;
	            node.style.right = "0px";
	          } else {
	            if (horiz == "left") {
	              left = 0;
	            } else if (horiz == "middle") {
	              left = (display.sizer.clientWidth - node.offsetWidth) / 2;
	            }

	            node.style.left = left + "px";
	          }

	          if (scroll) {
	            scrollIntoView(this, {
	              left: left,
	              top: top,
	              right: left + node.offsetWidth,
	              bottom: top + node.offsetHeight
	            });
	          }
	        },
	        triggerOnKeyDown: methodOp(onKeyDown),
	        triggerOnKeyPress: methodOp(onKeyPress),
	        triggerOnKeyUp: onKeyUp,
	        triggerOnMouseDown: methodOp(onMouseDown),
	        execCommand: function (cmd) {
	          if (commands.hasOwnProperty(cmd)) {
	            return commands[cmd].call(null, this);
	          }
	        },
	        triggerElectric: methodOp(function (text) {
	          triggerElectric(this, text);
	        }),
	        findPosH: function (from, amount, unit, visually) {
	          var dir = 1;

	          if (amount < 0) {
	            dir = -1;
	            amount = -amount;
	          }

	          var cur = clipPos(this.doc, from);

	          for (var i = 0; i < amount; ++i) {
	            cur = findPosH(this.doc, cur, dir, unit, visually);

	            if (cur.hitSide) {
	              break;
	            }
	          }

	          return cur;
	        },
	        moveH: methodOp(function (dir, unit) {
	          var this$1 = this;
	          this.extendSelectionsBy(function (range) {
	            if (this$1.display.shift || this$1.doc.extend || range.empty()) {
	              return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually);
	            } else {
	              return dir < 0 ? range.from() : range.to();
	            }
	          }, sel_move);
	        }),
	        deleteH: methodOp(function (dir, unit) {
	          var sel = this.doc.sel,
	              doc = this.doc;

	          if (sel.somethingSelected()) {
	            doc.replaceSelection("", null, "+delete");
	          } else {
	            deleteNearSelection(this, function (range) {
	              var other = findPosH(doc, range.head, dir, unit, false);
	              return dir < 0 ? {
	                from: other,
	                to: range.head
	              } : {
	                from: range.head,
	                to: other
	              };
	            });
	          }
	        }),
	        findPosV: function (from, amount, unit, goalColumn) {
	          var dir = 1,
	              x = goalColumn;

	          if (amount < 0) {
	            dir = -1;
	            amount = -amount;
	          }

	          var cur = clipPos(this.doc, from);

	          for (var i = 0; i < amount; ++i) {
	            var coords = cursorCoords(this, cur, "div");

	            if (x == null) {
	              x = coords.left;
	            } else {
	              coords.left = x;
	            }

	            cur = findPosV(this, coords, dir, unit);

	            if (cur.hitSide) {
	              break;
	            }
	          }

	          return cur;
	        },
	        moveV: methodOp(function (dir, unit) {
	          var this$1 = this;
	          var doc = this.doc,
	              goals = [];
	          var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
	          doc.extendSelectionsBy(function (range) {
	            if (collapse) {
	              return dir < 0 ? range.from() : range.to();
	            }

	            var headPos = cursorCoords(this$1, range.head, "div");

	            if (range.goalColumn != null) {
	              headPos.left = range.goalColumn;
	            }

	            goals.push(headPos.left);
	            var pos = findPosV(this$1, headPos, dir, unit);

	            if (unit == "page" && range == doc.sel.primary()) {
	              addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
	            }

	            return pos;
	          }, sel_move);

	          if (goals.length) {
	            for (var i = 0; i < doc.sel.ranges.length; i++) {
	              doc.sel.ranges[i].goalColumn = goals[i];
	            }
	          }
	        }),
	        // Find the word at the given position (as returned by coordsChar).
	        findWordAt: function (pos) {
	          var doc = this.doc,
	              line = getLine(doc, pos.line).text;
	          var start = pos.ch,
	              end = pos.ch;

	          if (line) {
	            var helper = this.getHelper(pos, "wordChars");

	            if ((pos.sticky == "before" || end == line.length) && start) {
	              --start;
	            } else {
	              ++end;
	            }

	            var startChar = line.charAt(start);
	            var check = isWordChar(startChar, helper) ? function (ch) {
	              return isWordChar(ch, helper);
	            } : /\s/.test(startChar) ? function (ch) {
	              return /\s/.test(ch);
	            } : function (ch) {
	              return !/\s/.test(ch) && !isWordChar(ch);
	            };

	            while (start > 0 && check(line.charAt(start - 1))) {
	              --start;
	            }

	            while (end < line.length && check(line.charAt(end))) {
	              ++end;
	            }
	          }

	          return new Range(Pos(pos.line, start), Pos(pos.line, end));
	        },
	        toggleOverwrite: function (value) {
	          if (value != null && value == this.state.overwrite) {
	            return;
	          }

	          if (this.state.overwrite = !this.state.overwrite) {
	            addClass(this.display.cursorDiv, "CodeMirror-overwrite");
	          } else {
	            rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
	          }

	          signal(this, "overwriteToggle", this, this.state.overwrite);
	        },
	        hasFocus: function () {
	          return this.display.input.getField() == activeElt();
	        },
	        isReadOnly: function () {
	          return !!(this.options.readOnly || this.doc.cantEdit);
	        },
	        scrollTo: methodOp(function (x, y) {
	          scrollToCoords(this, x, y);
	        }),
	        getScrollInfo: function () {
	          var scroller = this.display.scroller;
	          return {
	            left: scroller.scrollLeft,
	            top: scroller.scrollTop,
	            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	            clientHeight: displayHeight(this),
	            clientWidth: displayWidth(this)
	          };
	        },
	        scrollIntoView: methodOp(function (range, margin) {
	          if (range == null) {
	            range = {
	              from: this.doc.sel.primary().head,
	              to: null
	            };

	            if (margin == null) {
	              margin = this.options.cursorScrollMargin;
	            }
	          } else if (typeof range == "number") {
	            range = {
	              from: Pos(range, 0),
	              to: null
	            };
	          } else if (range.from == null) {
	            range = {
	              from: range,
	              to: null
	            };
	          }

	          if (!range.to) {
	            range.to = range.from;
	          }

	          range.margin = margin || 0;

	          if (range.from.line != null) {
	            scrollToRange(this, range);
	          } else {
	            scrollToCoordsRange(this, range.from, range.to, range.margin);
	          }
	        }),
	        setSize: methodOp(function (width, height) {
	          var this$1 = this;

	          var interpret = function (val) {
	            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
	          };

	          if (width != null) {
	            this.display.wrapper.style.width = interpret(width);
	          }

	          if (height != null) {
	            this.display.wrapper.style.height = interpret(height);
	          }

	          if (this.options.lineWrapping) {
	            clearLineMeasurementCache(this);
	          }

	          var lineNo = this.display.viewFrom;
	          this.doc.iter(lineNo, this.display.viewTo, function (line) {
	            if (line.widgets) {
	              for (var i = 0; i < line.widgets.length; i++) {
	                if (line.widgets[i].noHScroll) {
	                  regLineChange(this$1, lineNo, "widget");
	                  break;
	                }
	              }
	            }

	            ++lineNo;
	          });
	          this.curOp.forceUpdate = true;
	          signal(this, "refresh", this);
	        }),
	        operation: function (f) {
	          return runInOp(this, f);
	        },
	        startOperation: function () {
	          return startOperation(this);
	        },
	        endOperation: function () {
	          return endOperation(this);
	        },
	        refresh: methodOp(function () {
	          var oldHeight = this.display.cachedTextHeight;
	          regChange(this);
	          this.curOp.forceUpdate = true;
	          clearCaches(this);
	          scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
	          updateGutterSpace(this.display);

	          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping) {
	            estimateLineHeights(this);
	          }

	          signal(this, "refresh", this);
	        }),
	        swapDoc: methodOp(function (doc) {
	          var old = this.doc;
	          old.cm = null; // Cancel the current text selection if any (#5821)

	          if (this.state.selectingText) {
	            this.state.selectingText();
	          }

	          attachDoc(this, doc);
	          clearCaches(this);
	          this.display.input.reset();
	          scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
	          this.curOp.forceScroll = true;
	          signalLater(this, "swapDoc", this, old);
	          return old;
	        }),
	        phrase: function (phraseText) {
	          var phrases = this.options.phrases;
	          return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
	        },
	        getInputField: function () {
	          return this.display.input.getField();
	        },
	        getWrapperElement: function () {
	          return this.display.wrapper;
	        },
	        getScrollerElement: function () {
	          return this.display.scroller;
	        },
	        getGutterElement: function () {
	          return this.display.gutters;
	        }
	      };
	      eventMixin(CodeMirror);

	      CodeMirror.registerHelper = function (type, name, value) {
	        if (!helpers.hasOwnProperty(type)) {
	          helpers[type] = CodeMirror[type] = {
	            _global: []
	          };
	        }

	        helpers[type][name] = value;
	      };

	      CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
	        CodeMirror.registerHelper(type, name, value);

	        helpers[type]._global.push({
	          pred: predicate,
	          val: value
	        });
	      };
	    } // Used for horizontal relative motion. Dir is -1 or 1 (left or
	    // right), unit can be "codepoint", "char", "column" (like char, but
	    // doesn't cross line boundaries), "word" (across next word), or
	    // "group" (to the start of next group of word or
	    // non-word-non-whitespace chars). The visually param controls
	    // whether, in right-to-left text, direction 1 means to move towards
	    // the next index in the string, or towards the character to the right
	    // of the current position. The resulting position will have a
	    // hitSide=true property if it reached the end of the document.


	    function findPosH(doc, pos, dir, unit, visually) {
	      var oldPos = pos;
	      var origDir = dir;
	      var lineObj = getLine(doc, pos.line);
	      var lineDir = visually && doc.direction == "rtl" ? -dir : dir;

	      function findNextLine() {
	        var l = pos.line + lineDir;

	        if (l < doc.first || l >= doc.first + doc.size) {
	          return false;
	        }

	        pos = new Pos(l, pos.ch, pos.sticky);
	        return lineObj = getLine(doc, l);
	      }

	      function moveOnce(boundToLine) {
	        var next;

	        if (unit == "codepoint") {
	          var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));

	          if (isNaN(ch)) {
	            next = null;
	          } else {
	            var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;
	            next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
	          }
	        } else if (visually) {
	          next = moveVisually(doc.cm, lineObj, pos, dir);
	        } else {
	          next = moveLogically(lineObj, pos, dir);
	        }

	        if (next == null) {
	          if (!boundToLine && findNextLine()) {
	            pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
	          } else {
	            return false;
	          }
	        } else {
	          pos = next;
	        }

	        return true;
	      }

	      if (unit == "char" || unit == "codepoint") {
	        moveOnce();
	      } else if (unit == "column") {
	        moveOnce(true);
	      } else if (unit == "word" || unit == "group") {
	        var sawType = null,
	            group = unit == "group";
	        var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");

	        for (var first = true;; first = false) {
	          if (dir < 0 && !moveOnce(!first)) {
	            break;
	          }

	          var cur = lineObj.text.charAt(pos.ch) || "\n";
	          var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";

	          if (group && !first && !type) {
	            type = "s";
	          }

	          if (sawType && sawType != type) {
	            if (dir < 0) {
	              dir = 1;
	              moveOnce();
	              pos.sticky = "after";
	            }

	            break;
	          }

	          if (type) {
	            sawType = type;
	          }

	          if (dir > 0 && !moveOnce(!first)) {
	            break;
	          }
	        }
	      }

	      var result = skipAtomic(doc, pos, oldPos, origDir, true);

	      if (equalCursorPos(oldPos, result)) {
	        result.hitSide = true;
	      }

	      return result;
	    } // For relative vertical movement. Dir may be -1 or 1. Unit can be
	    // "page" or "line". The resulting position will have a hitSide=true
	    // property if it reached the end of the document.


	    function findPosV(cm, pos, dir, unit) {
	      var doc = cm.doc,
	          x = pos.left,
	          y;

	      if (unit == "page") {
	        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
	        var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
	        y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
	      } else if (unit == "line") {
	        y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
	      }

	      var target;

	      for (;;) {
	        target = coordsChar(cm, x, y);

	        if (!target.outside) {
	          break;
	        }

	        if (dir < 0 ? y <= 0 : y >= doc.height) {
	          target.hitSide = true;
	          break;
	        }

	        y += dir * 5;
	      }

	      return target;
	    } // CONTENTEDITABLE INPUT STYLE


	    var ContentEditableInput = function (cm) {
	      this.cm = cm;
	      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
	      this.polling = new Delayed();
	      this.composing = null;
	      this.gracePeriod = false;
	      this.readDOMTimeout = null;
	    };

	    ContentEditableInput.prototype.init = function (display) {
	      var this$1 = this;
	      var input = this,
	          cm = input.cm;
	      var div = input.div = display.lineDiv;
	      disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

	      function belongsToInput(e) {
	        for (var t = e.target; t; t = t.parentNode) {
	          if (t == div) {
	            return true;
	          }

	          if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
	            break;
	          }
	        }

	        return false;
	      }

	      on(div, "paste", function (e) {
	        if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
	          return;
	        } // IE doesn't fire input events, so we schedule a read for the pasted content in this way


	        if (ie_version <= 11) {
	          setTimeout(operation(cm, function () {
	            return this$1.updateFromDOM();
	          }), 20);
	        }
	      });
	      on(div, "compositionstart", function (e) {
	        this$1.composing = {
	          data: e.data,
	          done: false
	        };
	      });
	      on(div, "compositionupdate", function (e) {
	        if (!this$1.composing) {
	          this$1.composing = {
	            data: e.data,
	            done: false
	          };
	        }
	      });
	      on(div, "compositionend", function (e) {
	        if (this$1.composing) {
	          if (e.data != this$1.composing.data) {
	            this$1.readFromDOMSoon();
	          }

	          this$1.composing.done = true;
	        }
	      });
	      on(div, "touchstart", function () {
	        return input.forceCompositionEnd();
	      });
	      on(div, "input", function () {
	        if (!this$1.composing) {
	          this$1.readFromDOMSoon();
	        }
	      });

	      function onCopyCut(e) {
	        if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
	          return;
	        }

	        if (cm.somethingSelected()) {
	          setLastCopied({
	            lineWise: false,
	            text: cm.getSelections()
	          });

	          if (e.type == "cut") {
	            cm.replaceSelection("", null, "cut");
	          }
	        } else if (!cm.options.lineWiseCopyCut) {
	          return;
	        } else {
	          var ranges = copyableRanges(cm);
	          setLastCopied({
	            lineWise: true,
	            text: ranges.text
	          });

	          if (e.type == "cut") {
	            cm.operation(function () {
	              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
	              cm.replaceSelection("", null, "cut");
	            });
	          }
	        }

	        if (e.clipboardData) {
	          e.clipboardData.clearData();
	          var content = lastCopied.text.join("\n"); // iOS exposes the clipboard API, but seems to discard content inserted into it

	          e.clipboardData.setData("Text", content);

	          if (e.clipboardData.getData("Text") == content) {
	            e.preventDefault();
	            return;
	          }
	        } // Old-fashioned briefly-focus-a-textarea hack


	        var kludge = hiddenTextarea(),
	            te = kludge.firstChild;
	        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
	        te.value = lastCopied.text.join("\n");
	        var hadFocus = document.activeElement;
	        selectInput(te);
	        setTimeout(function () {
	          cm.display.lineSpace.removeChild(kludge);
	          hadFocus.focus();

	          if (hadFocus == div) {
	            input.showPrimarySelection();
	          }
	        }, 50);
	      }

	      on(div, "copy", onCopyCut);
	      on(div, "cut", onCopyCut);
	    };

	    ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
	      // Label for screenreaders, accessibility
	      if (label) {
	        this.div.setAttribute('aria-label', label);
	      } else {
	        this.div.removeAttribute('aria-label');
	      }
	    };

	    ContentEditableInput.prototype.prepareSelection = function () {
	      var result = prepareSelection(this.cm, false);
	      result.focus = document.activeElement == this.div;
	      return result;
	    };

	    ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
	      if (!info || !this.cm.display.view.length) {
	        return;
	      }

	      if (info.focus || takeFocus) {
	        this.showPrimarySelection();
	      }

	      this.showMultipleSelections(info);
	    };

	    ContentEditableInput.prototype.getSelection = function () {
	      return this.cm.display.wrapper.ownerDocument.getSelection();
	    };

	    ContentEditableInput.prototype.showPrimarySelection = function () {
	      var sel = this.getSelection(),
	          cm = this.cm,
	          prim = cm.doc.sel.primary();
	      var from = prim.from(),
	          to = prim.to();

	      if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
	        sel.removeAllRanges();
	        return;
	      }

	      var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	      var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);

	      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
	        return;
	      }

	      var view = cm.display.view;
	      var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
	        node: view[0].measure.map[2],
	        offset: 0
	      };
	      var end = to.line < cm.display.viewTo && posToDOM(cm, to);

	      if (!end) {
	        var measure = view[view.length - 1].measure;
	        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
	        end = {
	          node: map[map.length - 1],
	          offset: map[map.length - 2] - map[map.length - 3]
	        };
	      }

	      if (!start || !end) {
	        sel.removeAllRanges();
	        return;
	      }

	      var old = sel.rangeCount && sel.getRangeAt(0),
	          rng;

	      try {
	        rng = range(start.node, start.offset, end.offset, end.node);
	      } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible


	      if (rng) {
	        if (!gecko && cm.state.focused) {
	          sel.collapse(start.node, start.offset);

	          if (!rng.collapsed) {
	            sel.removeAllRanges();
	            sel.addRange(rng);
	          }
	        } else {
	          sel.removeAllRanges();
	          sel.addRange(rng);
	        }

	        if (old && sel.anchorNode == null) {
	          sel.addRange(old);
	        } else if (gecko) {
	          this.startGracePeriod();
	        }
	      }

	      this.rememberSelection();
	    };

	    ContentEditableInput.prototype.startGracePeriod = function () {
	      var this$1 = this;
	      clearTimeout(this.gracePeriod);
	      this.gracePeriod = setTimeout(function () {
	        this$1.gracePeriod = false;

	        if (this$1.selectionChanged()) {
	          this$1.cm.operation(function () {
	            return this$1.cm.curOp.selectionChanged = true;
	          });
	        }
	      }, 20);
	    };

	    ContentEditableInput.prototype.showMultipleSelections = function (info) {
	      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
	      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
	    };

	    ContentEditableInput.prototype.rememberSelection = function () {
	      var sel = this.getSelection();
	      this.lastAnchorNode = sel.anchorNode;
	      this.lastAnchorOffset = sel.anchorOffset;
	      this.lastFocusNode = sel.focusNode;
	      this.lastFocusOffset = sel.focusOffset;
	    };

	    ContentEditableInput.prototype.selectionInEditor = function () {
	      var sel = this.getSelection();

	      if (!sel.rangeCount) {
	        return false;
	      }

	      var node = sel.getRangeAt(0).commonAncestorContainer;
	      return contains(this.div, node);
	    };

	    ContentEditableInput.prototype.focus = function () {
	      if (this.cm.options.readOnly != "nocursor") {
	        if (!this.selectionInEditor() || document.activeElement != this.div) {
	          this.showSelection(this.prepareSelection(), true);
	        }

	        this.div.focus();
	      }
	    };

	    ContentEditableInput.prototype.blur = function () {
	      this.div.blur();
	    };

	    ContentEditableInput.prototype.getField = function () {
	      return this.div;
	    };

	    ContentEditableInput.prototype.supportsTouch = function () {
	      return true;
	    };

	    ContentEditableInput.prototype.receivedFocus = function () {
	      var input = this;

	      if (this.selectionInEditor()) {
	        this.pollSelection();
	      } else {
	        runInOp(this.cm, function () {
	          return input.cm.curOp.selectionChanged = true;
	        });
	      }

	      function poll() {
	        if (input.cm.state.focused) {
	          input.pollSelection();
	          input.polling.set(input.cm.options.pollInterval, poll);
	        }
	      }

	      this.polling.set(this.cm.options.pollInterval, poll);
	    };

	    ContentEditableInput.prototype.selectionChanged = function () {
	      var sel = this.getSelection();
	      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
	    };

	    ContentEditableInput.prototype.pollSelection = function () {
	      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
	        return;
	      }

	      var sel = this.getSelection(),
	          cm = this.cm; // On Android Chrome (version 56, at least), backspacing into an
	      // uneditable block element will put the cursor in that element,
	      // and then, because it's not editable, hide the virtual keyboard.
	      // Because Android doesn't allow us to actually detect backspace
	      // presses in a sane way, this code checks for when that happens
	      // and simulates a backspace press in this case.

	      if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
	        this.cm.triggerOnKeyDown({
	          type: "keydown",
	          keyCode: 8,
	          preventDefault: Math.abs
	        });
	        this.blur();
	        this.focus();
	        return;
	      }

	      if (this.composing) {
	        return;
	      }

	      this.rememberSelection();
	      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	      var head = domToPos(cm, sel.focusNode, sel.focusOffset);

	      if (anchor && head) {
	        runInOp(cm, function () {
	          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);

	          if (anchor.bad || head.bad) {
	            cm.curOp.selectionChanged = true;
	          }
	        });
	      }
	    };

	    ContentEditableInput.prototype.pollContent = function () {
	      if (this.readDOMTimeout != null) {
	        clearTimeout(this.readDOMTimeout);
	        this.readDOMTimeout = null;
	      }

	      var cm = this.cm,
	          display = cm.display,
	          sel = cm.doc.sel.primary();
	      var from = sel.from(),
	          to = sel.to();

	      if (from.ch == 0 && from.line > cm.firstLine()) {
	        from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
	      }

	      if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
	        to = Pos(to.line + 1, 0);
	      }

	      if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
	        return false;
	      }

	      var fromIndex, fromLine, fromNode;

	      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
	        fromLine = lineNo(display.view[0].line);
	        fromNode = display.view[0].node;
	      } else {
	        fromLine = lineNo(display.view[fromIndex].line);
	        fromNode = display.view[fromIndex - 1].node.nextSibling;
	      }

	      var toIndex = findViewIndex(cm, to.line);
	      var toLine, toNode;

	      if (toIndex == display.view.length - 1) {
	        toLine = display.viewTo - 1;
	        toNode = display.lineDiv.lastChild;
	      } else {
	        toLine = lineNo(display.view[toIndex + 1].line) - 1;
	        toNode = display.view[toIndex + 1].node.previousSibling;
	      }

	      if (!fromNode) {
	        return false;
	      }

	      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
	      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));

	      while (newText.length > 1 && oldText.length > 1) {
	        if (lst(newText) == lst(oldText)) {
	          newText.pop();
	          oldText.pop();
	          toLine--;
	        } else if (newText[0] == oldText[0]) {
	          newText.shift();
	          oldText.shift();
	          fromLine++;
	        } else {
	          break;
	        }
	      }

	      var cutFront = 0,
	          cutEnd = 0;
	      var newTop = newText[0],
	          oldTop = oldText[0],
	          maxCutFront = Math.min(newTop.length, oldTop.length);

	      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
	        ++cutFront;
	      }

	      var newBot = lst(newText),
	          oldBot = lst(oldText);
	      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));

	      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
	        ++cutEnd;
	      } // Try to move start of change to start of selection if ambiguous


	      if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
	        while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
	          cutFront--;
	          cutEnd++;
	        }
	      }

	      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
	      newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
	      var chFrom = Pos(fromLine, cutFront);
	      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);

	      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
	        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
	        return true;
	      }
	    };

	    ContentEditableInput.prototype.ensurePolled = function () {
	      this.forceCompositionEnd();
	    };

	    ContentEditableInput.prototype.reset = function () {
	      this.forceCompositionEnd();
	    };

	    ContentEditableInput.prototype.forceCompositionEnd = function () {
	      if (!this.composing) {
	        return;
	      }

	      clearTimeout(this.readDOMTimeout);
	      this.composing = null;
	      this.updateFromDOM();
	      this.div.blur();
	      this.div.focus();
	    };

	    ContentEditableInput.prototype.readFromDOMSoon = function () {
	      var this$1 = this;

	      if (this.readDOMTimeout != null) {
	        return;
	      }

	      this.readDOMTimeout = setTimeout(function () {
	        this$1.readDOMTimeout = null;

	        if (this$1.composing) {
	          if (this$1.composing.done) {
	            this$1.composing = null;
	          } else {
	            return;
	          }
	        }

	        this$1.updateFromDOM();
	      }, 80);
	    };

	    ContentEditableInput.prototype.updateFromDOM = function () {
	      var this$1 = this;

	      if (this.cm.isReadOnly() || !this.pollContent()) {
	        runInOp(this.cm, function () {
	          return regChange(this$1.cm);
	        });
	      }
	    };

	    ContentEditableInput.prototype.setUneditable = function (node) {
	      node.contentEditable = "false";
	    };

	    ContentEditableInput.prototype.onKeyPress = function (e) {
	      if (e.charCode == 0 || this.composing) {
	        return;
	      }

	      e.preventDefault();

	      if (!this.cm.isReadOnly()) {
	        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
	      }
	    };

	    ContentEditableInput.prototype.readOnlyChanged = function (val) {
	      this.div.contentEditable = String(val != "nocursor");
	    };

	    ContentEditableInput.prototype.onContextMenu = function () {};

	    ContentEditableInput.prototype.resetPosition = function () {};

	    ContentEditableInput.prototype.needsContentAttribute = true;

	    function posToDOM(cm, pos) {
	      var view = findViewForLine(cm, pos.line);

	      if (!view || view.hidden) {
	        return null;
	      }

	      var line = getLine(cm.doc, pos.line);
	      var info = mapFromLineView(view, line, pos.line);
	      var order = getOrder(line, cm.doc.direction),
	          side = "left";

	      if (order) {
	        var partPos = getBidiPartAt(order, pos.ch);
	        side = partPos % 2 ? "right" : "left";
	      }

	      var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
	      result.offset = result.collapse == "right" ? result.end : result.start;
	      return result;
	    }

	    function isInGutter(node) {
	      for (var scan = node; scan; scan = scan.parentNode) {
	        if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
	          return true;
	        }
	      }

	      return false;
	    }

	    function badPos(pos, bad) {
	      if (bad) {
	        pos.bad = true;
	      }

	      return pos;
	    }

	    function domTextBetween(cm, from, to, fromLine, toLine) {
	      var text = "",
	          closing = false,
	          lineSep = cm.doc.lineSeparator(),
	          extraLinebreak = false;

	      function recognizeMarker(id) {
	        return function (marker) {
	          return marker.id == id;
	        };
	      }

	      function close() {
	        if (closing) {
	          text += lineSep;

	          if (extraLinebreak) {
	            text += lineSep;
	          }

	          closing = extraLinebreak = false;
	        }
	      }

	      function addText(str) {
	        if (str) {
	          close();
	          text += str;
	        }
	      }

	      function walk(node) {
	        if (node.nodeType == 1) {
	          var cmText = node.getAttribute("cm-text");

	          if (cmText) {
	            addText(cmText);
	            return;
	          }

	          var markerID = node.getAttribute("cm-marker"),
	              range;

	          if (markerID) {
	            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));

	            if (found.length && (range = found[0].find(0))) {
	              addText(getBetween(cm.doc, range.from, range.to).join(lineSep));
	            }

	            return;
	          }

	          if (node.getAttribute("contenteditable") == "false") {
	            return;
	          }

	          var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);

	          if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
	            return;
	          }

	          if (isBlock) {
	            close();
	          }

	          for (var i = 0; i < node.childNodes.length; i++) {
	            walk(node.childNodes[i]);
	          }

	          if (/^(pre|p)$/i.test(node.nodeName)) {
	            extraLinebreak = true;
	          }

	          if (isBlock) {
	            closing = true;
	          }
	        } else if (node.nodeType == 3) {
	          addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
	        }
	      }

	      for (;;) {
	        walk(from);

	        if (from == to) {
	          break;
	        }

	        from = from.nextSibling;
	        extraLinebreak = false;
	      }

	      return text;
	    }

	    function domToPos(cm, node, offset) {
	      var lineNode;

	      if (node == cm.display.lineDiv) {
	        lineNode = cm.display.lineDiv.childNodes[offset];

	        if (!lineNode) {
	          return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
	        }

	        node = null;
	        offset = 0;
	      } else {
	        for (lineNode = node;; lineNode = lineNode.parentNode) {
	          if (!lineNode || lineNode == cm.display.lineDiv) {
	            return null;
	          }

	          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
	            break;
	          }
	        }
	      }

	      for (var i = 0; i < cm.display.view.length; i++) {
	        var lineView = cm.display.view[i];

	        if (lineView.node == lineNode) {
	          return locateNodeInLineView(lineView, node, offset);
	        }
	      }
	    }

	    function locateNodeInLineView(lineView, node, offset) {
	      var wrapper = lineView.text.firstChild,
	          bad = false;

	      if (!node || !contains(wrapper, node)) {
	        return badPos(Pos(lineNo(lineView.line), 0), true);
	      }

	      if (node == wrapper) {
	        bad = true;
	        node = wrapper.childNodes[offset];
	        offset = 0;

	        if (!node) {
	          var line = lineView.rest ? lst(lineView.rest) : lineView.line;
	          return badPos(Pos(lineNo(line), line.text.length), bad);
	        }
	      }

	      var textNode = node.nodeType == 3 ? node : null,
	          topNode = node;

	      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
	        textNode = node.firstChild;

	        if (offset) {
	          offset = textNode.nodeValue.length;
	        }
	      }

	      while (topNode.parentNode != wrapper) {
	        topNode = topNode.parentNode;
	      }

	      var measure = lineView.measure,
	          maps = measure.maps;

	      function find(textNode, topNode, offset) {
	        for (var i = -1; i < (maps ? maps.length : 0); i++) {
	          var map = i < 0 ? measure.map : maps[i];

	          for (var j = 0; j < map.length; j += 3) {
	            var curNode = map[j + 2];

	            if (curNode == textNode || curNode == topNode) {
	              var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
	              var ch = map[j] + offset;

	              if (offset < 0 || curNode != textNode) {
	                ch = map[j + (offset ? 1 : 0)];
	              }

	              return Pos(line, ch);
	            }
	          }
	        }
	      }

	      var found = find(textNode, topNode, offset);

	      if (found) {
	        return badPos(found, bad);
	      } // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems


	      for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
	        found = find(after, after.firstChild, 0);

	        if (found) {
	          return badPos(Pos(found.line, found.ch - dist), bad);
	        } else {
	          dist += after.textContent.length;
	        }
	      }

	      for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
	        found = find(before, before.firstChild, -1);

	        if (found) {
	          return badPos(Pos(found.line, found.ch + dist$1), bad);
	        } else {
	          dist$1 += before.textContent.length;
	        }
	      }
	    } // TEXTAREA INPUT STYLE


	    var TextareaInput = function (cm) {
	      this.cm = cm; // See input.poll and input.reset

	      this.prevInput = ""; // Flag that indicates whether we expect input to appear real soon
	      // now (after some event like 'keypress' or 'input') and are
	      // polling intensively.

	      this.pollingFast = false; // Self-resetting timeout for the poller

	      this.polling = new Delayed(); // Used to work around IE issue with selection being forgotten when focus moves away from textarea

	      this.hasSelection = false;
	      this.composing = null;
	    };

	    TextareaInput.prototype.init = function (display) {
	      var this$1 = this;
	      var input = this,
	          cm = this.cm;
	      this.createField(display);
	      var te = this.textarea;
	      display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild); // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)

	      if (ios) {
	        te.style.width = "0px";
	      }

	      on(te, "input", function () {
	        if (ie && ie_version >= 9 && this$1.hasSelection) {
	          this$1.hasSelection = null;
	        }

	        input.poll();
	      });
	      on(te, "paste", function (e) {
	        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
	          return;
	        }

	        cm.state.pasteIncoming = +new Date();
	        input.fastPoll();
	      });

	      function prepareCopyCut(e) {
	        if (signalDOMEvent(cm, e)) {
	          return;
	        }

	        if (cm.somethingSelected()) {
	          setLastCopied({
	            lineWise: false,
	            text: cm.getSelections()
	          });
	        } else if (!cm.options.lineWiseCopyCut) {
	          return;
	        } else {
	          var ranges = copyableRanges(cm);
	          setLastCopied({
	            lineWise: true,
	            text: ranges.text
	          });

	          if (e.type == "cut") {
	            cm.setSelections(ranges.ranges, null, sel_dontScroll);
	          } else {
	            input.prevInput = "";
	            te.value = ranges.text.join("\n");
	            selectInput(te);
	          }
	        }

	        if (e.type == "cut") {
	          cm.state.cutIncoming = +new Date();
	        }
	      }

	      on(te, "cut", prepareCopyCut);
	      on(te, "copy", prepareCopyCut);
	      on(display.scroller, "paste", function (e) {
	        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
	          return;
	        }

	        if (!te.dispatchEvent) {
	          cm.state.pasteIncoming = +new Date();
	          input.focus();
	          return;
	        } // Pass the `paste` event to the textarea so it's handled by its event listener.


	        var event = new Event("paste");
	        event.clipboardData = e.clipboardData;
	        te.dispatchEvent(event);
	      }); // Prevent normal selection in the editor (we handle our own)

	      on(display.lineSpace, "selectstart", function (e) {
	        if (!eventInWidget(display, e)) {
	          e_preventDefault(e);
	        }
	      });
	      on(te, "compositionstart", function () {
	        var start = cm.getCursor("from");

	        if (input.composing) {
	          input.composing.range.clear();
	        }

	        input.composing = {
	          start: start,
	          range: cm.markText(start, cm.getCursor("to"), {
	            className: "CodeMirror-composing"
	          })
	        };
	      });
	      on(te, "compositionend", function () {
	        if (input.composing) {
	          input.poll();
	          input.composing.range.clear();
	          input.composing = null;
	        }
	      });
	    };

	    TextareaInput.prototype.createField = function (_display) {
	      // Wraps and hides input textarea
	      this.wrapper = hiddenTextarea(); // The semihidden textarea that is focused when the editor is
	      // focused, and receives input.

	      this.textarea = this.wrapper.firstChild;
	    };

	    TextareaInput.prototype.screenReaderLabelChanged = function (label) {
	      // Label for screenreaders, accessibility
	      if (label) {
	        this.textarea.setAttribute('aria-label', label);
	      } else {
	        this.textarea.removeAttribute('aria-label');
	      }
	    };

	    TextareaInput.prototype.prepareSelection = function () {
	      // Redraw the selection and/or cursor
	      var cm = this.cm,
	          display = cm.display,
	          doc = cm.doc;
	      var result = prepareSelection(cm); // Move the hidden textarea near the cursor to prevent scrolling artifacts

	      if (cm.options.moveInputWithCursor) {
	        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
	        var wrapOff = display.wrapper.getBoundingClientRect(),
	            lineOff = display.lineDiv.getBoundingClientRect();
	        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
	        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
	      }

	      return result;
	    };

	    TextareaInput.prototype.showSelection = function (drawn) {
	      var cm = this.cm,
	          display = cm.display;
	      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
	      removeChildrenAndAdd(display.selectionDiv, drawn.selection);

	      if (drawn.teTop != null) {
	        this.wrapper.style.top = drawn.teTop + "px";
	        this.wrapper.style.left = drawn.teLeft + "px";
	      }
	    }; // Reset the input to correspond to the selection (or to be empty,
	    // when not typing and nothing is selected)


	    TextareaInput.prototype.reset = function (typing) {
	      if (this.contextMenuPending || this.composing) {
	        return;
	      }

	      var cm = this.cm;

	      if (cm.somethingSelected()) {
	        this.prevInput = "";
	        var content = cm.getSelection();
	        this.textarea.value = content;

	        if (cm.state.focused) {
	          selectInput(this.textarea);
	        }

	        if (ie && ie_version >= 9) {
	          this.hasSelection = content;
	        }
	      } else if (!typing) {
	        this.prevInput = this.textarea.value = "";

	        if (ie && ie_version >= 9) {
	          this.hasSelection = null;
	        }
	      }
	    };

	    TextareaInput.prototype.getField = function () {
	      return this.textarea;
	    };

	    TextareaInput.prototype.supportsTouch = function () {
	      return false;
	    };

	    TextareaInput.prototype.focus = function () {
	      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
	        try {
	          this.textarea.focus();
	        } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM

	      }
	    };

	    TextareaInput.prototype.blur = function () {
	      this.textarea.blur();
	    };

	    TextareaInput.prototype.resetPosition = function () {
	      this.wrapper.style.top = this.wrapper.style.left = 0;
	    };

	    TextareaInput.prototype.receivedFocus = function () {
	      this.slowPoll();
	    }; // Poll for input changes, using the normal rate of polling. This
	    // runs as long as the editor is focused.


	    TextareaInput.prototype.slowPoll = function () {
	      var this$1 = this;

	      if (this.pollingFast) {
	        return;
	      }

	      this.polling.set(this.cm.options.pollInterval, function () {
	        this$1.poll();

	        if (this$1.cm.state.focused) {
	          this$1.slowPoll();
	        }
	      });
	    }; // When an event has just come in that is likely to add or change
	    // something in the input textarea, we poll faster, to ensure that
	    // the change appears on the screen quickly.


	    TextareaInput.prototype.fastPoll = function () {
	      var missed = false,
	          input = this;
	      input.pollingFast = true;

	      function p() {
	        var changed = input.poll();

	        if (!changed && !missed) {
	          missed = true;
	          input.polling.set(60, p);
	        } else {
	          input.pollingFast = false;
	          input.slowPoll();
	        }
	      }

	      input.polling.set(20, p);
	    }; // Read input from the textarea, and update the document to match.
	    // When something is selected, it is present in the textarea, and
	    // selected (unless it is huge, in which case a placeholder is
	    // used). When nothing is selected, the cursor sits after previously
	    // seen text (can be empty), which is stored in prevInput (we must
	    // not reset the textarea when typing, because that breaks IME).


	    TextareaInput.prototype.poll = function () {
	      var this$1 = this;
	      var cm = this.cm,
	          input = this.textarea,
	          prevInput = this.prevInput; // Since this is called a *lot*, try to bail out as cheaply as
	      // possible when it is clear that nothing happened. hasSelection
	      // will be the case when there is a lot of text in the textarea,
	      // in which case reading its value would be expensive.

	      if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
	        return false;
	      }

	      var text = input.value; // If nothing changed, bail.

	      if (text == prevInput && !cm.somethingSelected()) {
	        return false;
	      } // Work around nonsensical selection resetting in IE9/10, and
	      // inexplicable appearance of private area unicode characters on
	      // some key combos in Mac (#2689).


	      if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
	        cm.display.input.reset();
	        return false;
	      }

	      if (cm.doc.sel == cm.display.selForContextMenu) {
	        var first = text.charCodeAt(0);

	        if (first == 0x200b && !prevInput) {
	          prevInput = "\u200b";
	        }

	        if (first == 0x21da) {
	          this.reset();
	          return this.cm.execCommand("undo");
	        }
	      } // Find the part of the input that is actually new


	      var same = 0,
	          l = Math.min(prevInput.length, text.length);

	      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
	        ++same;
	      }

	      runInOp(cm, function () {
	        applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null); // Don't leave long text in the textarea, since it makes further polling slow

	        if (text.length > 1000 || text.indexOf("\n") > -1) {
	          input.value = this$1.prevInput = "";
	        } else {
	          this$1.prevInput = text;
	        }

	        if (this$1.composing) {
	          this$1.composing.range.clear();
	          this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
	            className: "CodeMirror-composing"
	          });
	        }
	      });
	      return true;
	    };

	    TextareaInput.prototype.ensurePolled = function () {
	      if (this.pollingFast && this.poll()) {
	        this.pollingFast = false;
	      }
	    };

	    TextareaInput.prototype.onKeyPress = function () {
	      if (ie && ie_version >= 9) {
	        this.hasSelection = null;
	      }

	      this.fastPoll();
	    };

	    TextareaInput.prototype.onContextMenu = function (e) {
	      var input = this,
	          cm = input.cm,
	          display = cm.display,
	          te = input.textarea;

	      if (input.contextMenuPending) {
	        input.contextMenuPending();
	      }

	      var pos = posFromMouse(cm, e),
	          scrollPos = display.scroller.scrollTop;

	      if (!pos || presto) {
	        return;
	      } // Opera is difficult.
	      // Reset the current text selection only if the click is done outside of the selection
	      // and 'resetSelectionOnContextMenu' option is true.


	      var reset = cm.options.resetSelectionOnContextMenu;

	      if (reset && cm.doc.sel.contains(pos) == -1) {
	        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
	      }

	      var oldCSS = te.style.cssText,
	          oldWrapperCSS = input.wrapper.style.cssText;
	      var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
	      input.wrapper.style.cssText = "position: static";
	      te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
	      var oldScrollY;

	      if (webkit) {
	        oldScrollY = window.scrollY;
	      } // Work around Chrome issue (#2712)


	      display.input.focus();

	      if (webkit) {
	        window.scrollTo(null, oldScrollY);
	      }

	      display.input.reset(); // Adds "Select all" to context menu in FF

	      if (!cm.somethingSelected()) {
	        te.value = input.prevInput = " ";
	      }

	      input.contextMenuPending = rehide;
	      display.selForContextMenu = cm.doc.sel;
	      clearTimeout(display.detectingSelectAll); // Select-all will be greyed out if there's nothing to select, so
	      // this adds a zero-width space so that we can later check whether
	      // it got selected.

	      function prepareSelectAllHack() {
	        if (te.selectionStart != null) {
	          var selected = cm.somethingSelected();
	          var extval = "\u200b" + (selected ? te.value : "");
	          te.value = "\u21da"; // Used to catch context-menu undo

	          te.value = extval;
	          input.prevInput = selected ? "" : "\u200b";
	          te.selectionStart = 1;
	          te.selectionEnd = extval.length; // Re-set this, in case some other handler touched the
	          // selection in the meantime.

	          display.selForContextMenu = cm.doc.sel;
	        }
	      }

	      function rehide() {
	        if (input.contextMenuPending != rehide) {
	          return;
	        }

	        input.contextMenuPending = false;
	        input.wrapper.style.cssText = oldWrapperCSS;
	        te.style.cssText = oldCSS;

	        if (ie && ie_version < 9) {
	          display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
	        } // Try to detect the user choosing select-all


	        if (te.selectionStart != null) {
	          if (!ie || ie && ie_version < 9) {
	            prepareSelectAllHack();
	          }

	          var i = 0,
	              poll = function () {
	            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200b") {
	              operation(cm, selectAll)(cm);
	            } else if (i++ < 10) {
	              display.detectingSelectAll = setTimeout(poll, 500);
	            } else {
	              display.selForContextMenu = null;
	              display.input.reset();
	            }
	          };

	          display.detectingSelectAll = setTimeout(poll, 200);
	        }
	      }

	      if (ie && ie_version >= 9) {
	        prepareSelectAllHack();
	      }

	      if (captureRightClick) {
	        e_stop(e);

	        var mouseup = function () {
	          off(window, "mouseup", mouseup);
	          setTimeout(rehide, 20);
	        };

	        on(window, "mouseup", mouseup);
	      } else {
	        setTimeout(rehide, 50);
	      }
	    };

	    TextareaInput.prototype.readOnlyChanged = function (val) {
	      if (!val) {
	        this.reset();
	      }

	      this.textarea.disabled = val == "nocursor";
	      this.textarea.readOnly = !!val;
	    };

	    TextareaInput.prototype.setUneditable = function () {};

	    TextareaInput.prototype.needsContentAttribute = false;

	    function fromTextArea(textarea, options) {
	      options = options ? copyObj(options) : {};
	      options.value = textarea.value;

	      if (!options.tabindex && textarea.tabIndex) {
	        options.tabindex = textarea.tabIndex;
	      }

	      if (!options.placeholder && textarea.placeholder) {
	        options.placeholder = textarea.placeholder;
	      } // Set autofocus to true if this textarea is focused, or if it has
	      // autofocus and no other element is focused.


	      if (options.autofocus == null) {
	        var hasFocus = activeElt();
	        options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
	      }

	      function save() {
	        textarea.value = cm.getValue();
	      }

	      var realSubmit;

	      if (textarea.form) {
	        on(textarea.form, "submit", save); // Deplorable hack to make the submit method do the right thing.

	        if (!options.leaveSubmitMethodAlone) {
	          var form = textarea.form;
	          realSubmit = form.submit;

	          try {
	            var wrappedSubmit = form.submit = function () {
	              save();
	              form.submit = realSubmit;
	              form.submit();
	              form.submit = wrappedSubmit;
	            };
	          } catch (e) {}
	        }
	      }

	      options.finishInit = function (cm) {
	        cm.save = save;

	        cm.getTextArea = function () {
	          return textarea;
	        };

	        cm.toTextArea = function () {
	          cm.toTextArea = isNaN; // Prevent this from being ran twice

	          save();
	          textarea.parentNode.removeChild(cm.getWrapperElement());
	          textarea.style.display = "";

	          if (textarea.form) {
	            off(textarea.form, "submit", save);

	            if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
	              textarea.form.submit = realSubmit;
	            }
	          }
	        };
	      };

	      textarea.style.display = "none";
	      var cm = CodeMirror(function (node) {
	        return textarea.parentNode.insertBefore(node, textarea.nextSibling);
	      }, options);
	      return cm;
	    }

	    function addLegacyProps(CodeMirror) {
	      CodeMirror.off = off;
	      CodeMirror.on = on;
	      CodeMirror.wheelEventPixels = wheelEventPixels;
	      CodeMirror.Doc = Doc;
	      CodeMirror.splitLines = splitLinesAuto;
	      CodeMirror.countColumn = countColumn;
	      CodeMirror.findColumn = findColumn;
	      CodeMirror.isWordChar = isWordCharBasic;
	      CodeMirror.Pass = Pass;
	      CodeMirror.signal = signal;
	      CodeMirror.Line = Line;
	      CodeMirror.changeEnd = changeEnd;
	      CodeMirror.scrollbarModel = scrollbarModel;
	      CodeMirror.Pos = Pos;
	      CodeMirror.cmpPos = cmp;
	      CodeMirror.modes = modes;
	      CodeMirror.mimeModes = mimeModes;
	      CodeMirror.resolveMode = resolveMode;
	      CodeMirror.getMode = getMode;
	      CodeMirror.modeExtensions = modeExtensions;
	      CodeMirror.extendMode = extendMode;
	      CodeMirror.copyState = copyState;
	      CodeMirror.startState = startState;
	      CodeMirror.innerMode = innerMode;
	      CodeMirror.commands = commands;
	      CodeMirror.keyMap = keyMap;
	      CodeMirror.keyName = keyName;
	      CodeMirror.isModifierKey = isModifierKey;
	      CodeMirror.lookupKey = lookupKey;
	      CodeMirror.normalizeKeyMap = normalizeKeyMap;
	      CodeMirror.StringStream = StringStream;
	      CodeMirror.SharedTextMarker = SharedTextMarker;
	      CodeMirror.TextMarker = TextMarker;
	      CodeMirror.LineWidget = LineWidget;
	      CodeMirror.e_preventDefault = e_preventDefault;
	      CodeMirror.e_stopPropagation = e_stopPropagation;
	      CodeMirror.e_stop = e_stop;
	      CodeMirror.addClass = addClass;
	      CodeMirror.contains = contains;
	      CodeMirror.rmClass = rmClass;
	      CodeMirror.keyNames = keyNames;
	    } // EDITOR CONSTRUCTOR


	    defineOptions(CodeMirror);
	    addEditorMethods(CodeMirror); // Set up methods on CodeMirror's prototype to redirect to the editor's document.

	    var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");

	    for (var prop in Doc.prototype) {
	      if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
	        CodeMirror.prototype[prop] = function (method) {
	          return function () {
	            return method.apply(this.doc, arguments);
	          };
	        }(Doc.prototype[prop]);
	      }
	    }

	    eventMixin(Doc);
	    CodeMirror.inputStyles = {
	      "textarea": TextareaInput,
	      "contenteditable": ContentEditableInput
	    }; // Extra arguments are stored as the mode's dependencies, which is
	    // used by (legacy) mechanisms like loadmode.js to automatically
	    // load a mode. (Preferred mechanism is the require/define calls.)

	    CodeMirror.defineMode = function (name
	    /*, mode, …*/
	    ) {
	      if (!CodeMirror.defaults.mode && name != "null") {
	        CodeMirror.defaults.mode = name;
	      }

	      defineMode.apply(this, arguments);
	    };

	    CodeMirror.defineMIME = defineMIME; // Minimal default mode.

	    CodeMirror.defineMode("null", function () {
	      return {
	        token: function (stream) {
	          return stream.skipToEnd();
	        }
	      };
	    });
	    CodeMirror.defineMIME("text/plain", "null"); // EXTENSIONS

	    CodeMirror.defineExtension = function (name, func) {
	      CodeMirror.prototype[name] = func;
	    };

	    CodeMirror.defineDocExtension = function (name, func) {
	      Doc.prototype[name] = func;
	    };

	    CodeMirror.fromTextArea = fromTextArea;
	    addLegacyProps(CodeMirror);
	    CodeMirror.version = "5.59.2";
	    return CodeMirror;
	  });
	});

	var css = createCommonjsModule(function (module, exports) {
	  // CodeMirror, copyright (c) by Marijn Haverbeke and others
	  // Distributed under an MIT license: https://codemirror.net/LICENSE
	  (function (mod) {
	    mod(codemirror);
	  })(function (CodeMirror) {

	    CodeMirror.defineMode("css", function (config, parserConfig) {
	      var inline = parserConfig.inline;
	      if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");
	      var indentUnit = config.indentUnit,
	          tokenHooks = parserConfig.tokenHooks,
	          documentTypes = parserConfig.documentTypes || {},
	          mediaTypes = parserConfig.mediaTypes || {},
	          mediaFeatures = parserConfig.mediaFeatures || {},
	          mediaValueKeywords = parserConfig.mediaValueKeywords || {},
	          propertyKeywords = parserConfig.propertyKeywords || {},
	          nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
	          fontProperties = parserConfig.fontProperties || {},
	          counterDescriptors = parserConfig.counterDescriptors || {},
	          colorKeywords = parserConfig.colorKeywords || {},
	          valueKeywords = parserConfig.valueKeywords || {},
	          allowNested = parserConfig.allowNested,
	          lineComment = parserConfig.lineComment,
	          supportsAtComponent = parserConfig.supportsAtComponent === true,
	          highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;
	      var type, override;

	      function ret(style, tp) {
	        type = tp;
	        return style;
	      } // Tokenizers


	      function tokenBase(stream, state) {
	        var ch = stream.next();

	        if (tokenHooks[ch]) {
	          var result = tokenHooks[ch](stream, state);
	          if (result !== false) return result;
	        }

	        if (ch == "@") {
	          stream.eatWhile(/[\w\\\-]/);
	          return ret("def", stream.current());
	        } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
	          return ret(null, "compare");
	        } else if (ch == "\"" || ch == "'") {
	          state.tokenize = tokenString(ch);
	          return state.tokenize(stream, state);
	        } else if (ch == "#") {
	          stream.eatWhile(/[\w\\\-]/);
	          return ret("atom", "hash");
	        } else if (ch == "!") {
	          stream.match(/^\s*\w*/);
	          return ret("keyword", "important");
	        } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
	          stream.eatWhile(/[\w.%]/);
	          return ret("number", "unit");
	        } else if (ch === "-") {
	          if (/[\d.]/.test(stream.peek())) {
	            stream.eatWhile(/[\w.%]/);
	            return ret("number", "unit");
	          } else if (stream.match(/^-[\w\\\-]*/)) {
	            stream.eatWhile(/[\w\\\-]/);
	            if (stream.match(/^\s*:/, false)) return ret("variable-2", "variable-definition");
	            return ret("variable-2", "variable");
	          } else if (stream.match(/^\w+-/)) {
	            return ret("meta", "meta");
	          }
	        } else if (/[,+>*\/]/.test(ch)) {
	          return ret(null, "select-op");
	        } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
	          return ret("qualifier", "qualifier");
	        } else if (/[:;{}\[\]\(\)]/.test(ch)) {
	          return ret(null, ch);
	        } else if (stream.match(/^[\w-.]+(?=\()/)) {
	          if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {
	            state.tokenize = tokenParenthesized;
	          }

	          return ret("variable callee", "variable");
	        } else if (/[\w\\\-]/.test(ch)) {
	          stream.eatWhile(/[\w\\\-]/);
	          return ret("property", "word");
	        } else {
	          return ret(null, null);
	        }
	      }

	      function tokenString(quote) {
	        return function (stream, state) {
	          var escaped = false,
	              ch;

	          while ((ch = stream.next()) != null) {
	            if (ch == quote && !escaped) {
	              if (quote == ")") stream.backUp(1);
	              break;
	            }

	            escaped = !escaped && ch == "\\";
	          }

	          if (ch == quote || !escaped && quote != ")") state.tokenize = null;
	          return ret("string", "string");
	        };
	      }

	      function tokenParenthesized(stream, state) {
	        stream.next(); // Must be '('

	        if (!stream.match(/^\s*[\"\')]/, false)) state.tokenize = tokenString(")");else state.tokenize = null;
	        return ret(null, "(");
	      } // Context management


	      function Context(type, indent, prev) {
	        this.type = type;
	        this.indent = indent;
	        this.prev = prev;
	      }

	      function pushContext(state, stream, type, indent) {
	        state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
	        return type;
	      }

	      function popContext(state) {
	        if (state.context.prev) state.context = state.context.prev;
	        return state.context.type;
	      }

	      function pass(type, stream, state) {
	        return states[state.context.type](type, stream, state);
	      }

	      function popAndPass(type, stream, state, n) {
	        for (var i = n || 1; i > 0; i--) state.context = state.context.prev;

	        return pass(type, stream, state);
	      } // Parser


	      function wordAsValue(stream) {
	        var word = stream.current().toLowerCase();
	        if (valueKeywords.hasOwnProperty(word)) override = "atom";else if (colorKeywords.hasOwnProperty(word)) override = "keyword";else override = "variable";
	      }

	      var states = {};

	      states.top = function (type, stream, state) {
	        if (type == "{") {
	          return pushContext(state, stream, "block");
	        } else if (type == "}" && state.context.prev) {
	          return popContext(state);
	        } else if (supportsAtComponent && /@component/i.test(type)) {
	          return pushContext(state, stream, "atComponentBlock");
	        } else if (/^@(-moz-)?document$/i.test(type)) {
	          return pushContext(state, stream, "documentTypes");
	        } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
	          return pushContext(state, stream, "atBlock");
	        } else if (/^@(font-face|counter-style)/i.test(type)) {
	          state.stateArg = type;
	          return "restricted_atBlock_before";
	        } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
	          return "keyframes";
	        } else if (type && type.charAt(0) == "@") {
	          return pushContext(state, stream, "at");
	        } else if (type == "hash") {
	          override = "builtin";
	        } else if (type == "word") {
	          override = "tag";
	        } else if (type == "variable-definition") {
	          return "maybeprop";
	        } else if (type == "interpolation") {
	          return pushContext(state, stream, "interpolation");
	        } else if (type == ":") {
	          return "pseudo";
	        } else if (allowNested && type == "(") {
	          return pushContext(state, stream, "parens");
	        }

	        return state.context.type;
	      };

	      states.block = function (type, stream, state) {
	        if (type == "word") {
	          var word = stream.current().toLowerCase();

	          if (propertyKeywords.hasOwnProperty(word)) {
	            override = "property";
	            return "maybeprop";
	          } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
	            override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
	            return "maybeprop";
	          } else if (allowNested) {
	            override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
	            return "block";
	          } else {
	            override += " error";
	            return "maybeprop";
	          }
	        } else if (type == "meta") {
	          return "block";
	        } else if (!allowNested && (type == "hash" || type == "qualifier")) {
	          override = "error";
	          return "block";
	        } else {
	          return states.top(type, stream, state);
	        }
	      };

	      states.maybeprop = function (type, stream, state) {
	        if (type == ":") return pushContext(state, stream, "prop");
	        return pass(type, stream, state);
	      };

	      states.prop = function (type, stream, state) {
	        if (type == ";") return popContext(state);
	        if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
	        if (type == "}" || type == "{") return popAndPass(type, stream, state);
	        if (type == "(") return pushContext(state, stream, "parens");

	        if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
	          override += " error";
	        } else if (type == "word") {
	          wordAsValue(stream);
	        } else if (type == "interpolation") {
	          return pushContext(state, stream, "interpolation");
	        }

	        return "prop";
	      };

	      states.propBlock = function (type, _stream, state) {
	        if (type == "}") return popContext(state);

	        if (type == "word") {
	          override = "property";
	          return "maybeprop";
	        }

	        return state.context.type;
	      };

	      states.parens = function (type, stream, state) {
	        if (type == "{" || type == "}") return popAndPass(type, stream, state);
	        if (type == ")") return popContext(state);
	        if (type == "(") return pushContext(state, stream, "parens");
	        if (type == "interpolation") return pushContext(state, stream, "interpolation");
	        if (type == "word") wordAsValue(stream);
	        return "parens";
	      };

	      states.pseudo = function (type, stream, state) {
	        if (type == "meta") return "pseudo";

	        if (type == "word") {
	          override = "variable-3";
	          return state.context.type;
	        }

	        return pass(type, stream, state);
	      };

	      states.documentTypes = function (type, stream, state) {
	        if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
	          override = "tag";
	          return state.context.type;
	        } else {
	          return states.atBlock(type, stream, state);
	        }
	      };

	      states.atBlock = function (type, stream, state) {
	        if (type == "(") return pushContext(state, stream, "atBlock_parens");
	        if (type == "}" || type == ";") return popAndPass(type, stream, state);
	        if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
	        if (type == "interpolation") return pushContext(state, stream, "interpolation");

	        if (type == "word") {
	          var word = stream.current().toLowerCase();
	          if (word == "only" || word == "not" || word == "and" || word == "or") override = "keyword";else if (mediaTypes.hasOwnProperty(word)) override = "attribute";else if (mediaFeatures.hasOwnProperty(word)) override = "property";else if (mediaValueKeywords.hasOwnProperty(word)) override = "keyword";else if (propertyKeywords.hasOwnProperty(word)) override = "property";else if (nonStandardPropertyKeywords.hasOwnProperty(word)) override = highlightNonStandardPropertyKeywords ? "string-2" : "property";else if (valueKeywords.hasOwnProperty(word)) override = "atom";else if (colorKeywords.hasOwnProperty(word)) override = "keyword";else override = "error";
	        }

	        return state.context.type;
	      };

	      states.atComponentBlock = function (type, stream, state) {
	        if (type == "}") return popAndPass(type, stream, state);
	        if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
	        if (type == "word") override = "error";
	        return state.context.type;
	      };

	      states.atBlock_parens = function (type, stream, state) {
	        if (type == ")") return popContext(state);
	        if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
	        return states.atBlock(type, stream, state);
	      };

	      states.restricted_atBlock_before = function (type, stream, state) {
	        if (type == "{") return pushContext(state, stream, "restricted_atBlock");

	        if (type == "word" && state.stateArg == "@counter-style") {
	          override = "variable";
	          return "restricted_atBlock_before";
	        }

	        return pass(type, stream, state);
	      };

	      states.restricted_atBlock = function (type, stream, state) {
	        if (type == "}") {
	          state.stateArg = null;
	          return popContext(state);
	        }

	        if (type == "word") {
	          if (state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())) override = "error";else override = "property";
	          return "maybeprop";
	        }

	        return "restricted_atBlock";
	      };

	      states.keyframes = function (type, stream, state) {
	        if (type == "word") {
	          override = "variable";
	          return "keyframes";
	        }

	        if (type == "{") return pushContext(state, stream, "top");
	        return pass(type, stream, state);
	      };

	      states.at = function (type, stream, state) {
	        if (type == ";") return popContext(state);
	        if (type == "{" || type == "}") return popAndPass(type, stream, state);
	        if (type == "word") override = "tag";else if (type == "hash") override = "builtin";
	        return "at";
	      };

	      states.interpolation = function (type, stream, state) {
	        if (type == "}") return popContext(state);
	        if (type == "{" || type == ";") return popAndPass(type, stream, state);
	        if (type == "word") override = "variable";else if (type != "variable" && type != "(" && type != ")") override = "error";
	        return "interpolation";
	      };

	      return {
	        startState: function (base) {
	          return {
	            tokenize: null,
	            state: inline ? "block" : "top",
	            stateArg: null,
	            context: new Context(inline ? "block" : "top", base || 0, null)
	          };
	        },
	        token: function (stream, state) {
	          if (!state.tokenize && stream.eatSpace()) return null;
	          var style = (state.tokenize || tokenBase)(stream, state);

	          if (style && typeof style == "object") {
	            type = style[1];
	            style = style[0];
	          }

	          override = style;
	          if (type != "comment") state.state = states[state.state](type, stream, state);
	          return override;
	        },
	        indent: function (state, textAfter) {
	          var cx = state.context,
	              ch = textAfter && textAfter.charAt(0);
	          var indent = cx.indent;
	          if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;

	          if (cx.prev) {
	            if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
	              // Resume indentation from parent context.
	              cx = cx.prev;
	              indent = cx.indent;
	            } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
	              // Dedent relative to current context.
	              indent = Math.max(0, cx.indent - indentUnit);
	            }
	          }

	          return indent;
	        },
	        electricChars: "}",
	        blockCommentStart: "/*",
	        blockCommentEnd: "*/",
	        blockCommentContinue: " * ",
	        lineComment: lineComment,
	        fold: "brace"
	      };
	    });

	    function keySet(array) {
	      var keys = {};

	      for (var i = 0; i < array.length; ++i) {
	        keys[array[i].toLowerCase()] = true;
	      }

	      return keys;
	    }

	    var documentTypes_ = ["domain", "regexp", "url", "url-prefix"],
	        documentTypes = keySet(documentTypes_);
	    var mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"],
	        mediaTypes = keySet(mediaTypes_);
	    var mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid", "orientation", "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio", "pointer", "any-pointer", "hover", "any-hover", "prefers-color-scheme"],
	        mediaFeatures = keySet(mediaFeatures_);
	    var mediaValueKeywords_ = ["landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover", "interlace", "progressive", "dark", "light"],
	        mediaValueKeywords = keySet(mediaValueKeywords_);
	    var propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "all", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backdrop-filter", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-position-x", "background-position-y", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "block-size", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-optical-sizing", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "gap", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline", "inset-inline-end", "inset-inline-start", "isolation", "justify-content", "justify-items", "justify-self", "left", "letter-spacing", "line-break", "line-height", "line-height-step", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "offset", "offset-anchor", "offset-distance", "offset-path", "offset-position", "offset-rotate", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotate", "rotation", "rotation-point", "row-gap", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "scale", "scroll-behavior", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-type", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-skip-ink", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-orientation", "text-outline", "text-overflow", "text-rendering", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "touch-action", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "translate", "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index", // SVG-specific
	    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "paint-order", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"],
	        propertyKeywords = keySet(propertyKeywords_);
	    var nonStandardPropertyKeywords_ = ["border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "margin-block", "margin-block-end", "margin-block-start", "margin-inline", "margin-inline-end", "margin-inline-start", "padding-block", "padding-block-end", "padding-block-start", "padding-inline", "padding-inline-end", "padding-inline-start", "scroll-snap-stop", "scrollbar-3d-light-color", "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-track-color", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "shape-inside", "zoom"],
	        nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);
	    var fontProperties_ = ["font-display", "font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"],
	        fontProperties = keySet(fontProperties_);
	    var counterDescriptors_ = ["additive-symbols", "fallback", "negative", "pad", "prefix", "range", "speak-as", "suffix", "symbols", "system"],
	        counterDescriptors = keySet(counterDescriptors_);
	    var colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"],
	        colorKeywords = keySet(colorKeywords_);
	    var valueKeywords_ = ["above", "absolute", "activeborder", "additive", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "axis-pan", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fill-box", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "japanese-formal", "japanese-informal", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal", "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "manipulation", "match", "matrix", "matrix3d", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "perspective", "pinch-zoom", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "simp-chinese-formal", "simp-chinese-informal", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "stroke-box", "sub", "subpixel-antialiased", "svg_masks", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tamil", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "trad-chinese-formal", "trad-chinese-informal", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"],
	        valueKeywords = keySet(valueKeywords_);
	    var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
	    CodeMirror.registerHelper("hintWords", "css", allWords);

	    function tokenCComment(stream, state) {
	      var maybeEnd = false,
	          ch;

	      while ((ch = stream.next()) != null) {
	        if (maybeEnd && ch == "/") {
	          state.tokenize = null;
	          break;
	        }

	        maybeEnd = ch == "*";
	      }

	      return ["comment", "comment"];
	    }

	    CodeMirror.defineMIME("text/css", {
	      documentTypes: documentTypes,
	      mediaTypes: mediaTypes,
	      mediaFeatures: mediaFeatures,
	      mediaValueKeywords: mediaValueKeywords,
	      propertyKeywords: propertyKeywords,
	      nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	      fontProperties: fontProperties,
	      counterDescriptors: counterDescriptors,
	      colorKeywords: colorKeywords,
	      valueKeywords: valueKeywords,
	      tokenHooks: {
	        "/": function (stream, state) {
	          if (!stream.eat("*")) return false;
	          state.tokenize = tokenCComment;
	          return tokenCComment(stream, state);
	        }
	      },
	      name: "css"
	    });
	    CodeMirror.defineMIME("text/x-scss", {
	      mediaTypes: mediaTypes,
	      mediaFeatures: mediaFeatures,
	      mediaValueKeywords: mediaValueKeywords,
	      propertyKeywords: propertyKeywords,
	      nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	      colorKeywords: colorKeywords,
	      valueKeywords: valueKeywords,
	      fontProperties: fontProperties,
	      allowNested: true,
	      lineComment: "//",
	      tokenHooks: {
	        "/": function (stream, state) {
	          if (stream.eat("/")) {
	            stream.skipToEnd();
	            return ["comment", "comment"];
	          } else if (stream.eat("*")) {
	            state.tokenize = tokenCComment;
	            return tokenCComment(stream, state);
	          } else {
	            return ["operator", "operator"];
	          }
	        },
	        ":": function (stream) {
	          if (stream.match(/^\s*\{/, false)) return [null, null];
	          return false;
	        },
	        "$": function (stream) {
	          stream.match(/^[\w-]+/);
	          if (stream.match(/^\s*:/, false)) return ["variable-2", "variable-definition"];
	          return ["variable-2", "variable"];
	        },
	        "#": function (stream) {
	          if (!stream.eat("{")) return false;
	          return [null, "interpolation"];
	        }
	      },
	      name: "css",
	      helperType: "scss"
	    });
	    CodeMirror.defineMIME("text/x-less", {
	      mediaTypes: mediaTypes,
	      mediaFeatures: mediaFeatures,
	      mediaValueKeywords: mediaValueKeywords,
	      propertyKeywords: propertyKeywords,
	      nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	      colorKeywords: colorKeywords,
	      valueKeywords: valueKeywords,
	      fontProperties: fontProperties,
	      allowNested: true,
	      lineComment: "//",
	      tokenHooks: {
	        "/": function (stream, state) {
	          if (stream.eat("/")) {
	            stream.skipToEnd();
	            return ["comment", "comment"];
	          } else if (stream.eat("*")) {
	            state.tokenize = tokenCComment;
	            return tokenCComment(stream, state);
	          } else {
	            return ["operator", "operator"];
	          }
	        },
	        "@": function (stream) {
	          if (stream.eat("{")) return [null, "interpolation"];
	          if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
	          stream.eatWhile(/[\w\\\-]/);
	          if (stream.match(/^\s*:/, false)) return ["variable-2", "variable-definition"];
	          return ["variable-2", "variable"];
	        },
	        "&": function () {
	          return ["atom", "atom"];
	        }
	      },
	      name: "css",
	      helperType: "less"
	    });
	    CodeMirror.defineMIME("text/x-gss", {
	      documentTypes: documentTypes,
	      mediaTypes: mediaTypes,
	      mediaFeatures: mediaFeatures,
	      propertyKeywords: propertyKeywords,
	      nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	      fontProperties: fontProperties,
	      counterDescriptors: counterDescriptors,
	      colorKeywords: colorKeywords,
	      valueKeywords: valueKeywords,
	      supportsAtComponent: true,
	      tokenHooks: {
	        "/": function (stream, state) {
	          if (!stream.eat("*")) return false;
	          state.tokenize = tokenCComment;
	          return tokenCComment(stream, state);
	        }
	      },
	      name: "css",
	      helperType: "gss"
	    });
	  });
	});

	var searchcursor = createCommonjsModule(function (module, exports) {
	  // CodeMirror, copyright (c) by Marijn Haverbeke and others
	  // Distributed under an MIT license: https://codemirror.net/LICENSE
	  (function (mod) {
	    mod(codemirror);
	  })(function (CodeMirror) {

	    var Pos = CodeMirror.Pos;

	    function regexpFlags(regexp) {
	      var flags = regexp.flags;
	      return flags != null ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");
	    }

	    function ensureFlags(regexp, flags) {
	      var current = regexpFlags(regexp),
	          target = current;

	      for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1) target += flags.charAt(i);

	      return current == target ? regexp : new RegExp(regexp.source, target);
	    }

	    function maybeMultiline(regexp) {
	      return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source);
	    }

	    function searchRegexpForward(doc, regexp, start) {
	      regexp = ensureFlags(regexp, "g");

	      for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
	        regexp.lastIndex = ch;
	        var string = doc.getLine(line),
	            match = regexp.exec(string);
	        if (match) return {
	          from: Pos(line, match.index),
	          to: Pos(line, match.index + match[0].length),
	          match: match
	        };
	      }
	    }

	    function searchRegexpForwardMultiline(doc, regexp, start) {
	      if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start);
	      regexp = ensureFlags(regexp, "gm");
	      var string,
	          chunk = 1;

	      for (var line = start.line, last = doc.lastLine(); line <= last;) {
	        // This grows the search buffer in exponentially-sized chunks
	        // between matches, so that nearby matches are fast and don't
	        // require concatenating the whole document (in case we're
	        // searching for something that has tons of matches), but at the
	        // same time, the amount of retries is limited.
	        for (var i = 0; i < chunk; i++) {
	          if (line > last) break;
	          var curLine = doc.getLine(line++);
	          string = string == null ? curLine : string + "\n" + curLine;
	        }

	        chunk = chunk * 2;
	        regexp.lastIndex = start.ch;
	        var match = regexp.exec(string);

	        if (match) {
	          var before = string.slice(0, match.index).split("\n"),
	              inside = match[0].split("\n");
	          var startLine = start.line + before.length - 1,
	              startCh = before[before.length - 1].length;
	          return {
	            from: Pos(startLine, startCh),
	            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
	            match: match
	          };
	        }
	      }
	    }

	    function lastMatchIn(string, regexp, endMargin) {
	      var match,
	          from = 0;

	      while (from <= string.length) {
	        regexp.lastIndex = from;
	        var newMatch = regexp.exec(string);
	        if (!newMatch) break;
	        var end = newMatch.index + newMatch[0].length;
	        if (end > string.length - endMargin) break;
	        if (!match || end > match.index + match[0].length) match = newMatch;
	        from = newMatch.index + 1;
	      }

	      return match;
	    }

	    function searchRegexpBackward(doc, regexp, start) {
	      regexp = ensureFlags(regexp, "g");

	      for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
	        var string = doc.getLine(line);
	        var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch);
	        if (match) return {
	          from: Pos(line, match.index),
	          to: Pos(line, match.index + match[0].length),
	          match: match
	        };
	      }
	    }

	    function searchRegexpBackwardMultiline(doc, regexp, start) {
	      if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start);
	      regexp = ensureFlags(regexp, "gm");
	      var string,
	          chunkSize = 1,
	          endMargin = doc.getLine(start.line).length - start.ch;

	      for (var line = start.line, first = doc.firstLine(); line >= first;) {
	        for (var i = 0; i < chunkSize && line >= first; i++) {
	          var curLine = doc.getLine(line--);
	          string = string == null ? curLine : curLine + "\n" + string;
	        }

	        chunkSize *= 2;
	        var match = lastMatchIn(string, regexp, endMargin);

	        if (match) {
	          var before = string.slice(0, match.index).split("\n"),
	              inside = match[0].split("\n");
	          var startLine = line + before.length,
	              startCh = before[before.length - 1].length;
	          return {
	            from: Pos(startLine, startCh),
	            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
	            match: match
	          };
	        }
	      }
	    }

	    var doFold, noFold;

	    if (String.prototype.normalize) {
	      doFold = function (str) {
	        return str.normalize("NFD").toLowerCase();
	      };

	      noFold = function (str) {
	        return str.normalize("NFD");
	      };
	    } else {
	      doFold = function (str) {
	        return str.toLowerCase();
	      };

	      noFold = function (str) {
	        return str;
	      };
	    } // Maps a position in a case-folded line back to a position in the original line
	    // (compensating for codepoints increasing in number during folding)


	    function adjustPos(orig, folded, pos, foldFunc) {
	      if (orig.length == folded.length) return pos;

	      for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {
	        if (min == max) return min;
	        var mid = min + max >> 1;
	        var len = foldFunc(orig.slice(0, mid)).length;
	        if (len == pos) return mid;else if (len > pos) max = mid;else min = mid + 1;
	      }
	    }

	    function searchStringForward(doc, query, start, caseFold) {
	      // Empty string would match anything and never progress, so we
	      // define it to match nothing instead.
	      if (!query.length) return null;
	      var fold = caseFold ? doFold : noFold;
	      var lines = fold(query).split(/\r|\n\r?/);

	      search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
	        var orig = doc.getLine(line).slice(ch),
	            string = fold(orig);

	        if (lines.length == 1) {
	          var found = string.indexOf(lines[0]);
	          if (found == -1) continue search;
	          var start = adjustPos(orig, string, found, fold) + ch;
	          return {
	            from: Pos(line, adjustPos(orig, string, found, fold) + ch),
	            to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)
	          };
	        } else {
	          var cutFrom = string.length - lines[0].length;
	          if (string.slice(cutFrom) != lines[0]) continue search;

	          for (var i = 1; i < lines.length - 1; i++) if (fold(doc.getLine(line + i)) != lines[i]) continue search;

	          var end = doc.getLine(line + lines.length - 1),
	              endString = fold(end),
	              lastLine = lines[lines.length - 1];
	          if (endString.slice(0, lastLine.length) != lastLine) continue search;
	          return {
	            from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
	            to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))
	          };
	        }
	      }
	    }

	    function searchStringBackward(doc, query, start, caseFold) {
	      if (!query.length) return null;
	      var fold = caseFold ? doFold : noFold;
	      var lines = fold(query).split(/\r|\n\r?/);

	      search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
	        var orig = doc.getLine(line);
	        if (ch > -1) orig = orig.slice(0, ch);
	        var string = fold(orig);

	        if (lines.length == 1) {
	          var found = string.lastIndexOf(lines[0]);
	          if (found == -1) continue search;
	          return {
	            from: Pos(line, adjustPos(orig, string, found, fold)),
	            to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))
	          };
	        } else {
	          var lastLine = lines[lines.length - 1];
	          if (string.slice(0, lastLine.length) != lastLine) continue search;

	          for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++) if (fold(doc.getLine(start + i)) != lines[i]) continue search;

	          var top = doc.getLine(line + 1 - lines.length),
	              topString = fold(top);
	          if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search;
	          return {
	            from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
	            to: Pos(line, adjustPos(orig, string, lastLine.length, fold))
	          };
	        }
	      }
	    }

	    function SearchCursor(doc, query, pos, options) {
	      this.atOccurrence = false;
	      this.doc = doc;
	      pos = pos ? doc.clipPos(pos) : Pos(0, 0);
	      this.pos = {
	        from: pos,
	        to: pos
	      };
	      var caseFold;

	      if (typeof options == "object") {
	        caseFold = options.caseFold;
	      } else {
	        // Backwards compat for when caseFold was the 4th argument
	        caseFold = options;
	        options = null;
	      }

	      if (typeof query == "string") {
	        if (caseFold == null) caseFold = false;

	        this.matches = function (reverse, pos) {
	          return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold);
	        };
	      } else {
	        query = ensureFlags(query, "gm");
	        if (!options || options.multiline !== false) this.matches = function (reverse, pos) {
	          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos);
	        };else this.matches = function (reverse, pos) {
	          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos);
	        };
	      }
	    }

	    SearchCursor.prototype = {
	      findNext: function () {
	        return this.find(false);
	      },
	      findPrevious: function () {
	        return this.find(true);
	      },
	      find: function (reverse) {
	        var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to)); // Implements weird auto-growing behavior on null-matches for
	        // backwards-compatibility with the vim code (unfortunately)

	        while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {
	          if (reverse) {
	            if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1);else if (result.from.line == this.doc.firstLine()) result = null;else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)));
	          } else {
	            if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1);else if (result.to.line == this.doc.lastLine()) result = null;else result = this.matches(reverse, Pos(result.to.line + 1, 0));
	          }
	        }

	        if (result) {
	          this.pos = result;
	          this.atOccurrence = true;
	          return this.pos.match || true;
	        } else {
	          var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
	          this.pos = {
	            from: end,
	            to: end
	          };
	          return this.atOccurrence = false;
	        }
	      },
	      from: function () {
	        if (this.atOccurrence) return this.pos.from;
	      },
	      to: function () {
	        if (this.atOccurrence) return this.pos.to;
	      },
	      replace: function (newText, origin) {
	        if (!this.atOccurrence) return;
	        var lines = CodeMirror.splitLines(newText);
	        this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
	        this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
	      }
	    };
	    CodeMirror.defineExtension("getSearchCursor", function (query, pos, caseFold) {
	      return new SearchCursor(this.doc, query, pos, caseFold);
	    });
	    CodeMirror.defineDocExtension("getSearchCursor", function (query, pos, caseFold) {
	      return new SearchCursor(this, query, pos, caseFold);
	    });
	    CodeMirror.defineExtension("selectMatches", function (query, caseFold) {
	      var ranges = [];
	      var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);

	      while (cur.findNext()) {
	        if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
	        ranges.push({
	          anchor: cur.from(),
	          head: cur.to()
	        });
	      }

	      if (ranges.length) this.setSelections(ranges, 0);
	    });
	  });
	});

	var annotatescrollbar = createCommonjsModule(function (module, exports) {
	  // CodeMirror, copyright (c) by Marijn Haverbeke and others
	  // Distributed under an MIT license: https://codemirror.net/LICENSE
	  (function (mod) {
	    mod(codemirror);
	  })(function (CodeMirror) {

	    CodeMirror.defineExtension("annotateScrollbar", function (options) {
	      if (typeof options == "string") options = {
	        className: options
	      };
	      return new Annotation(this, options);
	    });
	    CodeMirror.defineOption("scrollButtonHeight", 0);

	    function Annotation(cm, options) {
	      this.cm = cm;
	      this.options = options;
	      this.buttonHeight = options.scrollButtonHeight || cm.getOption("scrollButtonHeight");
	      this.annotations = [];
	      this.doRedraw = this.doUpdate = null;
	      this.div = cm.getWrapperElement().appendChild(document.createElement("div"));
	      this.div.style.cssText = "position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none";
	      this.computeScale();

	      function scheduleRedraw(delay) {
	        clearTimeout(self.doRedraw);
	        self.doRedraw = setTimeout(function () {
	          self.redraw();
	        }, delay);
	      }

	      var self = this;
	      cm.on("refresh", this.resizeHandler = function () {
	        clearTimeout(self.doUpdate);
	        self.doUpdate = setTimeout(function () {
	          if (self.computeScale()) scheduleRedraw(20);
	        }, 100);
	      });
	      cm.on("markerAdded", this.resizeHandler);
	      cm.on("markerCleared", this.resizeHandler);
	      if (options.listenForChanges !== false) cm.on("changes", this.changeHandler = function () {
	        scheduleRedraw(250);
	      });
	    }

	    Annotation.prototype.computeScale = function () {
	      var cm = this.cm;
	      var hScale = (cm.getWrapperElement().clientHeight - cm.display.barHeight - this.buttonHeight * 2) / cm.getScrollerElement().scrollHeight;

	      if (hScale != this.hScale) {
	        this.hScale = hScale;
	        return true;
	      }
	    };

	    Annotation.prototype.update = function (annotations) {
	      this.annotations = annotations;
	      this.redraw();
	    };

	    Annotation.prototype.redraw = function (compute) {
	      if (compute !== false) this.computeScale();
	      var cm = this.cm,
	          hScale = this.hScale;
	      var frag = document.createDocumentFragment(),
	          anns = this.annotations;
	      var wrapping = cm.getOption("lineWrapping");
	      var singleLineH = wrapping && cm.defaultTextHeight() * 1.5;
	      var curLine = null,
	          curLineObj = null;

	      function getY(pos, top) {
	        if (curLine != pos.line) {
	          curLine = pos.line;
	          curLineObj = cm.getLineHandle(pos.line);
	          var visual = cm.getLineHandleVisualStart(curLineObj);

	          if (visual != curLineObj) {
	            curLine = cm.getLineNumber(visual);
	            curLineObj = visual;
	          }
	        }

	        if (curLineObj.widgets && curLineObj.widgets.length || wrapping && curLineObj.height > singleLineH) return cm.charCoords(pos, "local")[top ? "top" : "bottom"];
	        var topY = cm.heightAtLine(curLineObj, "local");
	        return topY + (top ? 0 : curLineObj.height);
	      }

	      var lastLine = cm.lastLine();
	      if (cm.display.barWidth) for (var i = 0, nextTop; i < anns.length; i++) {
	        var ann = anns[i];
	        if (ann.to.line > lastLine) continue;
	        var top = nextTop || getY(ann.from, true) * hScale;
	        var bottom = getY(ann.to, false) * hScale;

	        while (i < anns.length - 1) {
	          if (anns[i + 1].to.line > lastLine) break;
	          nextTop = getY(anns[i + 1].from, true) * hScale;
	          if (nextTop > bottom + .9) break;
	          ann = anns[++i];
	          bottom = getY(ann.to, false) * hScale;
	        }

	        if (bottom == top) continue;
	        var height = Math.max(bottom - top, 3);
	        var elt = frag.appendChild(document.createElement("div"));
	        elt.style.cssText = "position: absolute; right: 0px; width: " + Math.max(cm.display.barWidth - 1, 2) + "px; top: " + (top + this.buttonHeight) + "px; height: " + height + "px";
	        elt.className = this.options.className;

	        if (ann.id) {
	          elt.setAttribute("annotation-id", ann.id);
	        }
	      }
	      this.div.textContent = "";
	      this.div.appendChild(frag);
	    };

	    Annotation.prototype.clear = function () {
	      this.cm.off("refresh", this.resizeHandler);
	      this.cm.off("markerAdded", this.resizeHandler);
	      this.cm.off("markerCleared", this.resizeHandler);
	      if (this.changeHandler) this.cm.off("changes", this.changeHandler);
	      this.div.parentNode.removeChild(this.div);
	    };
	  });
	});

	var matchesonscrollbar = createCommonjsModule(function (module, exports) {
	  // CodeMirror, copyright (c) by Marijn Haverbeke and others
	  // Distributed under an MIT license: https://codemirror.net/LICENSE
	  (function (mod) {
	    mod(codemirror, searchcursor, annotatescrollbar);
	  })(function (CodeMirror) {

	    CodeMirror.defineExtension("showMatchesOnScrollbar", function (query, caseFold, options) {
	      if (typeof options == "string") options = {
	        className: options
	      };
	      if (!options) options = {};
	      return new SearchAnnotation(this, query, caseFold, options);
	    });

	    function SearchAnnotation(cm, query, caseFold, options) {
	      this.cm = cm;
	      this.options = options;
	      var annotateOptions = {
	        listenForChanges: false
	      };

	      for (var prop in options) annotateOptions[prop] = options[prop];

	      if (!annotateOptions.className) annotateOptions.className = "CodeMirror-search-match";
	      this.annotation = cm.annotateScrollbar(annotateOptions);
	      this.query = query;
	      this.caseFold = caseFold;
	      this.gap = {
	        from: cm.firstLine(),
	        to: cm.lastLine() + 1
	      };
	      this.matches = [];
	      this.update = null;
	      this.findMatches();
	      this.annotation.update(this.matches);
	      var self = this;
	      cm.on("change", this.changeHandler = function (_cm, change) {
	        self.onChange(change);
	      });
	    }

	    var MAX_MATCHES = 1000;

	    SearchAnnotation.prototype.findMatches = function () {
	      if (!this.gap) return;

	      for (var i = 0; i < this.matches.length; i++) {
	        var match = this.matches[i];
	        if (match.from.line >= this.gap.to) break;
	        if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);
	      }

	      var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), {
	        caseFold: this.caseFold,
	        multiline: this.options.multiline
	      });
	      var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;

	      while (cursor.findNext()) {
	        var match = {
	          from: cursor.from(),
	          to: cursor.to()
	        };
	        if (match.from.line >= this.gap.to) break;
	        this.matches.splice(i++, 0, match);
	        if (this.matches.length > maxMatches) break;
	      }

	      this.gap = null;
	    };

	    function offsetLine(line, changeStart, sizeChange) {
	      if (line <= changeStart) return line;
	      return Math.max(changeStart, line + sizeChange);
	    }

	    SearchAnnotation.prototype.onChange = function (change) {
	      var startLine = change.from.line;
	      var endLine = CodeMirror.changeEnd(change).line;
	      var sizeChange = endLine - change.to.line;

	      if (this.gap) {
	        this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);
	        this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);
	      } else {
	        this.gap = {
	          from: change.from.line,
	          to: endLine + 1
	        };
	      }

	      if (sizeChange) for (var i = 0; i < this.matches.length; i++) {
	        var match = this.matches[i];
	        var newFrom = offsetLine(match.from.line, startLine, sizeChange);
	        if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);
	        var newTo = offsetLine(match.to.line, startLine, sizeChange);
	        if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);
	      }
	      clearTimeout(this.update);
	      var self = this;
	      this.update = setTimeout(function () {
	        self.updateAfterChange();
	      }, 250);
	    };

	    SearchAnnotation.prototype.updateAfterChange = function () {
	      this.findMatches();
	      this.annotation.update(this.matches);
	    };

	    SearchAnnotation.prototype.clear = function () {
	      this.cm.off("change", this.changeHandler);
	      this.annotation.clear();
	    };
	  });
	});

	var matchHighlighter = createCommonjsModule(function (module, exports) {
	  // CodeMirror, copyright (c) by Marijn Haverbeke and others
	  // Distributed under an MIT license: https://codemirror.net/LICENSE
	  // Highlighting text that matches the selection
	  //
	  // Defines an option highlightSelectionMatches, which, when enabled,
	  // will style strings that match the selection throughout the
	  // document.
	  //
	  // The option can be set to true to simply enable it, or to a
	  // {minChars, style, wordsOnly, showToken, delay} object to explicitly
	  // configure it. minChars is the minimum amount of characters that should be
	  // selected for the behavior to occur, and style is the token style to
	  // apply to the matches. This will be prefixed by "cm-" to create an
	  // actual CSS class name. If wordsOnly is enabled, the matches will be
	  // highlighted only if the selected text is a word. showToken, when enabled,
	  // will cause the current token to be highlighted when nothing is selected.
	  // delay is used to specify how much time to wait, in milliseconds, before
	  // highlighting the matches. If annotateScrollbar is enabled, the occurrences
	  // will be highlighted on the scrollbar via the matchesonscrollbar addon.
	  (function (mod) {
	    mod(codemirror, matchesonscrollbar);
	  })(function (CodeMirror) {

	    var defaults = {
	      style: "matchhighlight",
	      minChars: 2,
	      delay: 100,
	      wordsOnly: false,
	      annotateScrollbar: false,
	      showToken: false,
	      trim: true
	    };

	    function State(options) {
	      this.options = {};

	      for (var name in defaults) this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name];

	      this.overlay = this.timeout = null;
	      this.matchesonscroll = null;
	      this.active = false;
	    }

	    CodeMirror.defineOption("highlightSelectionMatches", false, function (cm, val, old) {
	      if (old && old != CodeMirror.Init) {
	        removeOverlay(cm);
	        clearTimeout(cm.state.matchHighlighter.timeout);
	        cm.state.matchHighlighter = null;
	        cm.off("cursorActivity", cursorActivity);
	        cm.off("focus", onFocus);
	      }

	      if (val) {
	        var state = cm.state.matchHighlighter = new State(val);

	        if (cm.hasFocus()) {
	          state.active = true;
	          highlightMatches(cm);
	        } else {
	          cm.on("focus", onFocus);
	        }

	        cm.on("cursorActivity", cursorActivity);
	      }
	    });

	    function cursorActivity(cm) {
	      var state = cm.state.matchHighlighter;
	      if (state.active || cm.hasFocus()) scheduleHighlight(cm, state);
	    }

	    function onFocus(cm) {
	      var state = cm.state.matchHighlighter;

	      if (!state.active) {
	        state.active = true;
	        scheduleHighlight(cm, state);
	      }
	    }

	    function scheduleHighlight(cm, state) {
	      clearTimeout(state.timeout);
	      state.timeout = setTimeout(function () {
	        highlightMatches(cm);
	      }, state.options.delay);
	    }

	    function addOverlay(cm, query, hasBoundary, style) {
	      var state = cm.state.matchHighlighter;
	      cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));

	      if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {
	        var searchFor = hasBoundary ? new RegExp((/\w/.test(query.charAt(0)) ? "\\b" : "") + query.replace(/[\\\[.+*?(){|^$]/g, "\\$&") + (/\w/.test(query.charAt(query.length - 1)) ? "\\b" : "")) : query;
	        state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false, {
	          className: "CodeMirror-selection-highlight-scrollbar"
	        });
	      }
	    }

	    function removeOverlay(cm) {
	      var state = cm.state.matchHighlighter;

	      if (state.overlay) {
	        cm.removeOverlay(state.overlay);
	        state.overlay = null;

	        if (state.matchesonscroll) {
	          state.matchesonscroll.clear();
	          state.matchesonscroll = null;
	        }
	      }
	    }

	    function highlightMatches(cm) {
	      cm.operation(function () {
	        var state = cm.state.matchHighlighter;
	        removeOverlay(cm);

	        if (!cm.somethingSelected() && state.options.showToken) {
	          var re = state.options.showToken === true ? /[\w$]/ : state.options.showToken;
	          var cur = cm.getCursor(),
	              line = cm.getLine(cur.line),
	              start = cur.ch,
	              end = start;

	          while (start && re.test(line.charAt(start - 1))) --start;

	          while (end < line.length && re.test(line.charAt(end))) ++end;

	          if (start < end) addOverlay(cm, line.slice(start, end), re, state.options.style);
	          return;
	        }

	        var from = cm.getCursor("from"),
	            to = cm.getCursor("to");
	        if (from.line != to.line) return;
	        if (state.options.wordsOnly && !isWord(cm, from, to)) return;
	        var selection = cm.getRange(from, to);
	        if (state.options.trim) selection = selection.replace(/^\s+|\s+$/g, "");
	        if (selection.length >= state.options.minChars) addOverlay(cm, selection, false, state.options.style);
	      });
	    }

	    function isWord(cm, from, to) {
	      var str = cm.getRange(from, to);

	      if (str.match(/^\w+$/) !== null) {
	        if (from.ch > 0) {
	          var pos = {
	            line: from.line,
	            ch: from.ch - 1
	          };
	          var chr = cm.getRange(pos, from);
	          if (chr.match(/\W/) === null) return false;
	        }

	        if (to.ch < cm.getLine(from.line).length) {
	          var pos = {
	            line: to.line,
	            ch: to.ch + 1
	          };
	          var chr = cm.getRange(to, pos);
	          if (chr.match(/\W/) === null) return false;
	        }

	        return true;
	      } else return false;
	    }

	    function boundariesAround(stream, re) {
	      return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) && (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));
	    }

	    function makeOverlay(query, hasBoundary, style) {
	      return {
	        token: function (stream) {
	          if (stream.match(query) && (!hasBoundary || boundariesAround(stream, hasBoundary))) return style;
	          stream.next();
	          stream.skipTo(query.charAt(0)) || stream.skipToEnd();
	        }
	      };
	    }
	  });
	});

	var matchbrackets = createCommonjsModule(function (module, exports) {
	  // CodeMirror, copyright (c) by Marijn Haverbeke and others
	  // Distributed under an MIT license: https://codemirror.net/LICENSE
	  (function (mod) {
	    mod(codemirror);
	  })(function (CodeMirror) {
	    var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
	    var Pos = CodeMirror.Pos;
	    var matching = {
	      "(": ")>",
	      ")": "(<",
	      "[": "]>",
	      "]": "[<",
	      "{": "}>",
	      "}": "{<",
	      "<": ">>",
	      ">": "<<"
	    };

	    function bracketRegex(config) {
	      return config && config.bracketRegex || /[(){}[\]]/;
	    }

	    function findMatchingBracket(cm, where, config) {
	      var line = cm.getLineHandle(where.line),
	          pos = where.ch - 1;
	      var afterCursor = config && config.afterCursor;
	      if (afterCursor == null) afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);
	      var re = bracketRegex(config); // A cursor is defined as between two characters, but in in vim command mode
	      // (i.e. not insert mode), the cursor is visually represented as a
	      // highlighted box on top of the 2nd character. Otherwise, we allow matches
	      // from before or after the cursor.

	      var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
	      if (!match) return null;
	      var dir = match.charAt(1) == ">" ? 1 : -1;
	      if (config && config.strict && dir > 0 != (pos == where.ch)) return null;
	      var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));
	      var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);
	      if (found == null) return null;
	      return {
	        from: Pos(where.line, pos),
	        to: found && found.pos,
	        match: found && found.ch == match.charAt(0),
	        forward: dir > 0
	      };
	    } // bracketRegex is used to specify which type of bracket to scan
	    // should be a regexp, e.g. /[[\]]/
	    //
	    // Note: If "where" is on an open bracket, then this bracket is ignored.
	    //
	    // Returns false when no bracket was found, null when it reached
	    // maxScanLines and gave up


	    function scanForBracket(cm, where, dir, style, config) {
	      var maxScanLen = config && config.maxScanLineLength || 10000;
	      var maxScanLines = config && config.maxScanLines || 1000;
	      var stack = [];
	      var re = bracketRegex(config);
	      var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);

	      for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
	        var line = cm.getLine(lineNo);
	        if (!line) continue;
	        var pos = dir > 0 ? 0 : line.length - 1,
	            end = dir > 0 ? line.length : -1;
	        if (line.length > maxScanLen) continue;
	        if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);

	        for (; pos != end; pos += dir) {
	          var ch = line.charAt(pos);

	          if (re.test(ch) && (style === undefined || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || "") == (style || ""))) {
	            var match = matching[ch];
	            if (match && match.charAt(1) == ">" == dir > 0) stack.push(ch);else if (!stack.length) return {
	              pos: Pos(lineNo, pos),
	              ch: ch
	            };else stack.pop();
	          }
	        }
	      }

	      return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
	    }

	    function matchBrackets(cm, autoclear, config) {
	      // Disable brace matching in long lines, since it'll cause hugely slow updates
	      var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000,
	          highlightNonMatching = config && config.highlightNonMatching;
	      var marks = [],
	          ranges = cm.listSelections();

	      for (var i = 0; i < ranges.length; i++) {
	        var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);

	        if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {
	          var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
	          marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {
	            className: style
	          }));
	          if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen) marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {
	            className: style
	          }));
	        }
	      }

	      if (marks.length) {
	        // Kludge to work around the IE bug from issue #1193, where text
	        // input stops going to the textarea whenever this fires.
	        if (ie_lt8 && cm.state.focused) cm.focus();

	        var clear = function () {
	          cm.operation(function () {
	            for (var i = 0; i < marks.length; i++) marks[i].clear();
	          });
	        };

	        if (autoclear) setTimeout(clear, 800);else return clear;
	      }
	    }

	    function doMatchBrackets(cm) {
	      cm.operation(function () {
	        if (cm.state.matchBrackets.currentlyHighlighted) {
	          cm.state.matchBrackets.currentlyHighlighted();
	          cm.state.matchBrackets.currentlyHighlighted = null;
	        }

	        cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
	      });
	    }

	    function clearHighlighted(cm) {
	      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
	        cm.state.matchBrackets.currentlyHighlighted();
	        cm.state.matchBrackets.currentlyHighlighted = null;
	      }
	    }

	    CodeMirror.defineOption("matchBrackets", false, function (cm, val, old) {
	      if (old && old != CodeMirror.Init) {
	        cm.off("cursorActivity", doMatchBrackets);
	        cm.off("focus", doMatchBrackets);
	        cm.off("blur", clearHighlighted);
	        clearHighlighted(cm);
	      }

	      if (val) {
	        cm.state.matchBrackets = typeof val == "object" ? val : {};
	        cm.on("cursorActivity", doMatchBrackets);
	        cm.on("focus", doMatchBrackets);
	        cm.on("blur", clearHighlighted);
	      }
	    });
	    CodeMirror.defineExtension("matchBrackets", function () {
	      matchBrackets(this, true);
	    });
	    CodeMirror.defineExtension("findMatchingBracket", function (pos, config, oldConfig) {
	      // Backwards-compatibility kludge
	      if (oldConfig || typeof config == "boolean") {
	        if (!oldConfig) {
	          config = config ? {
	            strict: true
	          } : null;
	        } else {
	          oldConfig.strict = config;
	          config = oldConfig;
	        }
	      }

	      return findMatchingBracket(this, pos, config);
	    });
	    CodeMirror.defineExtension("scanForBracket", function (pos, dir, style, config) {
	      return scanForBracket(this, pos, dir, style, config);
	    });
	  });
	});

	var closebrackets = createCommonjsModule(function (module, exports) {
	  // CodeMirror, copyright (c) by Marijn Haverbeke and others
	  // Distributed under an MIT license: https://codemirror.net/LICENSE
	  (function (mod) {
	    mod(codemirror);
	  })(function (CodeMirror) {
	    var defaults = {
	      pairs: "()[]{}''\"\"",
	      closeBefore: ")]}'\":;>",
	      triples: "",
	      explode: "[]{}"
	    };
	    var Pos = CodeMirror.Pos;
	    CodeMirror.defineOption("autoCloseBrackets", false, function (cm, val, old) {
	      if (old && old != CodeMirror.Init) {
	        cm.removeKeyMap(keyMap);
	        cm.state.closeBrackets = null;
	      }

	      if (val) {
	        ensureBound(getOption(val, "pairs"));
	        cm.state.closeBrackets = val;
	        cm.addKeyMap(keyMap);
	      }
	    });

	    function getOption(conf, name) {
	      if (name == "pairs" && typeof conf == "string") return conf;
	      if (typeof conf == "object" && conf[name] != null) return conf[name];
	      return defaults[name];
	    }

	    var keyMap = {
	      Backspace: handleBackspace,
	      Enter: handleEnter
	    };

	    function ensureBound(chars) {
	      for (var i = 0; i < chars.length; i++) {
	        var ch = chars.charAt(i),
	            key = "'" + ch + "'";
	        if (!keyMap[key]) keyMap[key] = handler(ch);
	      }
	    }

	    ensureBound(defaults.pairs + "`");

	    function handler(ch) {
	      return function (cm) {
	        return handleChar(cm, ch);
	      };
	    }

	    function getConfig(cm) {
	      var deflt = cm.state.closeBrackets;
	      if (!deflt || deflt.override) return deflt;
	      var mode = cm.getModeAt(cm.getCursor());
	      return mode.closeBrackets || deflt;
	    }

	    function handleBackspace(cm) {
	      var conf = getConfig(cm);
	      if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;
	      var pairs = getOption(conf, "pairs");
	      var ranges = cm.listSelections();

	      for (var i = 0; i < ranges.length; i++) {
	        if (!ranges[i].empty()) return CodeMirror.Pass;
	        var around = charsAround(cm, ranges[i].head);
	        if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
	      }

	      for (var i = ranges.length - 1; i >= 0; i--) {
	        var cur = ranges[i].head;
	        cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
	      }
	    }

	    function handleEnter(cm) {
	      var conf = getConfig(cm);
	      var explode = conf && getOption(conf, "explode");
	      if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;
	      var ranges = cm.listSelections();

	      for (var i = 0; i < ranges.length; i++) {
	        if (!ranges[i].empty()) return CodeMirror.Pass;
	        var around = charsAround(cm, ranges[i].head);
	        if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
	      }

	      cm.operation(function () {
	        var linesep = cm.lineSeparator() || "\n";
	        cm.replaceSelection(linesep + linesep, null);
	        moveSel(cm, -1);
	        ranges = cm.listSelections();

	        for (var i = 0; i < ranges.length; i++) {
	          var line = ranges[i].head.line;
	          cm.indentLine(line, null, true);
	          cm.indentLine(line + 1, null, true);
	        }
	      });
	    }

	    function moveSel(cm, dir) {
	      var newRanges = [],
	          ranges = cm.listSelections(),
	          primary = 0;

	      for (var i = 0; i < ranges.length; i++) {
	        var range = ranges[i];
	        if (range.head == cm.getCursor()) primary = i;
	        var pos = range.head.ch || dir > 0 ? {
	          line: range.head.line,
	          ch: range.head.ch + dir
	        } : {
	          line: range.head.line - 1
	        };
	        newRanges.push({
	          anchor: pos,
	          head: pos
	        });
	      }

	      cm.setSelections(newRanges, primary);
	    }

	    function contractSelection(sel) {
	      var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
	      return {
	        anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
	        head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))
	      };
	    }

	    function handleChar(cm, ch) {
	      var conf = getConfig(cm);
	      if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;
	      var pairs = getOption(conf, "pairs");
	      var pos = pairs.indexOf(ch);
	      if (pos == -1) return CodeMirror.Pass;
	      var closeBefore = getOption(conf, "closeBefore");
	      var triples = getOption(conf, "triples");
	      var identical = pairs.charAt(pos + 1) == ch;
	      var ranges = cm.listSelections();
	      var opening = pos % 2 == 0;
	      var type;

	      for (var i = 0; i < ranges.length; i++) {
	        var range = ranges[i],
	            cur = range.head,
	            curType;
	        var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));

	        if (opening && !range.empty()) {
	          curType = "surround";
	        } else if ((identical || !opening) && next == ch) {
	          if (identical && stringStartsAfter(cm, cur)) curType = "both";else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch) curType = "skipThree";else curType = "skip";
	        } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
	          if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;
	          curType = "addFour";
	        } else if (identical) {
	          var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
	          if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = "both";else return CodeMirror.Pass;
	        } else if (opening && (next.length === 0 || /\s/.test(next) || closeBefore.indexOf(next) > -1)) {
	          curType = "both";
	        } else {
	          return CodeMirror.Pass;
	        }

	        if (!type) type = curType;else if (type != curType) return CodeMirror.Pass;
	      }

	      var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
	      var right = pos % 2 ? ch : pairs.charAt(pos + 1);
	      cm.operation(function () {
	        if (type == "skip") {
	          moveSel(cm, 1);
	        } else if (type == "skipThree") {
	          moveSel(cm, 3);
	        } else if (type == "surround") {
	          var sels = cm.getSelections();

	          for (var i = 0; i < sels.length; i++) sels[i] = left + sels[i] + right;

	          cm.replaceSelections(sels, "around");
	          sels = cm.listSelections().slice();

	          for (var i = 0; i < sels.length; i++) sels[i] = contractSelection(sels[i]);

	          cm.setSelections(sels);
	        } else if (type == "both") {
	          cm.replaceSelection(left + right, null);
	          cm.triggerElectric(left + right);
	          moveSel(cm, -1);
	        } else if (type == "addFour") {
	          cm.replaceSelection(left + left + left + left, "before");
	          moveSel(cm, 1);
	        }
	      });
	    }

	    function charsAround(cm, pos) {
	      var str = cm.getRange(Pos(pos.line, pos.ch - 1), Pos(pos.line, pos.ch + 1));
	      return str.length == 2 ? str : null;
	    }

	    function stringStartsAfter(cm, pos) {
	      var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
	      return /\bstring/.test(token.type) && token.start == pos.ch && (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)));
	    }
	  });
	});

	//
	var script = {
	  props: {
	    mode: {
	      type: String,
	      "default": 'text/html'
	    },
	    value: {
	      type: String,
	      "default": ''
	    },
	    attrs: {
	      type: Object,
	      "default": function _default() {
	        return {};
	      }
	    }
	  },
	  watch: {
	    value: function value(v) {
	      this.setValue(v);
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.event = this.attrs.lazy ? "blur" : "change";
	    this.editor = codemirror(this.$el, {
	      autoCloseBrackets: true,
	      autoCloseTags: true,
	      autofocus: false,
	      dragDrop: false,
	      indentUnit: 4,
	      indentWithTabs: false,
	      lineNumbers: true,
	      lineWrapping: true,
	      matchBrackets: true,
	      matchTags: true,
	      mode: this.mode,
	      tabSize: 4,
	      viewportMargin: 2
	      /*
	      extraKeys: {
	          'F11': cm => cm.setOption('fullScreen', !cm.getOption('fullScreen')),
	          'Esc': cm => cm.getOption('fullScreen') && cm.setOption('fullScreen', false)
	      }
	      */

	    });
	    this.setValue(this.value);

	    if (this.attrs.height) {
	      this.$nextTick(function () {
	        return _this.editor.setSize(null, _this.attrs.height);
	      });
	    }

	    this.editor.on(this.event, function () {
	      var value = _this.editor.getValue();

	      if (value !== _this.value) {
	        _this.$emit('input', value);
	      }
	    });
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.editor.off(this.event);
	  },
	  methods: {
	    setValue: function setValue(str) {
	      if (str === void 0) {
	        str = '';
	      }

	      this.editor && this.editor.getValue() !== str && this.editor.setValue(str);
	      this.editor.refresh();
	    },
	    refresh: function refresh() {
	      this.editor.refresh();
	    }
	  }
	};

	function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	    if (typeof shadowMode !== 'boolean') {
	        createInjectorSSR = createInjector;
	        createInjector = shadowMode;
	        shadowMode = false;
	    }
	    // Vue.extend constructor export interop.
	    const options = typeof script === 'function' ? script.options : script;
	    // render functions
	    if (template && template.render) {
	        options.render = template.render;
	        options.staticRenderFns = template.staticRenderFns;
	        options._compiled = true;
	        // functional template
	        if (isFunctionalTemplate) {
	            options.functional = true;
	        }
	    }
	    // scopedId
	    if (scopeId) {
	        options._scopeId = scopeId;
	    }
	    let hook;
	    if (moduleIdentifier) {
	        // server build
	        hook = function (context) {
	            // 2.3 injection
	            context =
	                context || // cached call
	                    (this.$vnode && this.$vnode.ssrContext) || // stateful
	                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
	            // 2.2 with runInNewContext: true
	            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	                context = __VUE_SSR_CONTEXT__;
	            }
	            // inject component styles
	            if (style) {
	                style.call(this, createInjectorSSR(context));
	            }
	            // register component module identifier for async chunk inference
	            if (context && context._registeredComponents) {
	                context._registeredComponents.add(moduleIdentifier);
	            }
	        };
	        // used by ssr in case component is cached and beforeCreate
	        // never gets called
	        options._ssrRegister = hook;
	    }
	    else if (style) {
	        hook = shadowMode
	            ? function (context) {
	                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
	            }
	            : function (context) {
	                style.call(this, createInjector(context));
	            };
	    }
	    if (hook) {
	        if (options.functional) {
	            // register for functional component in vue file
	            const originalRender = options.render;
	            options.render = function renderWithStyleInjection(h, context) {
	                hook.call(context);
	                return originalRender(h, context);
	            };
	        }
	        else {
	            // inject component registration as beforeCreate hook
	            const existing = options.beforeCreate;
	            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	    }
	    return script;
	}

	const isOldIE = typeof navigator !== 'undefined' &&
	    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
	function createInjector(context) {
	    return (id, style) => addStyle(id, style);
	}
	let HEAD;
	const styles = {};
	function addStyle(id, css) {
	    const group = isOldIE ? css.media || 'default' : id;
	    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });
	    if (!style.ids.has(id)) {
	        style.ids.add(id);
	        let code = css.source;
	        if (css.map) {
	            // https://developer.chrome.com/devtools/docs/javascript-debugging
	            // this makes source maps inside style tags work properly in Chrome
	            code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
	            // http://stackoverflow.com/a/26603875
	            code +=
	                '\n/*# sourceMappingURL=data:application/json;base64,' +
	                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
	                    ' */';
	        }
	        if (!style.element) {
	            style.element = document.createElement('style');
	            style.element.type = 'text/css';
	            if (css.media)
	                style.element.setAttribute('media', css.media);
	            if (HEAD === undefined) {
	                HEAD = document.head || document.getElementsByTagName('head')[0];
	            }
	            HEAD.appendChild(style.element);
	        }
	        if ('styleSheet' in style.element) {
	            style.styles.push(code);
	            style.element.styleSheet.cssText = style.styles
	                .filter(Boolean)
	                .join('\n');
	        }
	        else {
	            const index = style.ids.size - 1;
	            const textNode = document.createTextNode(code);
	            const nodes = style.element.childNodes;
	            if (nodes[index])
	                style.element.removeChild(nodes[index]);
	            if (nodes.length)
	                style.element.insertBefore(textNode, nodes[index]);
	            else
	                style.element.appendChild(textNode);
	        }
	    }
	}

	/* script */
	var __vue_script__ = script;
	/* template */

	var __vue_render__ = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div");
	};

	var __vue_staticRenderFns__ = [];
	__vue_render__._withStripped = true;
	/* style */

	var __vue_inject_styles__ = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-17054bf6_0", {
	    source: "/* BASICS */\n.CodeMirror {\n  /* Set height, width, borders, and global font properties here */\n  font-family: monospace;\n  height: 300px;\n  color: black;\n  direction: ltr;\n}\n\n/* PADDING */\n.CodeMirror-lines {\n  padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  padding: 0 4px; /* Horizontal padding of content */\n}\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  background-color: transparent; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  white-space: nowrap;\n}\n.CodeMirror-guttermarker { color: black;\n}\n.CodeMirror-guttermarker-subtle { color: #999;\n}\n\n/* CURSOR */\n.CodeMirror-cursor {\n  border-left: 1px solid black;\n  border-right: none;\n  width: 0;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.cm-fat-cursor .CodeMirror-cursor {\n  width: auto;\n  border: 0 !important;\n  background: #7e7;\n}\n.cm-fat-cursor div.CodeMirror-cursors {\n  z-index: 1;\n}\n.cm-fat-cursor-mark {\n  background-color: rgba(20, 255, 20, 0.5);\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n}\n.cm-animate-fat-cursor {\n  width: auto;\n  border: 0;\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n  background-color: #7e7;\n}\n@-moz-keyframes blink {\n0% {}\n50% { background-color: transparent;\n}\n100% {}\n}\n@-webkit-keyframes blink {\n0% {}\n50% { background-color: transparent;\n}\n100% {}\n}\n@keyframes blink {\n0% {}\n50% { background-color: transparent;\n}\n100% {}\n}\n\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror-overwrite .CodeMirror-cursor {}\n.cm-tab { display: inline-block; text-decoration: inherit;\n}\n.CodeMirror-rulers {\n  position: absolute;\n  left: 0; right: 0; top: -50px; bottom: 0;\n  overflow: hidden;\n}\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  top: 0; bottom: 0;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n.cm-strikethrough {text-decoration: line-through;}\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable,\n.cm-s-default .cm-punctuation,\n.cm-s-default .cm-property,\n.cm-s-default .cm-operator {}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n.cm-s-default .cm-error {color: #f00;}\n.cm-invalidchar {color: #f00;}\n.CodeMirror-composing { border-bottom: 2px solid;\n}\n\n/* Default styles for common addons */\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3);\n}\n.CodeMirror-activeline-background {background: #e8f2ff;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n.CodeMirror {\n  position: relative;\n  overflow: hidden;\n  background: white;\n}\n.CodeMirror-scroll {\n  overflow: scroll !important; /* Things will break if this is overridden */\n  /* 50px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -50px; margin-right: -50px;\n  padding-bottom: 50px;\n  height: 100%;\n  outline: none; /* Prevent dragging from highlighting the element */\n  position: relative;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 50px solid transparent;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actual scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n  outline: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0; top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0; left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0; bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0; bottom: 0;\n}\n.CodeMirror-gutters {\n  position: absolute; left: 0; top: 0;\n  min-height: 100%;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  display: inline-block;\n  vertical-align: top;\n  margin-bottom: -50px;\n}\n.CodeMirror-gutter-wrapper {\n  position: absolute;\n  z-index: 4;\n  background: none !important;\n  border: none !important;\n}\n.CodeMirror-gutter-background {\n  position: absolute;\n  top: 0; bottom: 0;\n  z-index: 4;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent\n}\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent\n}\n.CodeMirror-lines {\n  cursor: text;\n  min-height: 1px; /* prevents collapsing before first draw */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-font-variant-ligatures: contextual;\n  font-variant-ligatures: contextual;\n}\n.CodeMirror-wrap pre.CodeMirror-line,\n.CodeMirror-wrap pre.CodeMirror-line-like {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0; right: 0; top: 0; bottom: 0;\n  z-index: 0;\n}\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\n}\n.CodeMirror-widget {}\n.CodeMirror-rtl pre { direction: rtl;\n}\n.CodeMirror-code {\n  outline: none;\n}\n\n/* Force content-box sizing for the elements where we expect it */\n.CodeMirror-scroll,\n.CodeMirror-sizer,\n.CodeMirror-gutter,\n.CodeMirror-gutters,\n.CodeMirror-linenumber {\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n.CodeMirror-cursor {\n  position: absolute;\n  pointer-events: none;\n}\n.CodeMirror-measure pre { position: static;\n}\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 3;\n}\ndiv.CodeMirror-dragcursors {\n  visibility: visible;\n}\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n.CodeMirror-selected { background: #d9d9d9;\n}\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0;\n}\n.CodeMirror-crosshair { cursor: crosshair;\n}\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0;\n}\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0;\n}\n.cm-searching {\n  background-color: #ffa;\n  background-color: rgba(255, 255, 0, .4);\n}\n\n/* Used to force a border model for a node */\n.cm-force-border { padding-right: .1px;\n}\n@media print {\n  /* Hide the cursor when printing */\n.CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n}\n}\n\n/* See issue #2901 */\n.cm-tab-wrap-hack:after { content: '';\n}\n\n/* Help users use markselection to safely style text background */\nspan.CodeMirror-selectedtext { background: none;\n}\n",
	    map: undefined,
	    media: undefined
	  });
	};
	/* scoped */


	var __vue_scope_id__ = undefined;
	/* module identifier */

	var __vue_module_identifier__ = undefined;
	/* functional template */

	var __vue_is_functional_template__ = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__ = normalizeComponent({
	  render: __vue_render__,
	  staticRenderFns: __vue_staticRenderFns__
	}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, createInjector, undefined, undefined);

	Vue$1.use(VueI18n);
	var i18n = {
	  beforeCreate: function beforeCreate() {
	    this._i18n = new VueI18n({
	      locale: this.$store.state.config.locale,
	      messages: this.$store.state.sections.styles.messages,
	      pluralizationRules: {
	        /**
	         * @param choice {number} a choice index given by the input to $tc: `$tc('path.to.rule', choiceIndex)`
	         * @param choicesLength {number} an overall amount of available choices
	         * @returns a final choice index to select plural word by
	         */

	        /*'ru_RU': function (choice, choicesLength) {
	            // this === VueI18n instance, so the locale property also exists here
	              if (choice === 0) {
	                return 0
	            }
	              const teen = choice > 10 && choice < 20
	            const endsWithOne = choice % 10 === 1
	              if (choicesLength < 4) {
	                return (!teen && endsWithOne) ? 1 : 2
	            }
	            if (!teen && endsWithOne) {
	                return 1
	            }
	            if (!teen && choice % 10 >= 2 && choice % 10 <= 4) {
	                return 2
	            }
	              return (choicesLength < 4) ? 2 : 3
	        },*/
	        // alternate
	        'ru_RU': function ru_RU(choice, choicesLength) {
	          return choice > 1 && choice < 5 && (choice % 100 > 19 || choice % 100 < 10) ? 1 : choice == 1 ? 0 : 2;
	        }
	      }
	    });
	    this._i18nWatcher = this._i18n.watchI18nData();
	  }
	};

	//
	var CUSTOM_CODE = '@custom-code';
	var script$1 = {
	  mixins: [i18n],
	  "extends": Vue$1.component('field'),
	  computed: {
	    code: {
	      get: function get() {
	        return this.$store.state.styles.vars[CUSTOM_CODE] || '';
	      },
	      set: function set(value) {
	        this.$store.commit('styles/setState', {
	          name: "vars." + CUSTOM_CODE,
	          value: value
	        });
	        this.value = value;
	      }
	    }
	  },
	  components: {
	    EditorCode: __vue_component__
	  }
	};

	/* script */
	var __vue_script__$1 = script$1;
	/* template */

	var __vue_render__$1 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "uk-margin-small-top"
	  }, [_c("editor-code", _vm._b({
	    model: {
	      value: _vm.code,
	      callback: function callback($$v) {
	        _vm.code = $$v;
	      },
	      expression: "code"
	    }
	  }, "editor-code", _vm.attributes, false)), _vm._v(" "), _c("div", {
	    staticClass: "uk-text-muted uk-margin-small-top"
	  }, [_vm._v("\n        " + _vm._s(_vm.$t("Add custom CSS or LESS to your site. All LESS theme variables and mixins are available. The <style> tag is not needed.")) + "\n    ")])], 1);
	};

	var __vue_staticRenderFns__$1 = [];
	__vue_render__$1._withStripped = true;
	/* style */

	var __vue_inject_styles__$1 = undefined;
	/* scoped */

	var __vue_scope_id__$1 = undefined;
	/* module identifier */

	var __vue_module_identifier__$1 = undefined;
	/* functional template */

	var __vue_is_functional_template__$1 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$1 = normalizeComponent({
	  render: __vue_render__$1,
	  staticRenderFns: __vue_staticRenderFns__$1
	}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

	//
	var script$2 = {
	  mixins: [i18n],
	  "extends": Vue$1.component('field')
	};

	/* script */
	var __vue_script__$2 = script$2;
	/* template */

	var __vue_render__$2 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "uk-alert uk-alert-danger customizer-panel-margin-horizontal-indent"
	  }, [_vm._v("\n    " + _vm._s(_vm.$t("Сustomizable theme is not compatible by the plugin")) + "\n")]);
	};

	var __vue_staticRenderFns__$2 = [];
	__vue_render__$2._withStripped = true;
	/* style */

	var __vue_inject_styles__$2 = undefined;
	/* scoped */

	var __vue_scope_id__$2 = undefined;
	/* module identifier */

	var __vue_module_identifier__$2 = undefined;
	/* functional template */

	var __vue_is_functional_template__$2 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$2 = normalizeComponent({
	  render: __vue_render__$2,
	  staticRenderFns: __vue_staticRenderFns__$2
	}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	const objPrototype = Object.prototype;
	const {
	  hasOwnProperty
	} = objPrototype;
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	const strPrototype = String.prototype;

	const startsWithFn = strPrototype.startsWith || function (search) {
	  return this.lastIndexOf(search, 0) === 0;
	};

	function startsWith(str, search) {
	  return startsWithFn.call(str, search);
	}
	const arrPrototype = Array.prototype;
	const {
	  isArray
	} = Array;
	function isFunction(obj) {
	  return typeof obj === 'function';
	}
	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}
	const {
	  toString
	} = objPrototype;
	function isDocument(obj) {
	  return isObject(obj) && obj.nodeType === 9;
	}
	function isJQuery(obj) {
	  return isObject(obj) && !!obj.jquery;
	}
	function isNode(obj) {
	  return isObject(obj) && obj.nodeType >= 1;
	}
	function isElement(obj) {
	  return isObject(obj) && obj.nodeType === 1;
	}
	function isNodeCollection(obj) {
	  return toString.call(obj).match(/^\[object (NodeList|HTMLCollection)\]$/);
	}
	function isBoolean(value) {
	  return typeof value === 'boolean';
	}
	function isString(value) {
	  return typeof value === 'string';
	}
	function isUndefined(value) {
	  return value === void 0;
	}
	function toNumber(value) {
	  const number = Number(value);
	  return !isNaN(number) ? number : false;
	}
	function toNode(element) {
	  return isNode(element) ? element : isNodeCollection(element) || isJQuery(element) ? element[0] : isArray(element) ? toNode(element[0]) : null;
	}
	function toNodes(element) {
	  return isNode(element) ? [element] : isNodeCollection(element) ? arrPrototype.slice.call(element) : isArray(element) ? element.map(toNode).filter(Boolean) : isJQuery(element) ? element.toArray() : [];
	}
	const assign = Object.assign || function (target, ...args) {
	  target = Object(target);

	  for (let i = 0; i < args.length; i++) {
	    const source = args[i];

	    if (source !== null) {
	      for (const key in source) {
	        if (hasOwn(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	  }

	  return target;
	};
	function noop() {}
	function intersectRect(r1, r2) {
	  return r1.left < r2.right && r1.right > r2.left && r1.top < r2.bottom && r1.bottom > r2.top;
	}

	function attr(element, name, value) {
	  if (isObject(name)) {
	    for (const key in name) {
	      attr(element, key, name[key]);
	    }

	    return;
	  }

	  if (isUndefined(value)) {
	    element = toNode(element);
	    return element && element.getAttribute(name);
	  } else {
	    toNodes(element).forEach(element => {
	      if (isFunction(value)) {
	        value = value.call(element, attr(element, name));
	      }

	      if (value === null) {
	        removeAttr(element, name);
	      } else {
	        element.setAttribute(name, value);
	      }
	    });
	  }
	}
	function hasAttr(element, name) {
	  return toNodes(element).some(element => element.hasAttribute(name));
	}
	function removeAttr(element, name) {
	  element = toNodes(element);
	  name.split(' ').forEach(name => element.forEach(element => element.hasAttribute(name) && element.removeAttribute(name)));
	}
	function data(element, attribute) {
	  for (let i = 0, attrs = [attribute, `data-${attribute}`]; i < attrs.length; i++) {
	    if (hasAttr(element, attrs[i])) {
	      return attr(element, attrs[i]);
	    }
	  }
	}

	/* global DocumentTouch */
	const isIE = /msie|trident/i.test(window.navigator.userAgent);
	const isRtl = attr(document.documentElement, 'dir') === 'rtl';
	const hasTouchEvents = ('ontouchstart' in window);
	const hasTouch = hasTouchEvents || window.DocumentTouch && document instanceof DocumentTouch || navigator.maxTouchPoints; // IE >=11

	function find(selector, context) {
	  return toNode(_query(selector, context, 'querySelector'));
	}
	function findAll(selector, context) {
	  return toNodes(_query(selector, context, 'querySelectorAll'));
	}

	function _query(selector, context = document, queryFn) {
	  if (!selector || !isString(selector)) {
	    return null;
	  }

	  selector = selector.replace(contextSanitizeRe, '$1 *');
	  let removes;

	  if (isContextSelector(selector)) {
	    removes = [];
	    selector = splitSelector(selector).map((selector, i) => {
	      let ctx = context;

	      if (selector[0] === '!') {
	        const selectors = selector.substr(1).trim().split(' ');
	        ctx = closest(parent(context), selectors[0]);
	        selector = selectors.slice(1).join(' ').trim();
	      }

	      if (selector[0] === '-') {
	        const selectors = selector.substr(1).trim().split(' ');
	        const prev = (ctx || context).previousElementSibling;
	        ctx = matches(prev, selector.substr(1)) ? prev : null;
	        selector = selectors.slice(1).join(' ');
	      }

	      if (!ctx) {
	        return null;
	      }

	      if (!ctx.id) {
	        ctx.id = `uk-${Date.now()}${i}`;
	        removes.push(() => removeAttr(ctx, 'id'));
	      }

	      return `#${escape(ctx.id)} ${selector}`;
	    }).filter(Boolean).join(',');
	    context = document;
	  }

	  try {
	    return context[queryFn](selector);
	  } catch (e) {
	    return null;
	  } finally {
	    removes && removes.forEach(remove => remove());
	  }
	}

	const contextSelectorRe = /(^|[^\\],)\s*[!>+~-]/;
	const contextSanitizeRe = /([!>+~-])(?=\s+[!>+~-]|\s*$)/g;

	function isContextSelector(selector) {
	  return isString(selector) && selector.match(contextSelectorRe);
	}

	const selectorRe = /.*?[^\\](?:,|$)/g;

	function splitSelector(selector) {
	  return selector.match(selectorRe).map(selector => selector.replace(/,$/, '').trim());
	}

	const elProto = Element.prototype;
	const matchesFn = elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector;
	function matches(element, selector) {
	  return toNodes(element).some(element => matchesFn.call(element, selector));
	}

	const closestFn = elProto.closest || function (selector) {
	  let ancestor = this;

	  do {
	    if (matches(ancestor, selector)) {
	      return ancestor;
	    }
	  } while (ancestor = parent(ancestor));
	};

	function closest(element, selector) {
	  if (startsWith(selector, '>')) {
	    selector = selector.slice(1);
	  }

	  return isElement(element) ? closestFn.call(element, selector) : toNodes(element).map(element => closest(element, selector)).filter(Boolean);
	}
	function parent(element) {
	  element = toNode(element);
	  return element && isElement(element.parentNode) && element.parentNode;
	}

	const escapeFn = window.CSS && CSS.escape || function (css) {
	  return css.replace(/([^\x7f-\uFFFF\w-])/g, match => `\\${match}`);
	};

	function escape(css) {
	  return isString(css) ? escapeFn.call(null, css) : '';
	}

	function within(element, selector) {
	  return !isString(selector) ? element === selector || (isDocument(selector) ? selector.documentElement : toNode(selector)).contains(toNode(element)) // IE 11 document does not implement contains
	  : matches(element, selector) || closest(element, selector);
	}

	function on(...args) {
	  let [targets, type, selector, listener, useCapture] = getArgs(args);
	  targets = toEventTargets(targets);

	  if (listener.length > 1) {
	    listener = detail(listener);
	  }

	  if (useCapture && useCapture.self) {
	    listener = selfFilter(listener);
	  }

	  if (selector) {
	    listener = delegate(targets, selector, listener);
	  }

	  useCapture = useCaptureFilter(useCapture);
	  type.split(' ').forEach(type => targets.forEach(target => target.addEventListener(type, listener, useCapture)));
	  return () => off(targets, type, listener, useCapture);
	}
	function off(targets, type, listener, useCapture = false) {
	  useCapture = useCaptureFilter(useCapture);
	  targets = toEventTargets(targets);
	  type.split(' ').forEach(type => targets.forEach(target => target.removeEventListener(type, listener, useCapture)));
	}

	function getArgs(args) {
	  if (isFunction(args[2])) {
	    args.splice(2, 0, false);
	  }

	  return args;
	}

	function delegate(delegates, selector, listener) {
	  return e => {
	    delegates.forEach(delegate => {
	      const current = selector[0] === '>' ? findAll(selector, delegate).reverse().filter(element => within(e.target, element))[0] : closest(e.target, selector);

	      if (current) {
	        e.delegate = delegate;
	        e.current = current;
	        listener.call(this, e);
	      }
	    });
	  };
	}

	function detail(listener) {
	  return e => isArray(e.detail) ? listener(e, ...e.detail) : listener(e);
	}

	function selfFilter(listener) {
	  return function (e) {
	    if (e.target === e.currentTarget || e.target === e.current) {
	      return listener.call(null, e);
	    }
	  };
	}

	function useCaptureFilter(options) {
	  return options && isIE && !isBoolean(options) ? !!options.capture : options;
	}

	function isEventTarget(target) {
	  return target && 'addEventListener' in target;
	}

	function toEventTarget(target) {
	  return isEventTarget(target) ? target : toNode(target);
	}

	function toEventTargets(target) {
	  return isArray(target) ? target.map(toEventTarget).filter(Boolean) : isString(target) ? findAll(target) : isEventTarget(target) ? [target] : toNodes(target);
	}

	/* global setImmediate */
	const Promise = 'Promise' in window ? window.Promise : PromiseFn;
	/**
	 * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
	 */

	const RESOLVED = 0;
	const REJECTED = 1;
	const PENDING = 2;
	const async = 'setImmediate' in window ? setImmediate : setTimeout;

	function PromiseFn(executor) {
	  this.state = PENDING;
	  this.value = undefined;
	  this.deferred = [];
	  const promise = this;

	  try {
	    executor(x => {
	      promise.resolve(x);
	    }, r => {
	      promise.reject(r);
	    });
	  } catch (e) {
	    promise.reject(e);
	  }
	}

	PromiseFn.reject = function (r) {
	  return new PromiseFn((resolve, reject) => {
	    reject(r);
	  });
	};

	PromiseFn.resolve = function (x) {
	  return new PromiseFn((resolve, reject) => {
	    resolve(x);
	  });
	};

	PromiseFn.all = function all(iterable) {
	  return new PromiseFn((resolve, reject) => {
	    const result = [];
	    let count = 0;

	    if (iterable.length === 0) {
	      resolve(result);
	    }

	    function resolver(i) {
	      return function (x) {
	        result[i] = x;
	        count += 1;

	        if (count === iterable.length) {
	          resolve(result);
	        }
	      };
	    }

	    for (let i = 0; i < iterable.length; i += 1) {
	      PromiseFn.resolve(iterable[i]).then(resolver(i), reject);
	    }
	  });
	};

	PromiseFn.race = function race(iterable) {
	  return new PromiseFn((resolve, reject) => {
	    for (let i = 0; i < iterable.length; i += 1) {
	      PromiseFn.resolve(iterable[i]).then(resolve, reject);
	    }
	  });
	};

	const p = PromiseFn.prototype;

	p.resolve = function resolve(x) {
	  const promise = this;

	  if (promise.state === PENDING) {
	    if (x === promise) {
	      throw new TypeError('Promise settled with itself.');
	    }

	    let called = false;

	    try {
	      const then = x && x.then;

	      if (x !== null && isObject(x) && isFunction(then)) {
	        then.call(x, x => {
	          if (!called) {
	            promise.resolve(x);
	          }

	          called = true;
	        }, r => {
	          if (!called) {
	            promise.reject(r);
	          }

	          called = true;
	        });
	        return;
	      }
	    } catch (e) {
	      if (!called) {
	        promise.reject(e);
	      }

	      return;
	    }

	    promise.state = RESOLVED;
	    promise.value = x;
	    promise.notify();
	  }
	};

	p.reject = function reject(reason) {
	  const promise = this;

	  if (promise.state === PENDING) {
	    if (reason === promise) {
	      throw new TypeError('Promise settled with itself.');
	    }

	    promise.state = REJECTED;
	    promise.value = reason;
	    promise.notify();
	  }
	};

	p.notify = function notify() {
	  async(() => {
	    if (this.state !== PENDING) {
	      while (this.deferred.length) {
	        const [onResolved, onRejected, resolve, reject] = this.deferred.shift();

	        try {
	          if (this.state === RESOLVED) {
	            if (isFunction(onResolved)) {
	              resolve(onResolved.call(undefined, this.value));
	            } else {
	              resolve(this.value);
	            }
	          } else if (this.state === REJECTED) {
	            if (isFunction(onRejected)) {
	              resolve(onRejected.call(undefined, this.value));
	            } else {
	              reject(this.value);
	            }
	          }
	        } catch (e) {
	          reject(e);
	        }
	      }
	    }
	  });
	};

	p.then = function then(onResolved, onRejected) {
	  return new PromiseFn((resolve, reject) => {
	    this.deferred.push([onResolved, onRejected, resolve, reject]);
	    this.notify();
	  });
	};

	p.catch = function (onRejected) {
	  return this.then(undefined, onRejected);
	};

	function ajax(url, options) {
	  return new Promise((resolve, reject) => {
	    const env = assign({
	      data: null,
	      method: 'GET',
	      headers: {},
	      xhr: new XMLHttpRequest(),
	      beforeSend: noop,
	      responseType: ''
	    }, options);
	    env.beforeSend(env);
	    const {
	      xhr
	    } = env;

	    for (const prop in env) {
	      if (prop in xhr) {
	        try {
	          xhr[prop] = env[prop];
	        } catch (e) {}
	      }
	    }

	    xhr.open(env.method.toUpperCase(), url);

	    for (const header in env.headers) {
	      xhr.setRequestHeader(header, env.headers[header]);
	    }

	    on(xhr, 'load', () => {
	      if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
	        resolve(xhr);
	      } else {
	        reject(assign(Error(xhr.statusText), {
	          xhr,
	          status: xhr.status
	        }));
	      }
	    });
	    on(xhr, 'error', () => reject(assign(Error('Network Error'), {
	      xhr
	    })));
	    on(xhr, 'timeout', () => reject(assign(Error('Network Timeout'), {
	      xhr
	    })));
	    xhr.send(env.data);
	  });
	}

	const fragmentRe = /^\s*<(\w+|!)[^>]*>/;
	const singleTagRe = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;
	function fragment(html) {
	  const matches = singleTagRe.exec(html);

	  if (matches) {
	    return document.createElement(matches[1]);
	  }

	  const container = document.createElement('div');

	  if (fragmentRe.test(html)) {
	    container.insertAdjacentHTML('beforeend', html.trim());
	  } else {
	    container.textContent = html;
	  }

	  return container.childNodes.length > 1 ? toNodes(container.childNodes) : container.firstChild;
	}
	function $(selector, context) {
	  return !isString(selector) ? toNode(selector) : isHtml(selector) ? toNode(fragment(selector)) : find(selector, context);
	}
	function $$(selector, context) {
	  return !isString(selector) ? toNodes(selector) : isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context);
	}

	function isHtml(str) {
	  return str[0] === '<' || str.match(/^\s*</);
	}

	/**
	 * Utility functions
	 */

	var _set,
	    _del;

	function Util (_ref) {
	  var set = _ref.set,
	      config = _ref.config;
	  _set = set;
	  _del = arguments[0]["delete"];
	}
	function get(obj, key, def) {
	  var parts = key.split('.');

	  for (var i = 0; i < parts.length; i++) {
	    if (!isUndefined(obj[parts[i]])) {
	      obj = obj[parts[i]];
	    } else {
	      return def;
	    }
	  }

	  return obj;
	}
	function set(obj, key, val) {
	  var parts = key.split('.');

	  while (parts.length > 1) {
	    var part = parts.shift();

	    if (!isObject(obj[part])) {
	      _set(obj, part, {});
	    }

	    obj = obj[part];
	  }

	  _set(obj, parts.shift(), val);
	}
	function del(obj, key) {
	  var parts = key.split('.');

	  while (parts.length > 1) {
	    var part = parts.shift();

	    if (!isUndefined(obj[part])) {
	      obj = obj[part];
	    } else {
	      return;
	    }
	  }

	  _del(obj, parts.shift());
	}
	function preparePanels(obj) {
	  if (obj === void 0) {
	    obj = {};
	  }

	  return Object.keys(obj).reduce(function (panels, key) {
	    panels[key] = obj[key];
	    panels[key]['name'] = key;
	    return panels;
	  }, {});
	}
	function debounce(fn, delay) {
	  var timeoutID = null;
	  return function () {
	    clearTimeout(timeoutID);
	    var args = arguments;
	    var that = this;
	    timeoutID = setTimeout(function () {
	      fn.apply(that, args);
	    }, delay);
	  };
	}
	/**
	 * https://stackoverflow.com/questions/22783108/convert-js-object-to-form-data
	 */

	function convertToFormData(data, formData, parentKey) {
	  if (data === null || data === undefined) return null;
	  formData = formData || new FormData();

	  if (typeof data === 'object' && !(data instanceof Date) && !(data instanceof File)) {
	    Object.keys(data).forEach(function (key) {
	      return convertToFormData(data[key], formData, !parentKey ? key : data[key] instanceof File ? parentKey : parentKey + "[" + key + "]");
	    });
	  } else {
	    formData.append(parentKey, data);
	  }

	  return formData;
	}
	/**
	 *
	 */

	function matchName(name, group) {
	  return (isString(group) ? [group] : group).some(function (pattern) {
	    return name === pattern || name.match("^" + pattern.replace(/\*/g, '.*') + "$");
	  });
	}

	//
	var script$3 = {
	  mixins: [i18n],
	  props: ['value'],
	  data: function data() {
	    return {
	      open: false
	    };
	  },
	  computed: {
	    preview: function preview() {
	      return this.value;
	    }
	  },
	  methods: {
	    show: function show() {
	      var _this = this;

	      this.open = true;
	      this.$nextTick(function () {
	        _this.dropdown = uikit.dropdown(_this.$refs.dropdown, {
	          flip: "x",
	          mode: "click",
	          toggle: false,
	          animation: false,
	          boundaryAlign: true,
	          pos: 'bottom-justify',
	          boundary: closest(_this.$el, '.styles-group-field') || _this.$el
	        });

	        _this.dropdown.show();
	      });
	    }
	  }
	};

	/* script */
	var __vue_script__$3 = script$3;
	/* template */

	var __vue_render__$3 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", [_c("a", {
	    staticClass: "styles-picker",
	    on: {
	      click: function click($event) {
	        $event.preventDefault();
	        !_vm.open && _vm.show();
	      }
	    }
	  }, [_c("div", {
	    staticClass: "styles-picker-preview",
	    style: {
	      background: _vm.preview
	    }
	  }), _vm._v(" "), _vm._t("preview")], 2), _vm._v(" "), _vm.open ? _c("div", {
	    ref: "dropdown",
	    staticClass: "styles-picker-dropdown",
	    on: {
	      show: function show($event) {
	        if ($event.target !== $event.currentTarget) {
	          return null;
	        }

	        _vm.open = true;
	      },
	      hidden: function hidden($event) {
	        if ($event.target !== $event.currentTarget) {
	          return null;
	        }

	        _vm.open = false;

	        _vm.$emit("hidden");
	      }
	    }
	  }, [_vm._t("default"), _vm._v(" "), _c("div", {
	    staticClass: "vc-styles-presets uk-flex-right"
	  }, [_c("button", {
	    staticClass: "uk-button uk-button-default",
	    attrs: {
	      type: "button"
	    },
	    on: {
	      click: function click($event) {
	        return _vm.dropdown.hide(false);
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.$t("Cancel")))]), _vm._v(" "), _c("button", {
	    staticClass: "uk-button uk-button-primary",
	    attrs: {
	      type: "button"
	    },
	    on: {
	      click: function click($event) {
	        _vm.$emit("change");

	        _vm.dropdown.hide(false);
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.$t("Apply")))])])], 2) : _vm._e()]);
	};

	var __vue_staticRenderFns__$3 = [];
	__vue_render__$3._withStripped = true;
	/* style */

	var __vue_inject_styles__$3 = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-6e19c1e4_0", {
	    source: "\n.styles-picker-dropdown {\r\n    padding: 10px 10px 0;\n}\n.styles-picker-dropdown .uk-button {\r\n    line-height: 18px;\r\n    font-size: 10px;\r\n    padding: 0 10px;\r\n    margin: 0 10px 10px 0;\n}\n.styles-picker {\r\n    border-radius: 500px;\r\n    overflow: hidden;\r\n    position: relative;\r\n    display: inline-block;\r\n    vertical-align: top;\r\n    cursor: pointer;\r\n    width: 20px;\r\n    height: 20px;\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15);\n}\n.styles-picker-preview {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    border-radius: 500px;\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15);\r\n    z-index: 2;\n}\n.styles-picker .vc-checkerboard {\r\n    background-size: auto;\n}\n.vc-styles-field.styles-picker-field-header .vc-input__label {\r\n    padding: 0 0 10px;\n}\n.styles-picker-field {\r\n    margin: 0 -10px;\r\n    padding: 4px 10px;\r\n    border-top: 1px solid #eee;\n}\n.styles-picker-field-header > :first-child,\r\n.styles-picker-field > :first-child {\r\n    padding-left: 0;\n}\n.styles-picker-presets {\r\n    border: none;\n}\n.styles-picker-presets .vc-styles-presets-color {\r\n    width: 18px;\r\n    height: 18px;\n}\n.vc-styles-presets-color.styles-picker-presets-color-active {\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15), 0 0 0 2.5px #fff, 0 0 0 3px rgba(0, 0, 0, .3);\n}\r\n\r\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\vendor\\assets\\js\\components\\common\\Picker.vue"],
	      "names": [],
	      "mappings": ";AAyEA;IACA,oBAAA;AACA;AAEA;IACA,iBAAA;IACA,eAAA;IACA,eAAA;IACA,qBAAA;AACA;AAEA;IACA,oBAAA;IACA,gBAAA;IACA,kBAAA;IACA,qBAAA;IACA,mBAAA;IACA,eAAA;IACA,WAAA;IACA,YAAA;IACA,8CAAA;AACA;AAEA;IACA,kBAAA;IACA,MAAA;IACA,OAAA;IACA,QAAA;IACA,SAAA;IACA,oBAAA;IACA,8CAAA;IACA,UAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,iBAAA;AACA;AAEA;IACA,eAAA;IACA,iBAAA;IACA,0BAAA;AACA;AAEA;;IAEA,eAAA;AACA;AAEA;IACA,YAAA;AACA;AAEA;IACA,WAAA;IACA,YAAA;AACA;AAEA;IACA,6FAAA;AACA",
	      "file": "Picker.vue",
	      "sourcesContent": ["<template>\r\n\r\n    <div>\r\n        <a class=\"styles-picker\" @click.prevent=\"!open && show()\">\r\n            <div class=\"styles-picker-preview\" :style=\"{ background: preview }\" />\r\n            <slot name=\"preview\"></slot>\r\n        </a>\r\n        <div v-if=\"open\" class=\"styles-picker-dropdown\" ref=\"dropdown\" @show.self=\"open=true\" @hidden.self=\"open=false; $emit('hidden')\">\r\n            <slot />\r\n            <div class=\"vc-styles-presets uk-flex-right\">\r\n                <button type=\"button\" class=\"uk-button uk-button-default\" @click=\"dropdown.hide(false)\">{{ $t('Cancel') }}</button>\r\n                <button type=\"button\" class=\"uk-button uk-button-primary\" @click=\"$emit('change'); dropdown.hide(false)\">{{ $t('Apply') }}</button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n</template>\r\n\r\n<script>\r\n\r\nimport { dropdown as Dropdown } from 'uikit'\r\nimport { closest } from '../../util'\r\nimport { i18n } from '../mixins'\r\n\r\nexport default {\r\n\r\n    mixins: [ i18n ],\r\n\r\n\tprops: [ 'value' ],\r\n\r\n\tdata () {\r\n        return {\r\n            open: false\r\n        }\r\n    },\r\n\r\n    computed: {\r\n\r\n        preview () {\r\n            return this.value\r\n        }\r\n\r\n    },\r\n\r\n\tmethods: {\r\n\r\n        show () {\r\n            this.open = true\r\n            this.$nextTick(() => {\r\n                this.dropdown = Dropdown(\r\n                    this.$refs.dropdown,\r\n                    {\r\n                        flip: \"x\",\r\n                        mode: \"click\",\r\n                        toggle: false,\r\n                        animation: false,\r\n                        boundaryAlign: true,\r\n                        pos: 'bottom-justify',\r\n                        boundary: closest(this.$el, '.styles-group-field') || this.$el\r\n                    }\r\n                )\r\n                this.dropdown.show()\r\n            })\r\n        }\r\n\r\n\t}\r\n\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\n\r\n.styles-picker-dropdown {\r\n    padding: 10px 10px 0;\r\n}\r\n\r\n.styles-picker-dropdown .uk-button {\r\n    line-height: 18px;\r\n    font-size: 10px;\r\n    padding: 0 10px;\r\n    margin: 0 10px 10px 0;\r\n}\r\n\r\n.styles-picker {\r\n    border-radius: 500px;\r\n    overflow: hidden;\r\n    position: relative;\r\n    display: inline-block;\r\n    vertical-align: top;\r\n    cursor: pointer;\r\n    width: 20px;\r\n    height: 20px;\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15);\r\n}\r\n\r\n.styles-picker-preview {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    border-radius: 500px;\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15);\r\n    z-index: 2;\r\n}\r\n\r\n.styles-picker .vc-checkerboard {\r\n    background-size: auto;\r\n}\r\n\r\n.vc-styles-field.styles-picker-field-header .vc-input__label {\r\n    padding: 0 0 10px;\r\n}\r\n\r\n.styles-picker-field {\r\n    margin: 0 -10px;\r\n    padding: 4px 10px;\r\n    border-top: 1px solid #eee;\r\n}\r\n\r\n.styles-picker-field-header > :first-child,\r\n.styles-picker-field > :first-child {\r\n    padding-left: 0;\r\n}\r\n\r\n.styles-picker-presets {\r\n    border: none;\r\n}\r\n\r\n.styles-picker-presets .vc-styles-presets-color {\r\n    width: 18px;\r\n    height: 18px;\r\n}\r\n\r\n.vc-styles-presets-color.styles-picker-presets-color-active {\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15), 0 0 0 2.5px #fff, 0 0 0 3px rgba(0, 0, 0, .3);\r\n}\r\n\r\n</style>\r\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	var __vue_scope_id__$3 = undefined;
	/* module identifier */

	var __vue_module_identifier__$3 = undefined;
	/* functional template */

	var __vue_is_functional_template__$3 = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$3 = normalizeComponent({
	  render: __vue_render__$3,
	  staticRenderFns: __vue_staticRenderFns__$3
	}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, createInjector, undefined, undefined);

	//
	//
	//
	//
	let _checkboardCache = {};
	var script$4 = {
	  name: 'Checkboard',
	  props: {
	    size: {
	      type: [Number, String],
	      default: 8
	    },
	    white: {
	      type: String,
	      default: '#fff'
	    },
	    grey: {
	      type: String,
	      default: '#e6e6e6'
	    }
	  },
	  computed: {
	    bgStyle() {
	      return {
	        'background-image': 'url(' + getCheckboard(this.white, this.grey, this.size) + ')'
	      };
	    }

	  }
	};
	/**
	 * get base 64 data by canvas
	 *
	 * @param {String} c1 hex color
	 * @param {String} c2 hex color
	 * @param {Number} size
	 */

	function renderCheckboard(c1, c2, size) {
	  // Dont Render On Server
	  if (typeof document === 'undefined') {
	    return null;
	  }

	  var canvas = document.createElement('canvas');
	  canvas.width = canvas.height = size * 2;
	  var ctx = canvas.getContext('2d'); // If no context can be found, return early.

	  if (!ctx) {
	    return null;
	  }

	  ctx.fillStyle = c1;
	  ctx.fillRect(0, 0, canvas.width, canvas.height);
	  ctx.fillStyle = c2;
	  ctx.fillRect(0, 0, size, size);
	  ctx.translate(size, size);
	  ctx.fillRect(0, 0, size, size);
	  return canvas.toDataURL();
	}
	/**
	 * get checkboard base data and cache
	 *
	 * @param {String} c1 hex color
	 * @param {String} c2 hex color
	 * @param {Number} size
	 */


	function getCheckboard(c1, c2, size) {
	  var key = c1 + ',' + c2 + ',' + size;

	  if (_checkboardCache[key]) {
	    return _checkboardCache[key];
	  } else {
	    var checkboard = renderCheckboard(c1, c2, size);
	    _checkboardCache[key] = checkboard;
	    return checkboard;
	  }
	}

	/* script */
	const __vue_script__$4 = script$4;
	/* template */

	var __vue_render__$4 = function () {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "vc-checkerboard",
	    style: _vm.bgStyle
	  });
	};

	var __vue_staticRenderFns__$4 = [];
	__vue_render__$4._withStripped = true;
	/* style */

	const __vue_inject_styles__$4 = function (inject) {
	  if (!inject) return;
	  inject("data-v-59d251fa_0", {
	    source: "\n.vc-checkerboard {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  background-size: contain;\n}\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\node_modules\\vue-color\\src\\components\\common\\Checkboard.vue"],
	      "names": [],
	      "mappings": ";AAoFA;EACA,kBAAA;EACA,QAAA;EACA,UAAA;EACA,WAAA;EACA,SAAA;EACA,wBAAA;AACA",
	      "file": "Checkboard.vue",
	      "sourcesContent": ["<template>\n  <div class=\"vc-checkerboard\" :style=\"bgStyle\"></div>\n</template>\n\n<script>\nlet _checkboardCache = {}\n\nexport default {\n  name: 'Checkboard',\n  props: {\n    size: {\n      type: [Number, String],\n      default: 8\n    },\n    white: {\n      type: String,\n      default: '#fff'\n    },\n    grey: {\n      type: String,\n      default: '#e6e6e6'\n    }\n  },\n  computed: {\n    bgStyle () {\n      return {\n        'background-image': 'url(' + getCheckboard(this.white, this.grey, this.size) + ')'\n      }\n    }\n  }\n}\n\n/**\n * get base 64 data by canvas\n *\n * @param {String} c1 hex color\n * @param {String} c2 hex color\n * @param {Number} size\n */\n\nfunction renderCheckboard (c1, c2, size) {\n  // Dont Render On Server\n  if (typeof document === 'undefined') {\n    return null\n  }\n  var canvas = document.createElement('canvas')\n  canvas.width = canvas.height = size * 2\n  var ctx = canvas.getContext('2d')\n  // If no context can be found, return early.\n  if (!ctx) {\n    return null\n  }\n  ctx.fillStyle = c1\n  ctx.fillRect(0, 0, canvas.width, canvas.height)\n  ctx.fillStyle = c2\n  ctx.fillRect(0, 0, size, size)\n  ctx.translate(size, size)\n  ctx.fillRect(0, 0, size, size)\n  return canvas.toDataURL()\n}\n\n/**\n * get checkboard base data and cache\n *\n * @param {String} c1 hex color\n * @param {String} c2 hex color\n * @param {Number} size\n */\n\nfunction getCheckboard (c1, c2, size) {\n  var key = c1 + ',' + c2 + ',' + size\n\n  if (_checkboardCache[key]) {\n    return _checkboardCache[key]\n  } else {\n    var checkboard = renderCheckboard(c1, c2, size)\n    _checkboardCache[key] = checkboard\n    return checkboard\n  }\n}\n\n</script>\n\n<style>\n.vc-checkerboard {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  background-size: contain;\n}\n</style>\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	const __vue_scope_id__$4 = undefined;
	/* module identifier */

	const __vue_module_identifier__$4 = undefined;
	/* functional template */

	const __vue_is_functional_template__$4 = false;
	/* style inject SSR */

	/* style inject shadow dom */

	const __vue_component__$4 = normalizeComponent({
	  render: __vue_render__$4,
	  staticRenderFns: __vue_staticRenderFns__$4
	}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, createInjector, undefined, undefined);

	//
	//
	//
	//
	//
	//
	var _colorsymbolCache = {};
	var script$5 = {
	  props: {
	    size: {
	      type: [Number, String],
	      "default": 12
	    },
	    color: {
	      type: String,
	      "default": '#dd4646'
	    },
	    type: {
	      type: String,
	      "default": ''
	    }
	  },
	  computed: {
	    bgStyle: function bgStyle() {
	      return {
	        'background-image': "url(" + getColorsymbol(this.color, this.size, this.type) + ")"
	      };
	    }
	  }
	};
	/**
	 * get base 64 data by canvas
	 *
	 * @param {String} c hex color
	 * @param {Number} size
	 * @param {String} type
	 */

	function renderColorsymbol(c, size, type) {
	  // Dont Render On Server
	  if (typeof document === 'undefined') {
	    return null;
	  }

	  var canvas = document.createElement('canvas');
	  canvas.width = canvas.height = size * 2;
	  var ctx = canvas.getContext('2d'); // If no context can be found, return early.

	  if (!ctx) {
	    return null;
	  } // Set line style


	  ctx.lineWidth = 2;
	  ctx.strokeStyle = c; // Set font style

	  ctx.font = size * 2 + "px monospace";
	  ctx.textAlign = 'center';
	  ctx.textBaseline = 'middle';
	  ctx.fillStyle = c;

	  switch (type) {
	    case 'currentColor':
	    case 'currentcolor':
	      ctx.fillText('c', size, size);
	      break;

	    case 'inherit':
	      ctx.fillText('i', size, size);
	      break;

	    case 'initial':
	      ctx.fillText('i', size, size);
	      break;

	    case 'unset':
	      ctx.fillText('u', size, size);
	      break;

	    case '':
	    default:
	      ctx.moveTo(0, canvas.height);
	      ctx.lineTo(canvas.width, 0);
	      ctx.stroke();
	      break;
	  }

	  return canvas.toDataURL();
	}
	/**
	 * get colorsymbol base data and cache
	 *
	 * @param {String} type
	 * @param {String} c hex color
	 * @param {Number} size
	 */


	function getColorsymbol(c, size, type) {
	  var key = type + "," + c + "," + size;

	  if (_colorsymbolCache[key]) {
	    return _colorsymbolCache[key];
	  } else {
	    var colorsymbol = renderColorsymbol(c, size, type);
	    _colorsymbolCache[key] = colorsymbol;
	    return colorsymbol;
	  }
	}

	/* script */
	var __vue_script__$5 = script$5;
	/* template */

	var __vue_render__$5 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "vc-checkerboard",
	    style: _vm.bgStyle
	  });
	};

	var __vue_staticRenderFns__$5 = [];
	__vue_render__$5._withStripped = true;
	/* style */

	var __vue_inject_styles__$5 = undefined;
	/* scoped */

	var __vue_scope_id__$5 = undefined;
	/* module identifier */

	var __vue_module_identifier__$5 = undefined;
	/* functional template */

	var __vue_is_functional_template__$5 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$5 = normalizeComponent({
	  render: __vue_render__$5,
	  staticRenderFns: __vue_staticRenderFns__$5
	}, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, false, undefined, undefined, undefined);

	var tinycolor = createCommonjsModule(function (module) {
	  // TinyColor v1.4.1
	  // https://github.com/bgrins/TinyColor
	  // Brian Grinstead, MIT License
	  (function (Math) {
	    var trimLeft = /^\s+/,
	        trimRight = /\s+$/,
	        tinyCounter = 0,
	        mathRound = Math.round,
	        mathMin = Math.min,
	        mathMax = Math.max,
	        mathRandom = Math.random;

	    function tinycolor(color, opts) {
	      color = color ? color : '';
	      opts = opts || {}; // If input is already a tinycolor, return itself

	      if (color instanceof tinycolor) {
	        return color;
	      } // If we are called as a function, call using new instead


	      if (!(this instanceof tinycolor)) {
	        return new tinycolor(color, opts);
	      }

	      var rgb = inputToRGB(color);
	      this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
	      this._gradientType = opts.gradientType; // Don't let the range of [0,255] come back in [0,1].
	      // Potentially lose a little bit of precision here, but will fix issues where
	      // .5 gets interpreted as half of the total, instead of half of 1
	      // If it was supposed to be 128, this was already taken care of by `inputToRgb`

	      if (this._r < 1) {
	        this._r = mathRound(this._r);
	      }

	      if (this._g < 1) {
	        this._g = mathRound(this._g);
	      }

	      if (this._b < 1) {
	        this._b = mathRound(this._b);
	      }

	      this._ok = rgb.ok;
	      this._tc_id = tinyCounter++;
	    }

	    tinycolor.prototype = {
	      isDark: function () {
	        return this.getBrightness() < 128;
	      },
	      isLight: function () {
	        return !this.isDark();
	      },
	      isValid: function () {
	        return this._ok;
	      },
	      getOriginalInput: function () {
	        return this._originalInput;
	      },
	      getFormat: function () {
	        return this._format;
	      },
	      getAlpha: function () {
	        return this._a;
	      },
	      getBrightness: function () {
	        //http://www.w3.org/TR/AERT#color-contrast
	        var rgb = this.toRgb();
	        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
	      },
	      getLuminance: function () {
	        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
	        var rgb = this.toRgb();
	        var RsRGB, GsRGB, BsRGB, R, G, B;
	        RsRGB = rgb.r / 255;
	        GsRGB = rgb.g / 255;
	        BsRGB = rgb.b / 255;

	        if (RsRGB <= 0.03928) {
	          R = RsRGB / 12.92;
	        } else {
	          R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
	        }

	        if (GsRGB <= 0.03928) {
	          G = GsRGB / 12.92;
	        } else {
	          G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
	        }

	        if (BsRGB <= 0.03928) {
	          B = BsRGB / 12.92;
	        } else {
	          B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
	        }

	        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
	      },
	      setAlpha: function (value) {
	        this._a = boundAlpha(value);
	        this._roundA = mathRound(100 * this._a) / 100;
	        return this;
	      },
	      toHsv: function () {
	        var hsv = rgbToHsv(this._r, this._g, this._b);
	        return {
	          h: hsv.h * 360,
	          s: hsv.s,
	          v: hsv.v,
	          a: this._a
	        };
	      },
	      toHsvString: function () {
	        var hsv = rgbToHsv(this._r, this._g, this._b);
	        var h = mathRound(hsv.h * 360),
	            s = mathRound(hsv.s * 100),
	            v = mathRound(hsv.v * 100);
	        return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
	      },
	      toHsl: function () {
	        var hsl = rgbToHsl(this._r, this._g, this._b);
	        return {
	          h: hsl.h * 360,
	          s: hsl.s,
	          l: hsl.l,
	          a: this._a
	        };
	      },
	      toHslString: function () {
	        var hsl = rgbToHsl(this._r, this._g, this._b);
	        var h = mathRound(hsl.h * 360),
	            s = mathRound(hsl.s * 100),
	            l = mathRound(hsl.l * 100);
	        return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
	      },
	      toHex: function (allow3Char) {
	        return rgbToHex(this._r, this._g, this._b, allow3Char);
	      },
	      toHexString: function (allow3Char) {
	        return '#' + this.toHex(allow3Char);
	      },
	      toHex8: function (allow4Char) {
	        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
	      },
	      toHex8String: function (allow4Char) {
	        return '#' + this.toHex8(allow4Char);
	      },
	      toRgb: function () {
	        return {
	          r: mathRound(this._r),
	          g: mathRound(this._g),
	          b: mathRound(this._b),
	          a: this._a
	        };
	      },
	      toRgbString: function () {
	        return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
	      },
	      toPercentageRgb: function () {
	        return {
	          r: mathRound(bound01(this._r, 255) * 100) + "%",
	          g: mathRound(bound01(this._g, 255) * 100) + "%",
	          b: mathRound(bound01(this._b, 255) * 100) + "%",
	          a: this._a
	        };
	      },
	      toPercentageRgbString: function () {
	        return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
	      },
	      toName: function () {
	        if (this._a === 0) {
	          return "transparent";
	        }

	        if (this._a < 1) {
	          return false;
	        }

	        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
	      },
	      toFilter: function (secondColor) {
	        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
	        var secondHex8String = hex8String;
	        var gradientType = this._gradientType ? "GradientType = 1, " : "";

	        if (secondColor) {
	          var s = tinycolor(secondColor);
	          secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
	        }

	        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
	      },
	      toString: function (format) {
	        var formatSet = !!format;
	        format = format || this._format;
	        var formattedString = false;
	        var hasAlpha = this._a < 1 && this._a >= 0;
	        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

	        if (needsAlphaFormat) {
	          // Special case for "transparent", all other non-alpha formats
	          // will return rgba when there is transparency.
	          if (format === "name" && this._a === 0) {
	            return this.toName();
	          }

	          return this.toRgbString();
	        }

	        if (format === "rgb") {
	          formattedString = this.toRgbString();
	        }

	        if (format === "prgb") {
	          formattedString = this.toPercentageRgbString();
	        }

	        if (format === "hex" || format === "hex6") {
	          formattedString = this.toHexString();
	        }

	        if (format === "hex3") {
	          formattedString = this.toHexString(true);
	        }

	        if (format === "hex4") {
	          formattedString = this.toHex8String(true);
	        }

	        if (format === "hex8") {
	          formattedString = this.toHex8String();
	        }

	        if (format === "name") {
	          formattedString = this.toName();
	        }

	        if (format === "hsl") {
	          formattedString = this.toHslString();
	        }

	        if (format === "hsv") {
	          formattedString = this.toHsvString();
	        }

	        return formattedString || this.toHexString();
	      },
	      clone: function () {
	        return tinycolor(this.toString());
	      },
	      _applyModification: function (fn, args) {
	        var color = fn.apply(null, [this].concat([].slice.call(args)));
	        this._r = color._r;
	        this._g = color._g;
	        this._b = color._b;
	        this.setAlpha(color._a);
	        return this;
	      },
	      lighten: function () {
	        return this._applyModification(lighten, arguments);
	      },
	      brighten: function () {
	        return this._applyModification(brighten, arguments);
	      },
	      darken: function () {
	        return this._applyModification(darken, arguments);
	      },
	      desaturate: function () {
	        return this._applyModification(desaturate, arguments);
	      },
	      saturate: function () {
	        return this._applyModification(saturate, arguments);
	      },
	      greyscale: function () {
	        return this._applyModification(greyscale, arguments);
	      },
	      spin: function () {
	        return this._applyModification(spin, arguments);
	      },
	      _applyCombination: function (fn, args) {
	        return fn.apply(null, [this].concat([].slice.call(args)));
	      },
	      analogous: function () {
	        return this._applyCombination(analogous, arguments);
	      },
	      complement: function () {
	        return this._applyCombination(complement, arguments);
	      },
	      monochromatic: function () {
	        return this._applyCombination(monochromatic, arguments);
	      },
	      splitcomplement: function () {
	        return this._applyCombination(splitcomplement, arguments);
	      },
	      triad: function () {
	        return this._applyCombination(triad, arguments);
	      },
	      tetrad: function () {
	        return this._applyCombination(tetrad, arguments);
	      }
	    }; // If input is an object, force 1 into "1.0" to handle ratios properly
	    // String input requires "1.0" as input, so 1 will be treated as 1

	    tinycolor.fromRatio = function (color, opts) {
	      if (typeof color == "object") {
	        var newColor = {};

	        for (var i in color) {
	          if (color.hasOwnProperty(i)) {
	            if (i === "a") {
	              newColor[i] = color[i];
	            } else {
	              newColor[i] = convertToPercentage(color[i]);
	            }
	          }
	        }

	        color = newColor;
	      }

	      return tinycolor(color, opts);
	    }; // Given a string or object, convert that input to RGB
	    // Possible string inputs:
	    //
	    //     "red"
	    //     "#f00" or "f00"
	    //     "#ff0000" or "ff0000"
	    //     "#ff000000" or "ff000000"
	    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
	    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
	    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
	    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
	    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
	    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
	    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
	    //


	    function inputToRGB(color) {
	      var rgb = {
	        r: 0,
	        g: 0,
	        b: 0
	      };
	      var a = 1;
	      var s = null;
	      var v = null;
	      var l = null;
	      var ok = false;
	      var format = false;

	      if (typeof color == "string") {
	        color = stringInputToObject(color);
	      }

	      if (typeof color == "object") {
	        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
	          rgb = rgbToRgb(color.r, color.g, color.b);
	          ok = true;
	          format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
	        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
	          s = convertToPercentage(color.s);
	          v = convertToPercentage(color.v);
	          rgb = hsvToRgb(color.h, s, v);
	          ok = true;
	          format = "hsv";
	        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
	          s = convertToPercentage(color.s);
	          l = convertToPercentage(color.l);
	          rgb = hslToRgb(color.h, s, l);
	          ok = true;
	          format = "hsl";
	        }

	        if (color.hasOwnProperty("a")) {
	          a = color.a;
	        }
	      }

	      a = boundAlpha(a);
	      return {
	        ok: ok,
	        format: color.format || format,
	        r: mathMin(255, mathMax(rgb.r, 0)),
	        g: mathMin(255, mathMax(rgb.g, 0)),
	        b: mathMin(255, mathMax(rgb.b, 0)),
	        a: a
	      };
	    } // Conversion Functions
	    // --------------------
	    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
	    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
	    // `rgbToRgb`
	    // Handle bounds / percentage checking to conform to CSS color spec
	    // <http://www.w3.org/TR/css3-color/>
	    // *Assumes:* r, g, b in [0, 255] or [0, 1]
	    // *Returns:* { r, g, b } in [0, 255]


	    function rgbToRgb(r, g, b) {
	      return {
	        r: bound01(r, 255) * 255,
	        g: bound01(g, 255) * 255,
	        b: bound01(b, 255) * 255
	      };
	    } // `rgbToHsl`
	    // Converts an RGB color value to HSL.
	    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
	    // *Returns:* { h, s, l } in [0,1]


	    function rgbToHsl(r, g, b) {
	      r = bound01(r, 255);
	      g = bound01(g, 255);
	      b = bound01(b, 255);
	      var max = mathMax(r, g, b),
	          min = mathMin(r, g, b);
	      var h,
	          s,
	          l = (max + min) / 2;

	      if (max == min) {
	        h = s = 0; // achromatic
	      } else {
	        var d = max - min;
	        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

	        switch (max) {
	          case r:
	            h = (g - b) / d + (g < b ? 6 : 0);
	            break;

	          case g:
	            h = (b - r) / d + 2;
	            break;

	          case b:
	            h = (r - g) / d + 4;
	            break;
	        }

	        h /= 6;
	      }

	      return {
	        h: h,
	        s: s,
	        l: l
	      };
	    } // `hslToRgb`
	    // Converts an HSL color value to RGB.
	    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
	    // *Returns:* { r, g, b } in the set [0, 255]


	    function hslToRgb(h, s, l) {
	      var r, g, b;
	      h = bound01(h, 360);
	      s = bound01(s, 100);
	      l = bound01(l, 100);

	      function hue2rgb(p, q, t) {
	        if (t < 0) t += 1;
	        if (t > 1) t -= 1;
	        if (t < 1 / 6) return p + (q - p) * 6 * t;
	        if (t < 1 / 2) return q;
	        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	        return p;
	      }

	      if (s === 0) {
	        r = g = b = l; // achromatic
	      } else {
	        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        var p = 2 * l - q;
	        r = hue2rgb(p, q, h + 1 / 3);
	        g = hue2rgb(p, q, h);
	        b = hue2rgb(p, q, h - 1 / 3);
	      }

	      return {
	        r: r * 255,
	        g: g * 255,
	        b: b * 255
	      };
	    } // `rgbToHsv`
	    // Converts an RGB color value to HSV
	    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
	    // *Returns:* { h, s, v } in [0,1]


	    function rgbToHsv(r, g, b) {
	      r = bound01(r, 255);
	      g = bound01(g, 255);
	      b = bound01(b, 255);
	      var max = mathMax(r, g, b),
	          min = mathMin(r, g, b);
	      var h,
	          s,
	          v = max;
	      var d = max - min;
	      s = max === 0 ? 0 : d / max;

	      if (max == min) {
	        h = 0; // achromatic
	      } else {
	        switch (max) {
	          case r:
	            h = (g - b) / d + (g < b ? 6 : 0);
	            break;

	          case g:
	            h = (b - r) / d + 2;
	            break;

	          case b:
	            h = (r - g) / d + 4;
	            break;
	        }

	        h /= 6;
	      }

	      return {
	        h: h,
	        s: s,
	        v: v
	      };
	    } // `hsvToRgb`
	    // Converts an HSV color value to RGB.
	    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
	    // *Returns:* { r, g, b } in the set [0, 255]


	    function hsvToRgb(h, s, v) {
	      h = bound01(h, 360) * 6;
	      s = bound01(s, 100);
	      v = bound01(v, 100);
	      var i = Math.floor(h),
	          f = h - i,
	          p = v * (1 - s),
	          q = v * (1 - f * s),
	          t = v * (1 - (1 - f) * s),
	          mod = i % 6,
	          r = [v, q, p, p, t, v][mod],
	          g = [t, v, v, q, p, p][mod],
	          b = [p, p, t, v, v, q][mod];
	      return {
	        r: r * 255,
	        g: g * 255,
	        b: b * 255
	      };
	    } // `rgbToHex`
	    // Converts an RGB color to hex
	    // Assumes r, g, and b are contained in the set [0, 255]
	    // Returns a 3 or 6 character hex


	    function rgbToHex(r, g, b, allow3Char) {
	      var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))]; // Return a 3 character hex if possible

	      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
	        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
	      }

	      return hex.join("");
	    } // `rgbaToHex`
	    // Converts an RGBA color plus alpha transparency to hex
	    // Assumes r, g, b are contained in the set [0, 255] and
	    // a in [0, 1]. Returns a 4 or 8 character rgba hex


	    function rgbaToHex(r, g, b, a, allow4Char) {
	      var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)), pad2(convertDecimalToHex(a))]; // Return a 4 character hex if possible

	      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
	        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
	      }

	      return hex.join("");
	    } // `rgbaToArgbHex`
	    // Converts an RGBA color to an ARGB Hex8 string
	    // Rarely used, but required for "toFilter()"


	    function rgbaToArgbHex(r, g, b, a) {
	      var hex = [pad2(convertDecimalToHex(a)), pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];
	      return hex.join("");
	    } // `equals`
	    // Can be called with any tinycolor input


	    tinycolor.equals = function (color1, color2) {
	      if (!color1 || !color2) {
	        return false;
	      }

	      return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
	    };

	    tinycolor.random = function () {
	      return tinycolor.fromRatio({
	        r: mathRandom(),
	        g: mathRandom(),
	        b: mathRandom()
	      });
	    }; // Modification Functions
	    // ----------------------
	    // Thanks to less.js for some of the basics here
	    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>


	    function desaturate(color, amount) {
	      amount = amount === 0 ? 0 : amount || 10;
	      var hsl = tinycolor(color).toHsl();
	      hsl.s -= amount / 100;
	      hsl.s = clamp01(hsl.s);
	      return tinycolor(hsl);
	    }

	    function saturate(color, amount) {
	      amount = amount === 0 ? 0 : amount || 10;
	      var hsl = tinycolor(color).toHsl();
	      hsl.s += amount / 100;
	      hsl.s = clamp01(hsl.s);
	      return tinycolor(hsl);
	    }

	    function greyscale(color) {
	      return tinycolor(color).desaturate(100);
	    }

	    function lighten(color, amount) {
	      amount = amount === 0 ? 0 : amount || 10;
	      var hsl = tinycolor(color).toHsl();
	      hsl.l += amount / 100;
	      hsl.l = clamp01(hsl.l);
	      return tinycolor(hsl);
	    }

	    function brighten(color, amount) {
	      amount = amount === 0 ? 0 : amount || 10;
	      var rgb = tinycolor(color).toRgb();
	      rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
	      rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
	      rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
	      return tinycolor(rgb);
	    }

	    function darken(color, amount) {
	      amount = amount === 0 ? 0 : amount || 10;
	      var hsl = tinycolor(color).toHsl();
	      hsl.l -= amount / 100;
	      hsl.l = clamp01(hsl.l);
	      return tinycolor(hsl);
	    } // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
	    // Values outside of this range will be wrapped into this range.


	    function spin(color, amount) {
	      var hsl = tinycolor(color).toHsl();
	      var hue = (hsl.h + amount) % 360;
	      hsl.h = hue < 0 ? 360 + hue : hue;
	      return tinycolor(hsl);
	    } // Combination Functions
	    // ---------------------
	    // Thanks to jQuery xColor for some of the ideas behind these
	    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>


	    function complement(color) {
	      var hsl = tinycolor(color).toHsl();
	      hsl.h = (hsl.h + 180) % 360;
	      return tinycolor(hsl);
	    }

	    function triad(color) {
	      var hsl = tinycolor(color).toHsl();
	      var h = hsl.h;
	      return [tinycolor(color), tinycolor({
	        h: (h + 120) % 360,
	        s: hsl.s,
	        l: hsl.l
	      }), tinycolor({
	        h: (h + 240) % 360,
	        s: hsl.s,
	        l: hsl.l
	      })];
	    }

	    function tetrad(color) {
	      var hsl = tinycolor(color).toHsl();
	      var h = hsl.h;
	      return [tinycolor(color), tinycolor({
	        h: (h + 90) % 360,
	        s: hsl.s,
	        l: hsl.l
	      }), tinycolor({
	        h: (h + 180) % 360,
	        s: hsl.s,
	        l: hsl.l
	      }), tinycolor({
	        h: (h + 270) % 360,
	        s: hsl.s,
	        l: hsl.l
	      })];
	    }

	    function splitcomplement(color) {
	      var hsl = tinycolor(color).toHsl();
	      var h = hsl.h;
	      return [tinycolor(color), tinycolor({
	        h: (h + 72) % 360,
	        s: hsl.s,
	        l: hsl.l
	      }), tinycolor({
	        h: (h + 216) % 360,
	        s: hsl.s,
	        l: hsl.l
	      })];
	    }

	    function analogous(color, results, slices) {
	      results = results || 6;
	      slices = slices || 30;
	      var hsl = tinycolor(color).toHsl();
	      var part = 360 / slices;
	      var ret = [tinycolor(color)];

	      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
	        hsl.h = (hsl.h + part) % 360;
	        ret.push(tinycolor(hsl));
	      }

	      return ret;
	    }

	    function monochromatic(color, results) {
	      results = results || 6;
	      var hsv = tinycolor(color).toHsv();
	      var h = hsv.h,
	          s = hsv.s,
	          v = hsv.v;
	      var ret = [];
	      var modification = 1 / results;

	      while (results--) {
	        ret.push(tinycolor({
	          h: h,
	          s: s,
	          v: v
	        }));
	        v = (v + modification) % 1;
	      }

	      return ret;
	    } // Utility Functions
	    // ---------------------


	    tinycolor.mix = function (color1, color2, amount) {
	      amount = amount === 0 ? 0 : amount || 50;
	      var rgb1 = tinycolor(color1).toRgb();
	      var rgb2 = tinycolor(color2).toRgb();
	      var p = amount / 100;
	      var rgba = {
	        r: (rgb2.r - rgb1.r) * p + rgb1.r,
	        g: (rgb2.g - rgb1.g) * p + rgb1.g,
	        b: (rgb2.b - rgb1.b) * p + rgb1.b,
	        a: (rgb2.a - rgb1.a) * p + rgb1.a
	      };
	      return tinycolor(rgba);
	    }; // Readability Functions
	    // ---------------------
	    // <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)
	    // `contrast`
	    // Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)


	    tinycolor.readability = function (color1, color2) {
	      var c1 = tinycolor(color1);
	      var c2 = tinycolor(color2);
	      return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
	    }; // `isReadable`
	    // Ensure that foreground and background color combinations meet WCAG2 guidelines.
	    // The third argument is an optional Object.
	    //      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
	    //      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
	    // If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.
	    // *Example*
	    //    tinycolor.isReadable("#000", "#111") => false
	    //    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false


	    tinycolor.isReadable = function (color1, color2, wcag2) {
	      var readability = tinycolor.readability(color1, color2);
	      var wcag2Parms, out;
	      out = false;
	      wcag2Parms = validateWCAG2Parms(wcag2);

	      switch (wcag2Parms.level + wcag2Parms.size) {
	        case "AAsmall":
	        case "AAAlarge":
	          out = readability >= 4.5;
	          break;

	        case "AAlarge":
	          out = readability >= 3;
	          break;

	        case "AAAsmall":
	          out = readability >= 7;
	          break;
	      }

	      return out;
	    }; // `mostReadable`
	    // Given a base color and a list of possible foreground or background
	    // colors for that base, returns the most readable color.
	    // Optionally returns Black or White if the most readable color is unreadable.
	    // *Example*
	    //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
	    //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
	    //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
	    //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"


	    tinycolor.mostReadable = function (baseColor, colorList, args) {
	      var bestColor = null;
	      var bestScore = 0;
	      var readability;
	      var includeFallbackColors, level, size;
	      args = args || {};
	      includeFallbackColors = args.includeFallbackColors;
	      level = args.level;
	      size = args.size;

	      for (var i = 0; i < colorList.length; i++) {
	        readability = tinycolor.readability(baseColor, colorList[i]);

	        if (readability > bestScore) {
	          bestScore = readability;
	          bestColor = tinycolor(colorList[i]);
	        }
	      }

	      if (tinycolor.isReadable(baseColor, bestColor, {
	        "level": level,
	        "size": size
	      }) || !includeFallbackColors) {
	        return bestColor;
	      } else {
	        args.includeFallbackColors = false;
	        return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
	      }
	    }; // Big List of Colors
	    // ------------------
	    // <http://www.w3.org/TR/css3-color/#svg-color>


	    var names = tinycolor.names = {
	      aliceblue: "f0f8ff",
	      antiquewhite: "faebd7",
	      aqua: "0ff",
	      aquamarine: "7fffd4",
	      azure: "f0ffff",
	      beige: "f5f5dc",
	      bisque: "ffe4c4",
	      black: "000",
	      blanchedalmond: "ffebcd",
	      blue: "00f",
	      blueviolet: "8a2be2",
	      brown: "a52a2a",
	      burlywood: "deb887",
	      burntsienna: "ea7e5d",
	      cadetblue: "5f9ea0",
	      chartreuse: "7fff00",
	      chocolate: "d2691e",
	      coral: "ff7f50",
	      cornflowerblue: "6495ed",
	      cornsilk: "fff8dc",
	      crimson: "dc143c",
	      cyan: "0ff",
	      darkblue: "00008b",
	      darkcyan: "008b8b",
	      darkgoldenrod: "b8860b",
	      darkgray: "a9a9a9",
	      darkgreen: "006400",
	      darkgrey: "a9a9a9",
	      darkkhaki: "bdb76b",
	      darkmagenta: "8b008b",
	      darkolivegreen: "556b2f",
	      darkorange: "ff8c00",
	      darkorchid: "9932cc",
	      darkred: "8b0000",
	      darksalmon: "e9967a",
	      darkseagreen: "8fbc8f",
	      darkslateblue: "483d8b",
	      darkslategray: "2f4f4f",
	      darkslategrey: "2f4f4f",
	      darkturquoise: "00ced1",
	      darkviolet: "9400d3",
	      deeppink: "ff1493",
	      deepskyblue: "00bfff",
	      dimgray: "696969",
	      dimgrey: "696969",
	      dodgerblue: "1e90ff",
	      firebrick: "b22222",
	      floralwhite: "fffaf0",
	      forestgreen: "228b22",
	      fuchsia: "f0f",
	      gainsboro: "dcdcdc",
	      ghostwhite: "f8f8ff",
	      gold: "ffd700",
	      goldenrod: "daa520",
	      gray: "808080",
	      green: "008000",
	      greenyellow: "adff2f",
	      grey: "808080",
	      honeydew: "f0fff0",
	      hotpink: "ff69b4",
	      indianred: "cd5c5c",
	      indigo: "4b0082",
	      ivory: "fffff0",
	      khaki: "f0e68c",
	      lavender: "e6e6fa",
	      lavenderblush: "fff0f5",
	      lawngreen: "7cfc00",
	      lemonchiffon: "fffacd",
	      lightblue: "add8e6",
	      lightcoral: "f08080",
	      lightcyan: "e0ffff",
	      lightgoldenrodyellow: "fafad2",
	      lightgray: "d3d3d3",
	      lightgreen: "90ee90",
	      lightgrey: "d3d3d3",
	      lightpink: "ffb6c1",
	      lightsalmon: "ffa07a",
	      lightseagreen: "20b2aa",
	      lightskyblue: "87cefa",
	      lightslategray: "789",
	      lightslategrey: "789",
	      lightsteelblue: "b0c4de",
	      lightyellow: "ffffe0",
	      lime: "0f0",
	      limegreen: "32cd32",
	      linen: "faf0e6",
	      magenta: "f0f",
	      maroon: "800000",
	      mediumaquamarine: "66cdaa",
	      mediumblue: "0000cd",
	      mediumorchid: "ba55d3",
	      mediumpurple: "9370db",
	      mediumseagreen: "3cb371",
	      mediumslateblue: "7b68ee",
	      mediumspringgreen: "00fa9a",
	      mediumturquoise: "48d1cc",
	      mediumvioletred: "c71585",
	      midnightblue: "191970",
	      mintcream: "f5fffa",
	      mistyrose: "ffe4e1",
	      moccasin: "ffe4b5",
	      navajowhite: "ffdead",
	      navy: "000080",
	      oldlace: "fdf5e6",
	      olive: "808000",
	      olivedrab: "6b8e23",
	      orange: "ffa500",
	      orangered: "ff4500",
	      orchid: "da70d6",
	      palegoldenrod: "eee8aa",
	      palegreen: "98fb98",
	      paleturquoise: "afeeee",
	      palevioletred: "db7093",
	      papayawhip: "ffefd5",
	      peachpuff: "ffdab9",
	      peru: "cd853f",
	      pink: "ffc0cb",
	      plum: "dda0dd",
	      powderblue: "b0e0e6",
	      purple: "800080",
	      rebeccapurple: "663399",
	      red: "f00",
	      rosybrown: "bc8f8f",
	      royalblue: "4169e1",
	      saddlebrown: "8b4513",
	      salmon: "fa8072",
	      sandybrown: "f4a460",
	      seagreen: "2e8b57",
	      seashell: "fff5ee",
	      sienna: "a0522d",
	      silver: "c0c0c0",
	      skyblue: "87ceeb",
	      slateblue: "6a5acd",
	      slategray: "708090",
	      slategrey: "708090",
	      snow: "fffafa",
	      springgreen: "00ff7f",
	      steelblue: "4682b4",
	      tan: "d2b48c",
	      teal: "008080",
	      thistle: "d8bfd8",
	      tomato: "ff6347",
	      turquoise: "40e0d0",
	      violet: "ee82ee",
	      wheat: "f5deb3",
	      white: "fff",
	      whitesmoke: "f5f5f5",
	      yellow: "ff0",
	      yellowgreen: "9acd32"
	    }; // Make it easy to access colors via `hexNames[hex]`

	    var hexNames = tinycolor.hexNames = flip(names); // Utilities
	    // ---------
	    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`

	    function flip(o) {
	      var flipped = {};

	      for (var i in o) {
	        if (o.hasOwnProperty(i)) {
	          flipped[o[i]] = i;
	        }
	      }

	      return flipped;
	    } // Return a valid alpha value [0,1] with all invalid values being set to 1


	    function boundAlpha(a) {
	      a = parseFloat(a);

	      if (isNaN(a) || a < 0 || a > 1) {
	        a = 1;
	      }

	      return a;
	    } // Take input from [0, n] and return it as [0, 1]


	    function bound01(n, max) {
	      if (isOnePointZero(n)) {
	        n = "100%";
	      }

	      var processPercent = isPercentage(n);
	      n = mathMin(max, mathMax(0, parseFloat(n))); // Automatically convert percentage into number

	      if (processPercent) {
	        n = parseInt(n * max, 10) / 100;
	      } // Handle floating point rounding errors


	      if (Math.abs(n - max) < 0.000001) {
	        return 1;
	      } // Convert into [0, 1] range if it isn't already


	      return n % max / parseFloat(max);
	    } // Force a number between 0 and 1


	    function clamp01(val) {
	      return mathMin(1, mathMax(0, val));
	    } // Parse a base-16 hex value into a base-10 integer


	    function parseIntFromHex(val) {
	      return parseInt(val, 16);
	    } // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
	    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>


	    function isOnePointZero(n) {
	      return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
	    } // Check to see if string passed in is a percentage


	    function isPercentage(n) {
	      return typeof n === "string" && n.indexOf('%') != -1;
	    } // Force a hex value to have 2 characters


	    function pad2(c) {
	      return c.length == 1 ? '0' + c : '' + c;
	    } // Replace a decimal with it's percentage value


	    function convertToPercentage(n) {
	      if (n <= 1) {
	        n = n * 100 + "%";
	      }

	      return n;
	    } // Converts a decimal to a hex value


	    function convertDecimalToHex(d) {
	      return Math.round(parseFloat(d) * 255).toString(16);
	    } // Converts a hex value to a decimal


	    function convertHexToDecimal(h) {
	      return parseIntFromHex(h) / 255;
	    }

	    var matchers = function () {
	      // <http://www.w3.org/TR/css3-values/#integers>
	      var CSS_INTEGER = "[-\\+]?\\d+%?"; // <http://www.w3.org/TR/css3-values/#number-value>

	      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?"; // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.

	      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")"; // Actual matching.
	      // Parentheses and commas are optional, but not required.
	      // Whitespace can take the place of commas or opening paren

	      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
	      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
	      return {
	        CSS_UNIT: new RegExp(CSS_UNIT),
	        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
	        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
	        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
	        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
	        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
	        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
	        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
	        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
	      };
	    }(); // `isValidCSSUnit`
	    // Take in a single string / number and check to see if it looks like a CSS unit
	    // (see `matchers` above for definition).


	    function isValidCSSUnit(color) {
	      return !!matchers.CSS_UNIT.exec(color);
	    } // `stringInputToObject`
	    // Permissive string parsing.  Take in a number of formats, and output an object
	    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`


	    function stringInputToObject(color) {
	      color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();
	      var named = false;

	      if (names[color]) {
	        color = names[color];
	        named = true;
	      } else if (color == 'transparent') {
	        return {
	          r: 0,
	          g: 0,
	          b: 0,
	          a: 0,
	          format: "name"
	        };
	      } // Try to match string input using regular expressions.
	      // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
	      // Just return an object and let the conversion functions handle that.
	      // This way the result will be the same whether the tinycolor is initialized with string or object.


	      var match;

	      if (match = matchers.rgb.exec(color)) {
	        return {
	          r: match[1],
	          g: match[2],
	          b: match[3]
	        };
	      }

	      if (match = matchers.rgba.exec(color)) {
	        return {
	          r: match[1],
	          g: match[2],
	          b: match[3],
	          a: match[4]
	        };
	      }

	      if (match = matchers.hsl.exec(color)) {
	        return {
	          h: match[1],
	          s: match[2],
	          l: match[3]
	        };
	      }

	      if (match = matchers.hsla.exec(color)) {
	        return {
	          h: match[1],
	          s: match[2],
	          l: match[3],
	          a: match[4]
	        };
	      }

	      if (match = matchers.hsv.exec(color)) {
	        return {
	          h: match[1],
	          s: match[2],
	          v: match[3]
	        };
	      }

	      if (match = matchers.hsva.exec(color)) {
	        return {
	          h: match[1],
	          s: match[2],
	          v: match[3],
	          a: match[4]
	        };
	      }

	      if (match = matchers.hex8.exec(color)) {
	        return {
	          r: parseIntFromHex(match[1]),
	          g: parseIntFromHex(match[2]),
	          b: parseIntFromHex(match[3]),
	          a: convertHexToDecimal(match[4]),
	          format: named ? "name" : "hex8"
	        };
	      }

	      if (match = matchers.hex6.exec(color)) {
	        return {
	          r: parseIntFromHex(match[1]),
	          g: parseIntFromHex(match[2]),
	          b: parseIntFromHex(match[3]),
	          format: named ? "name" : "hex"
	        };
	      }

	      if (match = matchers.hex4.exec(color)) {
	        return {
	          r: parseIntFromHex(match[1] + '' + match[1]),
	          g: parseIntFromHex(match[2] + '' + match[2]),
	          b: parseIntFromHex(match[3] + '' + match[3]),
	          a: convertHexToDecimal(match[4] + '' + match[4]),
	          format: named ? "name" : "hex8"
	        };
	      }

	      if (match = matchers.hex3.exec(color)) {
	        return {
	          r: parseIntFromHex(match[1] + '' + match[1]),
	          g: parseIntFromHex(match[2] + '' + match[2]),
	          b: parseIntFromHex(match[3] + '' + match[3]),
	          format: named ? "name" : "hex"
	        };
	      }

	      return false;
	    }

	    function validateWCAG2Parms(parms) {
	      // return valid WCAG2 parms for isReadable.
	      // If input parms are invalid, return {"level":"AA", "size":"small"}
	      var level, size;
	      parms = parms || {
	        "level": "AA",
	        "size": "small"
	      };
	      level = (parms.level || "AA").toUpperCase();
	      size = (parms.size || "small").toLowerCase();

	      if (level !== "AA" && level !== "AAA") {
	        level = "AA";
	      }

	      if (size !== "small" && size !== "large") {
	        size = "small";
	      }

	      return {
	        "level": level,
	        "size": size
	      };
	    } // Node: Export function


	    if ( module.exports) {
	      module.exports = tinycolor;
	    } // AMD/requirejs: Define the module
	    else {
	          window.tinycolor = tinycolor;
	        }
	  })(Math);
	});

	function _colorChange(data, oldHue) {
	  var alpha = data && data.a;
	  var color; // hsl is better than hex between conversions

	  if (data && data.hsl) {
	    color = tinycolor(data.hsl);
	  } else if (data && data.hex && data.hex.length > 0) {
	    color = tinycolor(data.hex);
	  } else if (data && data.hsv) {
	    color = tinycolor(data.hsv);
	  } else if (data && data.rgba) {
	    color = tinycolor(data.rgba);
	  } else if (data && data.rgb) {
	    color = tinycolor(data.rgb);
	  } else {
	    color = tinycolor(data);
	  }

	  if (color && (color._a === undefined || color._a === null)) {
	    color.setAlpha(alpha || 1);
	  }

	  var hsl = color.toHsl();
	  var hsv = color.toHsv();

	  if (hsl.s === 0) {
	    hsv.h = hsl.h = data.h || data.hsl && data.hsl.h || oldHue || 0;
	  }
	  /* --- comment this block to fix #109, may cause #25 again --- */
	  // when the hsv.v is less than 0.0164 (base on test)
	  // because of possible loss of precision
	  // the result of hue and saturation would be miscalculated
	  // if (hsv.v < 0.0164) {
	  //   hsv.h = data.h || (data.hsv && data.hsv.h) || 0
	  //   hsv.s = data.s || (data.hsv && data.hsv.s) || 0
	  // }
	  // if (hsl.l < 0.01) {
	  //   hsl.h = data.h || (data.hsl && data.hsl.h) || 0
	  //   hsl.s = data.s || (data.hsl && data.hsl.s) || 0
	  // }

	  /* ------ */


	  return {
	    hsl: hsl,
	    hex: color.toHexString().toUpperCase(),
	    hex8: color.toHex8String().toUpperCase(),
	    rgba: color.toRgb(),
	    hsv: hsv,
	    oldHue: data.h || oldHue || hsl.h,
	    source: data.source,
	    a: data.a || color.getAlpha()
	  };
	}

	var ColorMixin = {
	  props: ['value'],

	  data() {
	    return {
	      val: _colorChange(this.value)
	    };
	  },

	  computed: {
	    colors: {
	      get() {
	        return this.val;
	      },

	      set(newVal) {
	        this.val = newVal;
	        this.$emit('input', newVal);
	      }

	    }
	  },
	  watch: {
	    value(newVal) {
	      this.val = _colorChange(newVal);
	    }

	  },
	  methods: {
	    colorChange(data, oldHue) {
	      this.oldHue = this.colors.hsl.h;
	      this.colors = _colorChange(data, oldHue || this.oldHue);
	    },

	    isValidHex(hex) {
	      return tinycolor(hex).isValid();
	    },

	    simpleCheckForValidColor(data) {
	      var keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];
	      var checked = 0;
	      var passed = 0;

	      for (var i = 0; i < keysToCheck.length; i++) {
	        var letter = keysToCheck[i];

	        if (data[letter]) {
	          checked++;

	          if (!isNaN(data[letter])) {
	            passed++;
	          }
	        }
	      }

	      if (checked === passed) {
	        return data;
	      }
	    },

	    paletteUpperCase(palette) {
	      return palette.map(c => c.toUpperCase());
	    },

	    isTransparent(color) {
	      return tinycolor(color).getAlpha() === 0;
	    }

	  }
	};

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	var script$6 = {
	  name: 'editableInput',
	  props: {
	    label: String,
	    labelText: String,
	    desc: String,
	    value: [String, Number],
	    max: Number,
	    min: Number,
	    arrowOffset: {
	      type: Number,
	      default: 1
	    }
	  },
	  computed: {
	    val: {
	      get() {
	        return this.value;
	      },

	      set(v) {
	        // TODO: min
	        if (!(this.max === undefined) && +v > this.max) {
	          this.$refs.input.value = this.max;
	        } else {
	          return v;
	        }
	      }

	    },

	    labelId() {
	      return `input__label__${this.label}__${Math.random().toString().slice(2, 5)}`;
	    },

	    labelSpanText() {
	      return this.labelText || this.label;
	    }

	  },
	  methods: {
	    update(e) {
	      this.handleChange(e.target.value);
	    },

	    handleChange(newVal) {
	      let data = {};
	      data[this.label] = newVal;

	      if (data.hex === undefined && data['#'] === undefined) {
	        this.$emit('change', data);
	      } else if (newVal.length > 5) {
	        this.$emit('change', data);
	      }
	    },

	    // **** unused
	    // handleBlur (e) {
	    //   console.log(e)
	    // },
	    handleKeyDown(e) {
	      let val = this.val;
	      let number = Number(val);

	      if (number) {
	        let amount = this.arrowOffset || 1; // Up

	        if (e.keyCode === 38) {
	          val = number + amount;
	          this.handleChange(val);
	          e.preventDefault();
	        } // Down


	        if (e.keyCode === 40) {
	          val = number - amount;
	          this.handleChange(val);
	          e.preventDefault();
	        }
	      }
	    } // **** unused
	    // handleDrag (e) {
	    //   console.log(e)
	    // },
	    // handleMouseDown (e) {
	    //   console.log(e)
	    // }


	  }
	};

	/* script */
	const __vue_script__$6 = script$6;
	/* template */

	var __vue_render__$6 = function () {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "vc-editable-input"
	  }, [_c("input", {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.val,
	      expression: "val"
	    }],
	    ref: "input",
	    staticClass: "vc-input__input",
	    attrs: {
	      "aria-labelledby": _vm.labelId
	    },
	    domProps: {
	      value: _vm.val
	    },
	    on: {
	      keydown: _vm.handleKeyDown,
	      input: [function ($event) {
	        if ($event.target.composing) {
	          return;
	        }

	        _vm.val = $event.target.value;
	      }, _vm.update]
	    }
	  }), _vm._v(" "), _c("span", {
	    staticClass: "vc-input__label",
	    attrs: {
	      for: _vm.label,
	      id: _vm.labelId
	    }
	  }, [_vm._v(_vm._s(_vm.labelSpanText))]), _vm._v(" "), _c("span", {
	    staticClass: "vc-input__desc"
	  }, [_vm._v(_vm._s(_vm.desc))])]);
	};

	var __vue_staticRenderFns__$6 = [];
	__vue_render__$6._withStripped = true;
	/* style */

	const __vue_inject_styles__$6 = function (inject) {
	  if (!inject) return;
	  inject("data-v-2de2452b_0", {
	    source: "\n.vc-editable-input {\n  position: relative;\n}\n.vc-input__input {\n  padding: 0;\n  border: 0;\n  outline: none;\n}\n.vc-input__label {\n  text-transform: capitalize;\n}\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\node_modules\\vue-color\\src\\components\\common\\EditableInput.vue"],
	      "names": [],
	      "mappings": ";AAsGA;EACA,kBAAA;AACA;AACA;EACA,UAAA;EACA,SAAA;EACA,aAAA;AACA;AACA;EACA,0BAAA;AACA",
	      "file": "EditableInput.vue",
	      "sourcesContent": ["<template>\n  <div class=\"vc-editable-input\">\n    <input\n      :aria-labelledby=\"labelId\"\n      class=\"vc-input__input\"\n      v-model=\"val\"\n      @keydown=\"handleKeyDown\"\n      @input=\"update\"\n      ref=\"input\"\n    >\n    <span :for=\"label\" class=\"vc-input__label\" :id=\"labelId\">{{labelSpanText}}</span>\n    <span class=\"vc-input__desc\">{{desc}}</span>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'editableInput',\n  props: {\n    label: String,\n    labelText: String,\n    desc: String,\n    value: [String, Number],\n    max: Number,\n    min: Number,\n    arrowOffset: {\n      type: Number,\n      default: 1\n    }\n  },\n  computed: {\n    val: {\n      get () {\n        return this.value\n      },\n      set (v) {\n        // TODO: min\n        if (!(this.max === undefined) && +v > this.max) {\n          this.$refs.input.value = this.max\n        } else {\n          return v\n        }\n      }\n    },\n    labelId () {\n      return `input__label__${this.label}__${Math.random().toString().slice(2, 5)}`\n    },\n    labelSpanText () {\n      return this.labelText || this.label\n    }\n  },\n  methods: {\n    update (e) {\n      this.handleChange(e.target.value)\n    },\n    handleChange (newVal) {\n      let data = {}\n      data[this.label] = newVal\n      if (data.hex === undefined && data['#'] === undefined) {\n        this.$emit('change', data)\n      } else if (newVal.length > 5) {\n        this.$emit('change', data)\n      }\n    },\n    // **** unused\n    // handleBlur (e) {\n    //   console.log(e)\n    // },\n    handleKeyDown (e) {\n      let val = this.val\n      let number = Number(val)\n\n      if (number) {\n        let amount = this.arrowOffset || 1\n\n        // Up\n        if (e.keyCode === 38) {\n          val = number + amount\n          this.handleChange(val)\n          e.preventDefault()\n        }\n\n        // Down\n        if (e.keyCode === 40) {\n          val = number - amount\n          this.handleChange(val)\n          e.preventDefault()\n        }\n      }\n    }\n    // **** unused\n    // handleDrag (e) {\n    //   console.log(e)\n    // },\n    // handleMouseDown (e) {\n    //   console.log(e)\n    // }\n  }\n}\n</script>\n\n<style>\n.vc-editable-input {\n  position: relative;\n}\n.vc-input__input {\n  padding: 0;\n  border: 0;\n  outline: none;\n}\n.vc-input__label {\n  text-transform: capitalize;\n}\n</style>\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	const __vue_scope_id__$6 = undefined;
	/* module identifier */

	const __vue_module_identifier__$6 = undefined;
	/* functional template */

	const __vue_is_functional_template__$6 = false;
	/* style inject SSR */

	/* style inject shadow dom */

	const __vue_component__$6 = normalizeComponent({
	  render: __vue_render__$6,
	  staticRenderFns: __vue_staticRenderFns__$6
	}, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, false, createInjector, undefined, undefined);

	var clamp_1 = clamp;

	function clamp(value, min, max) {
	  return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
	}

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the `TypeError` message for "Functions" methods. */

	var FUNC_ERROR_TEXT = 'Expected a function';
	/** Used as references for various `Number` constants. */

	var NAN = 0 / 0;
	/** `Object#toString` result references. */

	var symbolTag = '[object Symbol]';
	/** Used to match leading and trailing whitespace. */

	var reTrim = /^\s+|\s+$/g;
	/** Used to detect bad signed hexadecimal string values. */

	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	/** Used to detect binary string values. */

	var reIsBinary = /^0b[01]+$/i;
	/** Used to detect octal string values. */

	var reIsOctal = /^0o[0-7]+$/i;
	/** Built-in method references without a dependency on `root`. */

	var freeParseInt = parseInt;
	/** Detect free variable `global` from Node.js. */

	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
	/** Detect free variable `self`. */

	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	/** Used as a reference to the global object. */

	var root = freeGlobal || freeSelf || Function('return this')();
	/** Used for built-in method references. */

	var objectProto = Object.prototype;
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */

	var objectToString = objectProto.toString;
	/* Built-in method references for those with the same name as other `lodash` methods. */

	var nativeMax = Math.max,
	    nativeMin = Math.min;
	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */

	var now = function () {
	  return root.Date.now();
	};
	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */


	function debounce$1(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }

	  wait = toNumber$1(wait) || 0;

	  if (isObject$1(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber$1(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;
	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time; // Start the timer for the trailing edge.

	    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        result = wait - timeSinceLastCall;
	    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.

	    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
	  }

	  function timerExpired() {
	    var time = now();

	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    } // Restart the timer.


	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.

	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }

	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }

	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now());
	  }

	  function debounced() {
	    var time = now(),
	        isInvoking = shouldInvoke(time);
	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }

	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }

	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }

	    return result;
	  }

	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}
	/**
	 * Creates a throttled function that only invokes `func` at most once per
	 * every `wait` milliseconds. The throttled function comes with a `cancel`
	 * method to cancel delayed `func` invocations and a `flush` method to
	 * immediately invoke them. Provide `options` to indicate whether `func`
	 * should be invoked on the leading and/or trailing edge of the `wait`
	 * timeout. The `func` is invoked with the last arguments provided to the
	 * throttled function. Subsequent calls to the throttled function return the
	 * result of the last `func` invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the throttled function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.throttle` and `_.debounce`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to throttle.
	 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=true]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new throttled function.
	 * @example
	 *
	 * // Avoid excessively updating the position while scrolling.
	 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	 *
	 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	 * jQuery(element).on('click', throttled);
	 *
	 * // Cancel the trailing throttled invocation.
	 * jQuery(window).on('popstate', throttled.cancel);
	 */


	function throttle(func, wait, options) {
	  var leading = true,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }

	  if (isObject$1(options)) {
	    leading = 'leading' in options ? !!options.leading : leading;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  return debounce$1(func, wait, {
	    'leading': leading,
	    'maxWait': wait,
	    'trailing': trailing
	  });
	}
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */


	function isObject$1(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */


	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */


	function isSymbol(value) {
	  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
	}
	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */


	function toNumber$1(value) {
	  if (typeof value == 'number') {
	    return value;
	  }

	  if (isSymbol(value)) {
	    return NAN;
	  }

	  if (isObject$1(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject$1(other) ? other + '' : other;
	  }

	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }

	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
	}

	var lodash_throttle = throttle;

	//
	var script$7 = {
	  name: 'Saturation',
	  props: {
	    value: Object
	  },
	  computed: {
	    colors() {
	      return this.value;
	    },

	    bgColor() {
	      return `hsl(${this.colors.hsv.h}, 100%, 50%)`;
	    },

	    pointerTop() {
	      return -(this.colors.hsv.v * 100) + 1 + 100 + '%';
	    },

	    pointerLeft() {
	      return this.colors.hsv.s * 100 + '%';
	    }

	  },
	  methods: {
	    throttle: lodash_throttle((fn, data) => {
	      fn(data);
	    }, 20, {
	      'leading': true,
	      'trailing': false
	    }),

	    handleChange(e, skip) {
	      !skip && e.preventDefault();
	      var container = this.$refs.container;
	      var containerWidth = container.clientWidth;
	      var containerHeight = container.clientHeight;
	      var xOffset = container.getBoundingClientRect().left + window.pageXOffset;
	      var yOffset = container.getBoundingClientRect().top + window.pageYOffset;
	      var pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0);
	      var pageY = e.pageY || (e.touches ? e.touches[0].pageY : 0);
	      var left = clamp_1(pageX - xOffset, 0, containerWidth);
	      var top = clamp_1(pageY - yOffset, 0, containerHeight);
	      var saturation = left / containerWidth;
	      var bright = clamp_1(-(top / containerHeight) + 1, 0, 1);
	      this.throttle(this.onChange, {
	        h: this.colors.hsv.h,
	        s: saturation,
	        v: bright,
	        a: this.colors.hsv.a,
	        source: 'hsva'
	      });
	    },

	    onChange(param) {
	      this.$emit('change', param);
	    },

	    handleMouseDown(e) {
	      // this.handleChange(e, true)
	      window.addEventListener('mousemove', this.handleChange);
	      window.addEventListener('mouseup', this.handleChange);
	      window.addEventListener('mouseup', this.handleMouseUp);
	    },

	    handleMouseUp(e) {
	      this.unbindEventListeners();
	    },

	    unbindEventListeners() {
	      window.removeEventListener('mousemove', this.handleChange);
	      window.removeEventListener('mouseup', this.handleChange);
	      window.removeEventListener('mouseup', this.handleMouseUp);
	    }

	  }
	};

	/* script */
	const __vue_script__$7 = script$7;
	/* template */

	var __vue_render__$7 = function () {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    ref: "container",
	    staticClass: "vc-saturation",
	    style: {
	      background: _vm.bgColor
	    },
	    on: {
	      mousedown: _vm.handleMouseDown,
	      touchmove: _vm.handleChange,
	      touchstart: _vm.handleChange
	    }
	  }, [_c("div", {
	    staticClass: "vc-saturation--white"
	  }), _vm._v(" "), _c("div", {
	    staticClass: "vc-saturation--black"
	  }), _vm._v(" "), _c("div", {
	    staticClass: "vc-saturation-pointer",
	    style: {
	      top: _vm.pointerTop,
	      left: _vm.pointerLeft
	    }
	  }, [_c("div", {
	    staticClass: "vc-saturation-circle"
	  })])]);
	};

	var __vue_staticRenderFns__$7 = [];
	__vue_render__$7._withStripped = true;
	/* style */

	const __vue_inject_styles__$7 = function (inject) {
	  if (!inject) return;
	  inject("data-v-95dcab5c_0", {
	    source: "\n.vc-saturation,\n.vc-saturation--white,\n.vc-saturation--black {\n  cursor: pointer;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n.vc-saturation--white {\n  background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n}\n.vc-saturation--black {\n  background: linear-gradient(to top, #000, rgba(0,0,0,0));\n}\n.vc-saturation-pointer {\n  cursor: pointer;\n  position: absolute;\n}\n.vc-saturation-circle {\n  cursor: head;\n  width: 4px;\n  height: 4px;\n  box-shadow: 0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3), 0 0 1px 2px rgba(0,0,0,.4);\n  border-radius: 50%;\n  transform: translate(-2px, -2px);\n}\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\node_modules\\vue-color\\src\\components\\common\\Saturation.vue"],
	      "names": [],
	      "mappings": ";AA2FA;;;EAGA,eAAA;EACA,kBAAA;EACA,MAAA;EACA,OAAA;EACA,QAAA;EACA,SAAA;AACA;AAEA;EACA,gEAAA;AACA;AACA;EACA,wDAAA;AACA;AACA;EACA,eAAA;EACA,kBAAA;AACA;AACA;EACA,YAAA;EACA,UAAA;EACA,WAAA;EACA,0FAAA;EACA,kBAAA;EACA,gCAAA;AACA",
	      "file": "Saturation.vue",
	      "sourcesContent": ["<template>\n  <div class=\"vc-saturation\"\n    :style=\"{background: bgColor}\"\n    ref=\"container\"\n    @mousedown=\"handleMouseDown\"\n    @touchmove=\"handleChange\"\n    @touchstart=\"handleChange\">\n    <div class=\"vc-saturation--white\"></div>\n    <div class=\"vc-saturation--black\"></div>\n    <div class=\"vc-saturation-pointer\" :style=\"{top: pointerTop, left: pointerLeft}\">\n      <div class=\"vc-saturation-circle\"></div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport clamp from 'clamp'\nimport throttle from 'lodash.throttle'\n\nexport default {\n  name: 'Saturation',\n  props: {\n    value: Object\n  },\n  computed: {\n    colors () {\n      return this.value\n    },\n    bgColor () {\n      return `hsl(${this.colors.hsv.h}, 100%, 50%)`\n    },\n    pointerTop () {\n      return (-(this.colors.hsv.v * 100) + 1) + 100 + '%'\n    },\n    pointerLeft () {\n      return this.colors.hsv.s * 100 + '%'\n    }\n  },\n  methods: {\n    throttle: throttle((fn, data) => {\n      fn(data)\n    }, 20,\n      {\n        'leading': true,\n        'trailing': false\n      }),\n    handleChange (e, skip) {\n      !skip && e.preventDefault()\n      var container = this.$refs.container\n      var containerWidth = container.clientWidth\n      var containerHeight = container.clientHeight\n\n      var xOffset = container.getBoundingClientRect().left + window.pageXOffset\n      var yOffset = container.getBoundingClientRect().top + window.pageYOffset\n      var pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0)\n      var pageY = e.pageY || (e.touches ? e.touches[0].pageY : 0)\n      var left = clamp(pageX - xOffset, 0, containerWidth)\n      var top = clamp(pageY - yOffset, 0, containerHeight)\n      var saturation = left / containerWidth\n      var bright = clamp(-(top / containerHeight) + 1, 0, 1)\n\n      this.throttle(this.onChange, {\n        h: this.colors.hsv.h,\n        s: saturation,\n        v: bright,\n        a: this.colors.hsv.a,\n        source: 'hsva'\n      })\n    },\n    onChange (param) {\n      this.$emit('change', param)\n    },\n    handleMouseDown (e) {\n      // this.handleChange(e, true)\n      window.addEventListener('mousemove', this.handleChange)\n      window.addEventListener('mouseup', this.handleChange)\n      window.addEventListener('mouseup', this.handleMouseUp)\n    },\n    handleMouseUp (e) {\n      this.unbindEventListeners()\n    },\n    unbindEventListeners () {\n      window.removeEventListener('mousemove', this.handleChange)\n      window.removeEventListener('mouseup', this.handleChange)\n      window.removeEventListener('mouseup', this.handleMouseUp)\n    }\n  }\n}\n</script>\n\n<style>\n.vc-saturation,\n.vc-saturation--white,\n.vc-saturation--black {\n  cursor: pointer;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.vc-saturation--white {\n  background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n}\n.vc-saturation--black {\n  background: linear-gradient(to top, #000, rgba(0,0,0,0));\n}\n.vc-saturation-pointer {\n  cursor: pointer;\n  position: absolute;\n}\n.vc-saturation-circle {\n  cursor: head;\n  width: 4px;\n  height: 4px;\n  box-shadow: 0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3), 0 0 1px 2px rgba(0,0,0,.4);\n  border-radius: 50%;\n  transform: translate(-2px, -2px);\n}\n</style>\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	const __vue_scope_id__$7 = undefined;
	/* module identifier */

	const __vue_module_identifier__$7 = undefined;
	/* functional template */

	const __vue_is_functional_template__$7 = false;
	/* style inject SSR */

	/* style inject shadow dom */

	const __vue_component__$7 = normalizeComponent({
	  render: __vue_render__$7,
	  staticRenderFns: __vue_staticRenderFns__$7
	}, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, false, createInjector, undefined, undefined);

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	var script$8 = {
	  name: 'Hue',
	  props: {
	    value: Object,
	    direction: {
	      type: String,
	      // [horizontal | vertical]
	      default: 'horizontal'
	    }
	  },

	  data() {
	    return {
	      oldHue: 0,
	      pullDirection: ''
	    };
	  },

	  computed: {
	    colors() {
	      const h = this.value.hsl.h;
	      if (h !== 0 && h - this.oldHue > 0) this.pullDirection = 'right';
	      if (h !== 0 && h - this.oldHue < 0) this.pullDirection = 'left';
	      this.oldHue = h;
	      return this.value;
	    },

	    directionClass() {
	      return {
	        'vc-hue--horizontal': this.direction === 'horizontal',
	        'vc-hue--vertical': this.direction === 'vertical'
	      };
	    },

	    pointerTop() {
	      if (this.direction === 'vertical') {
	        if (this.colors.hsl.h === 0 && this.pullDirection === 'right') return 0;
	        return -(this.colors.hsl.h * 100 / 360) + 100 + '%';
	      } else {
	        return 0;
	      }
	    },

	    pointerLeft() {
	      if (this.direction === 'vertical') {
	        return 0;
	      } else {
	        if (this.colors.hsl.h === 0 && this.pullDirection === 'right') return '100%';
	        return this.colors.hsl.h * 100 / 360 + '%';
	      }
	    }

	  },
	  methods: {
	    handleChange(e, skip) {
	      !skip && e.preventDefault();
	      var container = this.$refs.container;
	      var containerWidth = container.clientWidth;
	      var containerHeight = container.clientHeight;
	      var xOffset = container.getBoundingClientRect().left + window.pageXOffset;
	      var yOffset = container.getBoundingClientRect().top + window.pageYOffset;
	      var pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0);
	      var pageY = e.pageY || (e.touches ? e.touches[0].pageY : 0);
	      var left = pageX - xOffset;
	      var top = pageY - yOffset;
	      var h;
	      var percent;

	      if (this.direction === 'vertical') {
	        if (top < 0) {
	          h = 360;
	        } else if (top > containerHeight) {
	          h = 0;
	        } else {
	          percent = -(top * 100 / containerHeight) + 100;
	          h = 360 * percent / 100;
	        }

	        if (this.colors.hsl.h !== h) {
	          this.$emit('change', {
	            h: h,
	            s: this.colors.hsl.s,
	            l: this.colors.hsl.l,
	            a: this.colors.hsl.a,
	            source: 'hsl'
	          });
	        }
	      } else {
	        if (left < 0) {
	          h = 0;
	        } else if (left > containerWidth) {
	          h = 360;
	        } else {
	          percent = left * 100 / containerWidth;
	          h = 360 * percent / 100;
	        }

	        if (this.colors.hsl.h !== h) {
	          this.$emit('change', {
	            h: h,
	            s: this.colors.hsl.s,
	            l: this.colors.hsl.l,
	            a: this.colors.hsl.a,
	            source: 'hsl'
	          });
	        }
	      }
	    },

	    handleMouseDown(e) {
	      this.handleChange(e, true);
	      window.addEventListener('mousemove', this.handleChange);
	      window.addEventListener('mouseup', this.handleMouseUp);
	    },

	    handleMouseUp(e) {
	      this.unbindEventListeners();
	    },

	    unbindEventListeners() {
	      window.removeEventListener('mousemove', this.handleChange);
	      window.removeEventListener('mouseup', this.handleMouseUp);
	    }

	  }
	};

	/* script */
	const __vue_script__$8 = script$8;
	/* template */

	var __vue_render__$8 = function () {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    class: ["vc-hue", _vm.directionClass]
	  }, [_c("div", {
	    ref: "container",
	    staticClass: "vc-hue-container",
	    attrs: {
	      role: "slider",
	      "aria-valuenow": _vm.colors.hsl.h,
	      "aria-valuemin": "0",
	      "aria-valuemax": "360"
	    },
	    on: {
	      mousedown: _vm.handleMouseDown,
	      touchmove: _vm.handleChange,
	      touchstart: _vm.handleChange
	    }
	  }, [_c("div", {
	    staticClass: "vc-hue-pointer",
	    style: {
	      top: _vm.pointerTop,
	      left: _vm.pointerLeft
	    },
	    attrs: {
	      role: "presentation"
	    }
	  }, [_c("div", {
	    staticClass: "vc-hue-picker"
	  })])])]);
	};

	var __vue_staticRenderFns__$8 = [];
	__vue_render__$8._withStripped = true;
	/* style */

	const __vue_inject_styles__$8 = function (inject) {
	  if (!inject) return;
	  inject("data-v-8e130a42_0", {
	    source: "\n.vc-hue {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  border-radius: 2px;\n}\n.vc-hue--horizontal {\n  background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n}\n.vc-hue--vertical {\n  background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n}\n.vc-hue-container {\n  cursor: pointer;\n  margin: 0 2px;\n  position: relative;\n  height: 100%;\n}\n.vc-hue-pointer {\n  z-index: 2;\n  position: absolute;\n}\n.vc-hue-picker {\n  cursor: pointer;\n  margin-top: 1px;\n  width: 4px;\n  border-radius: 1px;\n  height: 8px;\n  box-shadow: 0 0 2px rgba(0, 0, 0, .6);\n  background: #fff;\n  transform: translateX(-2px) ;\n}\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\node_modules\\vue-color\\src\\components\\common\\Hue.vue"],
	      "names": [],
	      "mappings": ";AA8IA;EACA,kBAAA;EACA,QAAA;EACA,UAAA;EACA,WAAA;EACA,SAAA;EACA,kBAAA;AACA;AACA;EACA,2GAAA;AACA;AACA;EACA,yGAAA;AACA;AACA;EACA,eAAA;EACA,aAAA;EACA,kBAAA;EACA,YAAA;AACA;AACA;EACA,UAAA;EACA,kBAAA;AACA;AACA;EACA,eAAA;EACA,eAAA;EACA,UAAA;EACA,kBAAA;EACA,WAAA;EACA,qCAAA;EACA,gBAAA;EACA,4BAAA;AACA",
	      "file": "Hue.vue",
	      "sourcesContent": ["<template>\n  <div :class=\"['vc-hue', directionClass]\">\n    <div class=\"vc-hue-container\"\n      role=\"slider\"\n      :aria-valuenow=\"colors.hsl.h\"\n      aria-valuemin=\"0\"\n      aria-valuemax=\"360\"\n      ref=\"container\"\n      @mousedown=\"handleMouseDown\"\n      @touchmove=\"handleChange\"\n      @touchstart=\"handleChange\">\n      <div class=\"vc-hue-pointer\" :style=\"{top: pointerTop, left: pointerLeft}\" role=\"presentation\">\n        <div class=\"vc-hue-picker\"></div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'Hue',\n  props: {\n    value: Object,\n    direction: {\n      type: String,\n      // [horizontal | vertical]\n      default: 'horizontal'\n    }\n  },\n  data () {\n    return {\n      oldHue: 0,\n      pullDirection: ''\n    }\n  },\n  computed: {\n    colors () {\n      const h = this.value.hsl.h\n      if (h !== 0 && h - this.oldHue > 0) this.pullDirection = 'right'\n      if (h !== 0 && h - this.oldHue < 0) this.pullDirection = 'left'\n      this.oldHue = h\n\n      return this.value\n    },\n    directionClass () {\n      return {\n        'vc-hue--horizontal': this.direction === 'horizontal',\n        'vc-hue--vertical': this.direction === 'vertical'\n      }\n    },\n    pointerTop () {\n      if (this.direction === 'vertical') {\n        if (this.colors.hsl.h === 0 && this.pullDirection === 'right') return 0\n        return -((this.colors.hsl.h * 100) / 360) + 100 + '%'\n      } else {\n        return 0\n      }\n    },\n    pointerLeft () {\n      if (this.direction === 'vertical') {\n        return 0\n      } else {\n        if (this.colors.hsl.h === 0 && this.pullDirection === 'right') return '100%'\n        return (this.colors.hsl.h * 100) / 360 + '%'\n      }\n    }\n  },\n  methods: {\n    handleChange (e, skip) {\n      !skip && e.preventDefault()\n\n      var container = this.$refs.container\n      var containerWidth = container.clientWidth\n      var containerHeight = container.clientHeight\n\n      var xOffset = container.getBoundingClientRect().left + window.pageXOffset\n      var yOffset = container.getBoundingClientRect().top + window.pageYOffset\n      var pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0)\n      var pageY = e.pageY || (e.touches ? e.touches[0].pageY : 0)\n      var left = pageX - xOffset\n      var top = pageY - yOffset\n\n      var h\n      var percent\n\n      if (this.direction === 'vertical') {\n        if (top < 0) {\n          h = 360\n        } else if (top > containerHeight) {\n          h = 0\n        } else {\n          percent = -(top * 100 / containerHeight) + 100\n          h = (360 * percent / 100)\n        }\n\n        if (this.colors.hsl.h !== h) {\n          this.$emit('change', {\n            h: h,\n            s: this.colors.hsl.s,\n            l: this.colors.hsl.l,\n            a: this.colors.hsl.a,\n            source: 'hsl'\n          })\n        }\n      } else {\n        if (left < 0) {\n          h = 0\n        } else if (left > containerWidth) {\n          h = 360\n        } else {\n          percent = left * 100 / containerWidth\n          h = (360 * percent / 100)\n        }\n\n        if (this.colors.hsl.h !== h) {\n          this.$emit('change', {\n            h: h,\n            s: this.colors.hsl.s,\n            l: this.colors.hsl.l,\n            a: this.colors.hsl.a,\n            source: 'hsl'\n          })\n        }\n      }\n    },\n    handleMouseDown (e) {\n      this.handleChange(e, true)\n      window.addEventListener('mousemove', this.handleChange)\n      window.addEventListener('mouseup', this.handleMouseUp)\n    },\n    handleMouseUp (e) {\n      this.unbindEventListeners()\n    },\n    unbindEventListeners () {\n      window.removeEventListener('mousemove', this.handleChange)\n      window.removeEventListener('mouseup', this.handleMouseUp)\n    }\n  }\n}\n</script>\n\n<style>\n.vc-hue {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  border-radius: 2px;\n}\n.vc-hue--horizontal {\n  background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n}\n.vc-hue--vertical {\n  background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n}\n.vc-hue-container {\n  cursor: pointer;\n  margin: 0 2px;\n  position: relative;\n  height: 100%;\n}\n.vc-hue-pointer {\n  z-index: 2;\n  position: absolute;\n}\n.vc-hue-picker {\n  cursor: pointer;\n  margin-top: 1px;\n  width: 4px;\n  border-radius: 1px;\n  height: 8px;\n  box-shadow: 0 0 2px rgba(0, 0, 0, .6);\n  background: #fff;\n  transform: translateX(-2px) ;\n}\n</style>\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	const __vue_scope_id__$8 = undefined;
	/* module identifier */

	const __vue_module_identifier__$8 = undefined;
	/* functional template */

	const __vue_is_functional_template__$8 = false;
	/* style inject SSR */

	/* style inject shadow dom */

	const __vue_component__$8 = normalizeComponent({
	  render: __vue_render__$8,
	  staticRenderFns: __vue_staticRenderFns__$8
	}, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, false, createInjector, undefined, undefined);

	//
	var script$9 = {
	  name: 'Alpha',
	  props: {
	    value: Object,
	    onChange: Function
	  },
	  components: {
	    checkboard: __vue_component__$4
	  },
	  computed: {
	    colors() {
	      return this.value;
	    },

	    gradientColor() {
	      var rgba = this.colors.rgba;
	      var rgbStr = [rgba.r, rgba.g, rgba.b].join(',');
	      return 'linear-gradient(to right, rgba(' + rgbStr + ', 0) 0%, rgba(' + rgbStr + ', 1) 100%)';
	    }

	  },
	  methods: {
	    handleChange(e, skip) {
	      !skip && e.preventDefault();
	      var container = this.$refs.container;
	      var containerWidth = container.clientWidth;
	      var xOffset = container.getBoundingClientRect().left + window.pageXOffset;
	      var pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0);
	      var left = pageX - xOffset;
	      var a;

	      if (left < 0) {
	        a = 0;
	      } else if (left > containerWidth) {
	        a = 1;
	      } else {
	        a = Math.round(left * 100 / containerWidth) / 100;
	      }

	      if (this.colors.a !== a) {
	        this.$emit('change', {
	          h: this.colors.hsl.h,
	          s: this.colors.hsl.s,
	          l: this.colors.hsl.l,
	          a: a,
	          source: 'rgba'
	        });
	      }
	    },

	    handleMouseDown(e) {
	      this.handleChange(e, true);
	      window.addEventListener('mousemove', this.handleChange);
	      window.addEventListener('mouseup', this.handleMouseUp);
	    },

	    handleMouseUp() {
	      this.unbindEventListeners();
	    },

	    unbindEventListeners() {
	      window.removeEventListener('mousemove', this.handleChange);
	      window.removeEventListener('mouseup', this.handleMouseUp);
	    }

	  }
	};

	/* script */
	const __vue_script__$9 = script$9;
	/* template */

	var __vue_render__$9 = function () {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "vc-alpha"
	  }, [_c("div", {
	    staticClass: "vc-alpha-checkboard-wrap"
	  }, [_c("checkboard")], 1), _vm._v(" "), _c("div", {
	    staticClass: "vc-alpha-gradient",
	    style: {
	      background: _vm.gradientColor
	    }
	  }), _vm._v(" "), _c("div", {
	    ref: "container",
	    staticClass: "vc-alpha-container",
	    on: {
	      mousedown: _vm.handleMouseDown,
	      touchmove: _vm.handleChange,
	      touchstart: _vm.handleChange
	    }
	  }, [_c("div", {
	    staticClass: "vc-alpha-pointer",
	    style: {
	      left: _vm.colors.a * 100 + "%"
	    }
	  }, [_c("div", {
	    staticClass: "vc-alpha-picker"
	  })])])]);
	};

	var __vue_staticRenderFns__$9 = [];
	__vue_render__$9._withStripped = true;
	/* style */

	const __vue_inject_styles__$9 = function (inject) {
	  if (!inject) return;
	  inject("data-v-3c31834e_0", {
	    source: "\n.vc-alpha {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n}\n.vc-alpha-checkboard-wrap {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  overflow: hidden;\n}\n.vc-alpha-gradient {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n}\n.vc-alpha-container {\n  cursor: pointer;\n  position: relative;\n  z-index: 2;\n  height: 100%;\n  margin: 0 3px;\n}\n.vc-alpha-pointer {\n  z-index: 2;\n  position: absolute;\n}\n.vc-alpha-picker {\n  cursor: pointer;\n  width: 4px;\n  border-radius: 1px;\n  height: 8px;\n  box-shadow: 0 0 2px rgba(0, 0, 0, .6);\n  background: #fff;\n  margin-top: 1px;\n  transform: translateX(-2px);\n}\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\node_modules\\vue-color\\src\\components\\common\\Alpha.vue"],
	      "names": [],
	      "mappings": ";AAsFA;EACA,kBAAA;EACA,QAAA;EACA,UAAA;EACA,WAAA;EACA,SAAA;AACA;AACA;EACA,kBAAA;EACA,QAAA;EACA,UAAA;EACA,WAAA;EACA,SAAA;EACA,gBAAA;AACA;AACA;EACA,kBAAA;EACA,QAAA;EACA,UAAA;EACA,WAAA;EACA,SAAA;AACA;AACA;EACA,eAAA;EACA,kBAAA;EACA,UAAA;EACA,YAAA;EACA,aAAA;AACA;AACA;EACA,UAAA;EACA,kBAAA;AACA;AACA;EACA,eAAA;EACA,UAAA;EACA,kBAAA;EACA,WAAA;EACA,qCAAA;EACA,gBAAA;EACA,eAAA;EACA,2BAAA;AACA",
	      "file": "Alpha.vue",
	      "sourcesContent": ["<template>\n  <div class=\"vc-alpha\">\n    <div class=\"vc-alpha-checkboard-wrap\">\n      <checkboard></checkboard>\n    </div>\n    <div class=\"vc-alpha-gradient\" :style=\"{background: gradientColor}\"></div>\n    <div class=\"vc-alpha-container\" ref=\"container\"\n        @mousedown=\"handleMouseDown\"\n        @touchmove=\"handleChange\"\n        @touchstart=\"handleChange\">\n      <div class=\"vc-alpha-pointer\" :style=\"{left: colors.a * 100 + '%'}\">\n        <div class=\"vc-alpha-picker\"></div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport checkboard from './Checkboard.vue'\n\nexport default {\n  name: 'Alpha',\n  props: {\n    value: Object,\n    onChange: Function\n  },\n  components: {\n    checkboard\n  },\n  computed: {\n    colors () {\n      return this.value\n    },\n    gradientColor () {\n      var rgba = this.colors.rgba\n      var rgbStr = [rgba.r, rgba.g, rgba.b].join(',')\n      return 'linear-gradient(to right, rgba(' + rgbStr + ', 0) 0%, rgba(' + rgbStr + ', 1) 100%)'\n    }\n  },\n  methods: {\n    handleChange (e, skip) {\n      !skip && e.preventDefault()\n      var container = this.$refs.container\n      var containerWidth = container.clientWidth\n\n      var xOffset = container.getBoundingClientRect().left + window.pageXOffset\n      var pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0)\n      var left = pageX - xOffset\n\n      var a\n      if (left < 0) {\n        a = 0\n      } else if (left > containerWidth) {\n        a = 1\n      } else {\n        a = Math.round(left * 100 / containerWidth) / 100\n      }\n\n      if (this.colors.a !== a) {\n        this.$emit('change', {\n          h: this.colors.hsl.h,\n          s: this.colors.hsl.s,\n          l: this.colors.hsl.l,\n          a: a,\n          source: 'rgba'\n        })\n      }\n    },\n    handleMouseDown (e) {\n      this.handleChange(e, true)\n      window.addEventListener('mousemove', this.handleChange)\n      window.addEventListener('mouseup', this.handleMouseUp)\n    },\n    handleMouseUp () {\n      this.unbindEventListeners()\n    },\n    unbindEventListeners () {\n      window.removeEventListener('mousemove', this.handleChange)\n      window.removeEventListener('mouseup', this.handleMouseUp)\n    }\n  }\n}\n\n</script>\n\n<style>\n.vc-alpha {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n}\n.vc-alpha-checkboard-wrap {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  overflow: hidden;\n}\n.vc-alpha-gradient {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n}\n.vc-alpha-container {\n  cursor: pointer;\n  position: relative;\n  z-index: 2;\n  height: 100%;\n  margin: 0 3px;\n}\n.vc-alpha-pointer {\n  z-index: 2;\n  position: absolute;\n}\n.vc-alpha-picker {\n  cursor: pointer;\n  width: 4px;\n  border-radius: 1px;\n  height: 8px;\n  box-shadow: 0 0 2px rgba(0, 0, 0, .6);\n  background: #fff;\n  margin-top: 1px;\n  transform: translateX(-2px);\n}\n</style>\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	const __vue_scope_id__$9 = undefined;
	/* module identifier */

	const __vue_module_identifier__$9 = undefined;
	/* functional template */

	const __vue_is_functional_template__$9 = false;
	/* style inject SSR */

	/* style inject shadow dom */

	const __vue_component__$9 = normalizeComponent({
	  render: __vue_render__$9,
	  staticRenderFns: __vue_staticRenderFns__$9
	}, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, false, createInjector, undefined, undefined);

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	var script$a = {};

	/* script */
	var __vue_script__$a = script$a;
	/* template */

	var __vue_render__$a = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "vg-toggle-button",
	    attrs: {
	      role: "button"
	    },
	    on: {
	      click: function click($event) {
	        return _vm.$emit("toggle");
	      }
	    }
	  }, [_c("div", {
	    staticClass: "vg-toggle-icon"
	  }, [_c("svg", {
	    attrs: {
	      xmlns: "http://www.w3.org/2000/svg",
	      width: "16",
	      height: "16",
	      viewBox: "0 0 16 16"
	    }
	  }, [_c("path", {
	    attrs: {
	      d: "M11 7h-6l3-4z"
	    }
	  }), _vm._v(" "), _c("path", {
	    attrs: {
	      d: "M5 9h6l-3 4z"
	    }
	  })])])]);
	};

	var __vue_staticRenderFns__$a = [];
	__vue_render__$a._withStripped = true;
	/* style */

	var __vue_inject_styles__$a = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-665ea8ad_0", {
	    source: "\n.vg-toggle-button {\r\n    cursor: pointer;\r\n    display: inline-flex;\n}\n.vg-toggle-button:hover {\r\n    background: #eee;\n}\n.vg-toggle-icon {\r\n    margin: 0;\r\n    border: none;\r\n    border-radius: 0;\r\n    overflow: visible;\r\n    font: inherit;\r\n    color: inherit;\r\n    text-transform: none;\r\n    padding: 0;\r\n    background-color: transparent;\r\n    display: inline-block;\r\n    fill: currentcolor;\r\n    line-height: 0;\n}\r\n\r\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\vendor\\assets\\js\\components\\common\\ToggleButton.vue"],
	      "names": [],
	      "mappings": ";AA0BA;IACA,eAAA;IACA,oBAAA;AACA;AAEA;IACA,gBAAA;AACA;AAEA;IACA,SAAA;IACA,YAAA;IACA,gBAAA;IACA,iBAAA;IACA,aAAA;IACA,cAAA;IACA,oBAAA;IACA,UAAA;IACA,6BAAA;IACA,qBAAA;IACA,kBAAA;IACA,cAAA;AACA",
	      "file": "ToggleButton.vue",
	      "sourcesContent": ["<template>\r\n\r\n    <div class=\"vg-toggle-button\" role=\"button\" @click=\"$emit('toggle')\">\r\n        <div class=\"vg-toggle-icon\">\r\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\r\n            \t<path d=\"M11 7h-6l3-4z\" />\r\n            \t<path d=\"M5 9h6l-3 4z\" />\r\n            </svg>\r\n            <!--svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\">\r\n                <path d=\"M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z\" />\r\n            </svg-->\r\n        </div>\r\n    </div>\r\n\r\n</template>\r\n\r\n<script>\r\n\r\nexport default {\r\n\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\n\r\n.vg-toggle-button {\r\n    cursor: pointer;\r\n    display: inline-flex;\r\n}\r\n\r\n.vg-toggle-button:hover {\r\n    background: #eee;\r\n}\r\n\r\n.vg-toggle-icon {\r\n    margin: 0;\r\n    border: none;\r\n    border-radius: 0;\r\n    overflow: visible;\r\n    font: inherit;\r\n    color: inherit;\r\n    text-transform: none;\r\n    padding: 0;\r\n    background-color: transparent;\r\n    display: inline-block;\r\n    fill: currentcolor;\r\n    line-height: 0;\r\n}\r\n\r\n</style>\r\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	var __vue_scope_id__$a = undefined;
	/* module identifier */

	var __vue_module_identifier__$a = undefined;
	/* functional template */

	var __vue_is_functional_template__$a = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$a = normalizeComponent({
	  render: __vue_render__$a,
	  staticRenderFns: __vue_staticRenderFns__$a
	}, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, false, createInjector, undefined, undefined);

	//
	var presetColors = ['#D0021B', '#F5A623', '#F8E71C', '#8B572A', '#7ED321', '#417505', '#BD10E0', '#9013FE', '#4A90E2', '#50E3C2', '#B8E986', '#000000', '#4A4A4A', '#9B9B9B', '#FFFFFF', 'rgba(0,0,0,0)'];
	var script$b = {
	  mixins: [ColorMixin],
	  components: {
	    Saturation: __vue_component__$7,
	    Hue: __vue_component__$8,
	    Alpha: __vue_component__$9,
	    EditableInput: __vue_component__$6,
	    Checkboard: __vue_component__$4,
	    Colorsymbol: __vue_component__$5,
	    ToggleButton: __vue_component__$a
	  },
	  props: {
	    presetColorsUsed: {
	      type: Array,
	      "default": function _default() {
	        return [];
	      }
	    },
	    presetColors: {
	      type: Array,
	      "default": function _default() {
	        return presetColors;
	      }
	    },
	    presetLength: {
	      type: Number,
	      "default": function _default() {
	        return 16;
	      }
	    },
	    disableAlpha: {
	      type: Boolean,
	      "default": false
	    },
	    disableFields: {
	      type: Boolean,
	      "default": false
	    }
	  },
	  data: function data() {
	    return {
	      color: this.value,
	      showAllColors: false,
	      showAllColorsUsed: false
	    };
	  },
	  computed: {
	    colors: {
	      get: function get() {
	        return this.val;
	      },
	      set: function set(newVal) {
	        var rgba = newVal.rgba,
	            source = newVal.source;
	        this.val = newVal;
	        this.color = this.hasNone(source) || this.hasKeyword(source) ? source : "rgba(" + [rgba.r, rgba.g, rgba.b, rgba.a].join(',') + ")";
	        this.$emit('input', this.color);
	      }
	    },
	    hex: function hex() {
	      var hex;

	      if (this.colors.a < 1) {
	        hex = this.colors.hex8;
	      } else {
	        hex = this.colors.hex;
	      }

	      return hex.replace('#', '');
	    },
	    isValid: function isValid() {
	      return !this.hasNone(this.color) && !this.hasKeyword(this.color) || '';
	    }
	  },
	  watch: {
	    value: function value(newVal) {
	      this.color = newVal;
	    }
	  },
	  methods: {
	    handlePreset: function handlePreset(c) {
	      this.colorChange({
	        hex: c,
	        source: this.hasNone(c) || this.hasKeyword(c) ? c : 'hex'
	      });
	    },
	    childChange: function childChange(data) {
	      this.colorChange(data);
	    },
	    inputChange: function inputChange(data) {
	      if (!data) {
	        return;
	      }

	      if (data.hex) {
	        this.isValidHex(data.hex) && this.colorChange({
	          hex: data.hex,
	          source: 'hex'
	        });
	      } else if (data.r || data.g || data.b || data.a) {
	        this.colorChange({
	          r: data.r || this.colors.rgba.r,
	          g: data.g || this.colors.rgba.g,
	          b: data.b || this.colors.rgba.b,
	          a: data.a || this.colors.rgba.a,
	          source: 'rgba'
	        });
	      }
	    },
	    hasNone: function hasNone(color) {
	      return '' === color;
	    },
	    hasKeyword: function hasKeyword(color) {
	      return ['currentColor', 'currentcolor', 'inherit', 'initial', 'unset'].includes(color);
	    }
	  }
	};

	/* script */
	var __vue_script__$b = script$b;
	/* template */

	var __vue_render__$b = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    "class": ["vc-styles", _vm.disableAlpha ? "vc-styles__disable-alpha" : ""],
	    attrs: {
	      role: "application",
	      "aria-label": "styles color picker"
	    }
	  }, [_c("div", {
	    staticClass: "vc-styles-saturation-wrap"
	  }, [_c("saturation", {
	    on: {
	      change: _vm.childChange
	    },
	    model: {
	      value: _vm.colors,
	      callback: function callback($$v) {
	        _vm.colors = $$v;
	      },
	      expression: "colors"
	    }
	  })], 1), _vm._v(" "), _c("div", {
	    staticClass: "vc-styles-controls"
	  }, [_c("div", {
	    staticClass: "vc-styles-sliders"
	  }, [_c("div", {
	    staticClass: "vc-styles-hue-wrap"
	  }, [_c("hue", {
	    on: {
	      change: _vm.childChange
	    },
	    model: {
	      value: _vm.colors,
	      callback: function callback($$v) {
	        _vm.colors = $$v;
	      },
	      expression: "colors"
	    }
	  })], 1), _vm._v(" "), !_vm.disableAlpha ? _c("div", {
	    staticClass: "vc-styles-alpha-wrap"
	  }, [_c("alpha", {
	    on: {
	      change: _vm.childChange
	    },
	    model: {
	      value: _vm.colors,
	      callback: function callback($$v) {
	        _vm.colors = $$v;
	      },
	      expression: "colors"
	    }
	  })], 1) : _vm._e()]), _vm._v(" "), _c("div", {
	    staticClass: "vc-styles-color-wrap"
	  }, [_c("div", {
	    staticClass: "vc-styles-active-color",
	    style: {
	      background: _vm.isValid && _vm.color
	    },
	    attrs: {
	      "aria-label": "Current color is " + _vm.color
	    }
	  }), _vm._v(" "), _vm.hasNone(_vm.color) || _vm.hasKeyword(_vm.color) ? _c("colorsymbol", {
	    attrs: {
	      type: _vm.color
	    }
	  }) : _c("checkboard")], 1)]), _vm._v(" "), !_vm.disableFields ? _c("div", {
	    staticClass: "vc-styles-field"
	  }, [_c("div", {
	    staticClass: "vc-styles-field--double"
	  }, [_c("editable-input", {
	    attrs: {
	      label: "hex",
	      value: _vm.isValid && _vm.hex
	    },
	    on: {
	      change: _vm.inputChange
	    }
	  })], 1), _vm._v(" "), _c("div", {
	    staticClass: "vc-styles-field--single"
	  }, [_c("editable-input", {
	    attrs: {
	      label: "r",
	      value: _vm.isValid && _vm.colors.rgba.r
	    },
	    on: {
	      change: _vm.inputChange
	    }
	  })], 1), _vm._v(" "), _c("div", {
	    staticClass: "vc-styles-field--single"
	  }, [_c("editable-input", {
	    attrs: {
	      label: "g",
	      value: _vm.isValid && _vm.colors.rgba.g
	    },
	    on: {
	      change: _vm.inputChange
	    }
	  })], 1), _vm._v(" "), _c("div", {
	    staticClass: "vc-styles-field--single"
	  }, [_c("editable-input", {
	    attrs: {
	      label: "b",
	      value: _vm.isValid && _vm.colors.rgba.b
	    },
	    on: {
	      change: _vm.inputChange
	    }
	  })], 1), _vm._v(" "), !_vm.disableAlpha ? _c("div", {
	    staticClass: "vc-styles-field--single"
	  }, [_c("editable-input", {
	    attrs: {
	      label: "a",
	      value: _vm.isValid && _vm.colors.a,
	      "arrow-offset": 0.01,
	      max: 1
	    },
	    on: {
	      change: _vm.inputChange
	    }
	  })], 1) : _vm._e()]) : _vm._e(), _vm._v(" "), _vm.presetColorsUsed && _vm.presetColorsUsed.length ? _c("div", {
	    staticClass: "vc-styles-presets",
	    attrs: {
	      role: "group",
	      "aria-label": "A color preset, pick one to set as current color"
	    }
	  }, [_c("div", {
	    staticClass: "uk-width-expand"
	  }, [_vm._l(_vm.presetColorsUsed, function (c, i) {
	    return [_vm.showAllColorsUsed || i < _vm.presetLength ? _c("div", {
	      key: c.value,
	      staticClass: "vc-styles-presets-color",
	      attrs: {
	        "aria-label": "Color:" + c.value,
	        title: c.name
	      },
	      on: {
	        click: function click($event) {
	          return _vm.handlePreset(c.value);
	        }
	      }
	    }, [_c("div", {
	      staticClass: "vc-styles-active-color",
	      style: {
	        background: !_vm.hasNone(c.value) && !_vm.hasKeyword(c.value) && c.value
	      }
	    }), _vm._v(" "), _vm.hasNone(c.value) || _vm.hasKeyword(c.value) ? _c("colorsymbol", {
	      attrs: {
	        type: c.value
	      }
	    }) : _c("checkboard")], 1) : _vm._e()];
	  })], 2), _vm._v(" "), _vm.presetColorsUsed.length > _vm.presetLength ? _c("div", {
	    staticClass: "vc-styles-presets-toggle-button-wrap"
	  }, [_c("toggle-button", {
	    on: {
	      toggle: function toggle($event) {
	        _vm.showAllColorsUsed = !_vm.showAllColorsUsed;
	      }
	    }
	  })], 1) : _vm._e()]) : _vm._e(), _vm._v(" "), _vm.presetColors && _vm.presetColors.length ? _c("div", {
	    staticClass: "vc-styles-presets",
	    attrs: {
	      role: "group",
	      "aria-label": "A color preset, pick one to set as current color"
	    }
	  }, [_c("div", {
	    staticClass: "uk-width-expand"
	  }, [_vm._l(_vm.presetColors, function (c, i) {
	    return [_vm.showAllColors || i < _vm.presetLength ? _c("div", {
	      key: c,
	      staticClass: "vc-styles-presets-color",
	      attrs: {
	        "aria-label": "Color:" + c
	      },
	      on: {
	        click: function click($event) {
	          return _vm.handlePreset(c);
	        }
	      }
	    }, [_c("div", {
	      staticClass: "vc-styles-active-color",
	      style: {
	        background: !_vm.hasNone(c) && !_vm.hasKeyword(c) && c
	      }
	    }), _vm._v(" "), _vm.hasNone(c) || _vm.hasKeyword(c) ? _c("colorsymbol", {
	      attrs: {
	        type: c
	      }
	    }) : _c("checkboard")], 1) : _vm._e()];
	  })], 2), _vm._v(" "), _vm.presetColors.length > _vm.presetLength ? _c("div", {
	    staticClass: "vc-styles-presets-toggle-button-wrap"
	  }, [_c("toggle-button", {
	    on: {
	      toggle: function toggle($event) {
	        _vm.showAllColors = !_vm.showAllColors;
	      }
	    }
	  })], 1) : _vm._e()]) : _vm._e()]);
	};

	var __vue_staticRenderFns__$b = [];
	__vue_render__$b._withStripped = true;
	/* style */

	var __vue_inject_styles__$b = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-69917f06_0", {
	    source: "\n.vc-styles {\r\n    position: relative;\r\n    background: #fff;\n}\n.vc-styles-saturation-wrap {\r\n    width: 100%;\r\n    padding-bottom: 50%;\r\n    position: relative;\r\n    overflow: hidden;\n}\n.vc-styles-controls {\r\n    display: flex;\n}\n.vc-styles-sliders {\r\n    padding: 4px 0;\r\n    flex: 1;\n}\n.vc-styles-sliders .vc-hue,\r\n.vc-styles-sliders .vc-alpha-gradient {\r\n    border-radius: 2px;\n}\n.vc-styles-hue-wrap {\r\n    position: relative;\r\n    height: 10px;\n}\n.vc-styles-alpha-wrap {\r\n    position: relative;\r\n    height: 10px;\r\n    margin-top: 4px;\r\n    overflow: hidden;\n}\n.vc-styles-color-wrap {\r\n    width: 24px;\r\n    height: 24px;\r\n    position: relative;\r\n    margin-top: 4px;\r\n    margin-left: 4px;\r\n    border-radius: 3px;\n}\n.vc-styles-active-color {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    border-radius: 2px;\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15);\r\n    z-index: 2;\n}\n.vc-styles-color-wrap .vc-checkerboard {\r\n    background-size: auto;\n}\n.vc-styles-field {\r\n    display: flex;\r\n    padding-top: 4px;\n}\n.vc-styles-field .vc-input__input {\r\n    width: 90%;\r\n    padding: 4px 2px 3px;\r\n    border: none;\r\n    box-shadow: inset 0 0 0 1px #ccc;\r\n    font-size: 10px;\r\n    text-align: center;\n}\n.vc-styles-field .vc-input__label {\r\n    display: block;\r\n    text-align: center;\r\n    font-size: 11px;\r\n    color: #222;\r\n    padding-top: 3px;\r\n    padding-bottom: 4px;\r\n    text-transform: capitalize;\n}\n.vc-styles-field--single {\r\n    flex: 1;\r\n    padding-left: 6px;\n}\n.vc-styles-field--double {\r\n    flex: 2;\n}\n.vc-styles-presets {\r\n    margin-right: -10px;\r\n    margin-left: -10px;\r\n    padding-left: 10px;\r\n    padding-top: 10px;\r\n    border-top: 1px solid #eee;\r\n    display: flex;\r\n    flex-wrap: wrap;\n}\n.vc-styles-presets-color {\r\n    border-radius: 3px;\r\n    overflow: hidden;\r\n    position: relative;\r\n    display: inline-block;\r\n    margin: 0 10px 10px 0;\r\n    vertical-align: top;\r\n    cursor: pointer;\r\n    width: 16px;\r\n    height: 16px;\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15);\n}\n.vc-styles-presets-color .vc-styles-active-color {\r\n    border-radius: 3px;\n}\n.vc-styles__disable-alpha .vc-styles-color-wrap {\r\n    height: 10px;\n}\n.vc-styles-presets-toggle-button-wrap {\r\n    width: 26px;\r\n    display: flex;\r\n    align-items: flex-start;\n}\n.vc-styles-presets .vg-toggle-button {\r\n    border-radius: 3px;\r\n    display: inline-flex;\n}\r\n\r\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\vendor\\assets\\js\\components\\common\\ColorControls.vue"],
	      "names": [],
	      "mappings": ";AAiPA;IACA,kBAAA;IACA,gBAAA;AACA;AAEA;IACA,WAAA;IACA,mBAAA;IACA,kBAAA;IACA,gBAAA;AACA;AAEA;IACA,aAAA;AACA;AAEA;IACA,cAAA;IACA,OAAA;AACA;AAEA;;IAEA,kBAAA;AACA;AAEA;IACA,kBAAA;IACA,YAAA;AACA;AAEA;IACA,kBAAA;IACA,YAAA;IACA,eAAA;IACA,gBAAA;AACA;AAEA;IACA,WAAA;IACA,YAAA;IACA,kBAAA;IACA,eAAA;IACA,gBAAA;IACA,kBAAA;AACA;AAEA;IACA,kBAAA;IACA,MAAA;IACA,OAAA;IACA,QAAA;IACA,SAAA;IACA,kBAAA;IACA,8CAAA;IACA,UAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,aAAA;IACA,gBAAA;AACA;AAEA;IACA,UAAA;IACA,oBAAA;IACA,YAAA;IACA,gCAAA;IACA,eAAA;IACA,kBAAA;AACA;AAEA;IACA,cAAA;IACA,kBAAA;IACA,eAAA;IACA,WAAA;IACA,gBAAA;IACA,mBAAA;IACA,0BAAA;AACA;AAEA;IACA,OAAA;IACA,iBAAA;AACA;AAEA;IACA,OAAA;AACA;AAEA;IACA,mBAAA;IACA,kBAAA;IACA,kBAAA;IACA,iBAAA;IACA,0BAAA;IACA,aAAA;IACA,eAAA;AACA;AAEA;IACA,kBAAA;IACA,gBAAA;IACA,kBAAA;IACA,qBAAA;IACA,qBAAA;IACA,mBAAA;IACA,eAAA;IACA,WAAA;IACA,YAAA;IACA,8CAAA;AACA;AAEA;IACA,kBAAA;AACA;AAEA;IACA,YAAA;AACA;AAEA;IACA,WAAA;IACA,aAAA;IACA,uBAAA;AACA;AAEA;IACA,kBAAA;IACA,oBAAA;AACA",
	      "file": "ColorControls.vue",
	      "sourcesContent": ["<template>\r\n\r\n    <div role=\"application\" aria-label=\"styles color picker\" :class=\"['vc-styles', disableAlpha ? 'vc-styles__disable-alpha' : '']\">\r\n\r\n        <div class=\"vc-styles-saturation-wrap\">\r\n            <saturation v-model=\"colors\" @change=\"childChange\" />\r\n        </div>\r\n\r\n        <div class=\"vc-styles-controls\">\r\n            <div class=\"vc-styles-sliders\">\r\n                <div class=\"vc-styles-hue-wrap\">\r\n                    <hue v-model=\"colors\" @change=\"childChange\" />\r\n                </div>\r\n                <div class=\"vc-styles-alpha-wrap\" v-if=\"!disableAlpha\">\r\n                    <alpha v-model=\"colors\" @change=\"childChange\" />\r\n                </div>\r\n            </div>\r\n            <div class=\"vc-styles-color-wrap\">\r\n                <div :aria-label=\"`Current color is ${color}`\" class=\"vc-styles-active-color\" :style=\"{ background: isValid && color }\" />\r\n                <colorsymbol v-if=\"hasNone(color) || hasKeyword(color)\" :type=\"color\" />\r\n                <checkboard v-else />\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"vc-styles-field\" v-if=\"!disableFields\">\r\n            <div class=\"vc-styles-field--double\">\r\n                <editable-input label=\"hex\" :value=\"isValid && hex\" @change=\"inputChange\" />\r\n            </div>\r\n            <div class=\"vc-styles-field--single\">\r\n                <editable-input label=\"r\" :value=\"isValid && colors.rgba.r\" @change=\"inputChange\" />\r\n            </div>\r\n            <div class=\"vc-styles-field--single\">\r\n                <editable-input label=\"g\" :value=\"isValid && colors.rgba.g\" @change=\"inputChange\" />\r\n            </div>\r\n            <div class=\"vc-styles-field--single\">\r\n                <editable-input label=\"b\" :value=\"isValid && colors.rgba.b\" @change=\"inputChange\" />\r\n            </div>\r\n            <div class=\"vc-styles-field--single\" v-if=\"!disableAlpha\">\r\n                <editable-input label=\"a\" :value=\"isValid && colors.a\" :arrow-offset=\"0.01\" :max=\"1\" @change=\"inputChange\" />\r\n            </div>\r\n        </div>\r\n\r\n        <div v-if=\"presetColorsUsed && presetColorsUsed.length\" class=\"vc-styles-presets\" role=\"group\" aria-label=\"A color preset, pick one to set as current color\">\r\n            <div class=\"uk-width-expand\">\r\n                <template v-for=\"(c, i) in presetColorsUsed\">\r\n                    <div v-if=\"showAllColorsUsed || i < presetLength\" class=\"vc-styles-presets-color\" :key=\"c.value\" :aria-label=\"'Color:' + c.value\" :title=\"c.name\" @click=\"handlePreset(c.value)\">\r\n                        <div class=\"vc-styles-active-color\" :style=\"{ background: !hasNone(c.value) && !hasKeyword(c.value) && c.value }\" />\r\n                        <colorsymbol v-if=\"hasNone(c.value) || hasKeyword(c.value)\" :type=\"c.value\" />\r\n                        <checkboard v-else />\r\n                    </div>\r\n                </template>\r\n            </div>\r\n            <div v-if=\"presetColorsUsed.length > presetLength\" class=\"vc-styles-presets-toggle-button-wrap\">\r\n                <toggle-button @toggle=\"showAllColorsUsed = !showAllColorsUsed\" />\r\n            </div>\r\n        </div>\r\n\r\n        <div v-if=\"presetColors && presetColors.length\" class=\"vc-styles-presets\" role=\"group\" aria-label=\"A color preset, pick one to set as current color\">\r\n            <div class=\"uk-width-expand\">\r\n                <template v-for=\"(c, i) in presetColors\">\r\n                    <div v-if=\"showAllColors || i < presetLength\" class=\"vc-styles-presets-color\" :key=\"c\" :aria-label=\"'Color:' + c\" @click=\"handlePreset(c)\">\r\n                        <div class=\"vc-styles-active-color\" :style=\"{ background: !hasNone(c) && !hasKeyword(c) && c }\" />\r\n                        <colorsymbol v-if=\"hasNone(c) || hasKeyword(c)\" :type=\"c\" />\r\n                        <checkboard v-else />\r\n                    </div>\r\n                </template>\r\n            </div>\r\n            <div v-if=\"presetColors.length > presetLength\" class=\"vc-styles-presets-toggle-button-wrap\">\r\n                <toggle-button @toggle=\"showAllColors = !showAllColors\" />\r\n            </div>\r\n        </div>\r\n\r\n    </div>\r\n\r\n</template>\r\n\r\n<script>\r\n\r\nimport ColorMixin from 'vue-color/src/mixin/color'\r\nimport EditableInput from 'vue-color/src/components/common/EditableInput.vue'\r\nimport Saturation from 'vue-color/src/components/common/Saturation.vue'\r\nimport Hue from 'vue-color/src/components/common/Hue.vue'\r\nimport Alpha from 'vue-color/src/components/common/Alpha.vue'\r\nimport Checkboard from 'vue-color/src/components/common/Checkboard.vue'\r\nimport Colorsymbol from './Colorsymbol.vue'\r\nimport ToggleButton from './ToggleButton.vue'\r\n\r\nconst presetColors = [\r\n    '#D0021B', '#F5A623', '#F8E71C', '#8B572A', '#7ED321',\r\n    '#417505', '#BD10E0', '#9013FE', '#4A90E2', '#50E3C2',\r\n    '#B8E986', '#000000', '#4A4A4A', '#9B9B9B', '#FFFFFF',\r\n    'rgba(0,0,0,0)'\r\n]\r\n\r\nexport default {\r\n\r\n    mixins: [ ColorMixin ],\r\n\r\n    components: {\r\n        Saturation,\r\n        Hue,\r\n        Alpha,\r\n        EditableInput,\r\n        Checkboard,\r\n        Colorsymbol,\r\n        ToggleButton\r\n    },\r\n\r\n    props: {\r\n\r\n        presetColorsUsed: {\r\n            type: Array,\r\n            default () {\r\n                return []\r\n            }\r\n        },\r\n\r\n        presetColors: {\r\n            type: Array,\r\n            default () {\r\n                return presetColors\r\n            }\r\n        },\r\n\r\n        presetLength: {\r\n            type: Number,\r\n            default () {\r\n                return 16\r\n            }\r\n        },\r\n\r\n        disableAlpha: {\r\n            type: Boolean,\r\n            default: false\r\n        },\r\n\r\n        disableFields: {\r\n            type: Boolean,\r\n            default: false\r\n        }\r\n\r\n    },\r\n\r\n    data () {\r\n        return {\r\n            color: this.value,\r\n            showAllColors: false,\r\n            showAllColorsUsed: false\r\n        }\r\n    },\r\n\r\n    computed: {\r\n\r\n        colors: {\r\n\r\n            get () {\r\n                return this.val\r\n            },\r\n\r\n            set (newVal) {\r\n                const { rgba, source } = newVal\r\n                this.val = newVal\r\n                this.color = this.hasNone(source) || this.hasKeyword(source) ? source : `rgba(${[rgba.r, rgba.g, rgba.b, rgba.a].join(',')})`\r\n                this.$emit('input', this.color)\r\n            }\r\n\r\n        },\r\n\r\n        hex () {\r\n            let hex\r\n            if (this.colors.a < 1) {\r\n                hex = this.colors.hex8\r\n            } else {\r\n                hex = this.colors.hex\r\n            }\r\n            return hex.replace('#', '')\r\n        },\r\n\r\n        isValid () {\r\n            return !this.hasNone(this.color) && !this.hasKeyword(this.color) || ''\r\n        }\r\n\r\n    },\r\n\r\n    watch: {\r\n\r\n        value (newVal) {\r\n            this.color = newVal\r\n        }\r\n\r\n    },\r\n\r\n    methods: {\r\n\r\n        handlePreset (c) {\r\n            this.colorChange({\r\n                hex: c,\r\n                source: this.hasNone(c) || this.hasKeyword(c) ? c : 'hex'\r\n            })\r\n        },\r\n\r\n        childChange (data) {\r\n            this.colorChange(data)\r\n        },\r\n\r\n        inputChange (data) {\r\n            if (!data) {\r\n                return\r\n            }\r\n            if (data.hex) {\r\n                this.isValidHex(data.hex) && this.colorChange({\r\n                    hex: data.hex,\r\n                    source: 'hex'\r\n                })\r\n            } else if (data.r || data.g || data.b || data.a) {\r\n                this.colorChange({\r\n                    r: data.r || this.colors.rgba.r,\r\n                    g: data.g || this.colors.rgba.g,\r\n                    b: data.b || this.colors.rgba.b,\r\n                    a: data.a || this.colors.rgba.a,\r\n                    source: 'rgba'\r\n                })\r\n            }\r\n        },\r\n\r\n        hasNone (color) {\r\n            return '' === color\r\n        },\r\n\r\n        hasKeyword (color) {\r\n            return [ 'currentColor', 'currentcolor', 'inherit', 'initial', 'unset' ].includes(color)\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\n\r\n.vc-styles {\r\n    position: relative;\r\n    background: #fff;\r\n}\r\n\r\n.vc-styles-saturation-wrap {\r\n    width: 100%;\r\n    padding-bottom: 50%;\r\n    position: relative;\r\n    overflow: hidden;\r\n}\r\n\r\n.vc-styles-controls {\r\n    display: flex;\r\n}\r\n\r\n.vc-styles-sliders {\r\n    padding: 4px 0;\r\n    flex: 1;\r\n}\r\n\r\n.vc-styles-sliders .vc-hue,\r\n.vc-styles-sliders .vc-alpha-gradient {\r\n    border-radius: 2px;\r\n}\r\n\r\n.vc-styles-hue-wrap {\r\n    position: relative;\r\n    height: 10px;\r\n}\r\n\r\n.vc-styles-alpha-wrap {\r\n    position: relative;\r\n    height: 10px;\r\n    margin-top: 4px;\r\n    overflow: hidden;\r\n}\r\n\r\n.vc-styles-color-wrap {\r\n    width: 24px;\r\n    height: 24px;\r\n    position: relative;\r\n    margin-top: 4px;\r\n    margin-left: 4px;\r\n    border-radius: 3px;\r\n}\r\n\r\n.vc-styles-active-color {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    border-radius: 2px;\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15);\r\n    z-index: 2;\r\n}\r\n\r\n.vc-styles-color-wrap .vc-checkerboard {\r\n    background-size: auto;\r\n}\r\n\r\n.vc-styles-field {\r\n    display: flex;\r\n    padding-top: 4px;\r\n}\r\n\r\n.vc-styles-field .vc-input__input {\r\n    width: 90%;\r\n    padding: 4px 2px 3px;\r\n    border: none;\r\n    box-shadow: inset 0 0 0 1px #ccc;\r\n    font-size: 10px;\r\n    text-align: center;\r\n}\r\n\r\n.vc-styles-field .vc-input__label {\r\n    display: block;\r\n    text-align: center;\r\n    font-size: 11px;\r\n    color: #222;\r\n    padding-top: 3px;\r\n    padding-bottom: 4px;\r\n    text-transform: capitalize;\r\n}\r\n\r\n.vc-styles-field--single {\r\n    flex: 1;\r\n    padding-left: 6px;\r\n}\r\n\r\n.vc-styles-field--double {\r\n    flex: 2;\r\n}\r\n\r\n.vc-styles-presets {\r\n    margin-right: -10px;\r\n    margin-left: -10px;\r\n    padding-left: 10px;\r\n    padding-top: 10px;\r\n    border-top: 1px solid #eee;\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n}\r\n\r\n.vc-styles-presets-color {\r\n    border-radius: 3px;\r\n    overflow: hidden;\r\n    position: relative;\r\n    display: inline-block;\r\n    margin: 0 10px 10px 0;\r\n    vertical-align: top;\r\n    cursor: pointer;\r\n    width: 16px;\r\n    height: 16px;\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15);\r\n}\r\n\r\n.vc-styles-presets-color .vc-styles-active-color {\r\n    border-radius: 3px;\r\n}\r\n\r\n.vc-styles__disable-alpha .vc-styles-color-wrap {\r\n    height: 10px;\r\n}\r\n\r\n.vc-styles-presets-toggle-button-wrap {\r\n    width: 26px;\r\n    display: flex;\r\n    align-items: flex-start;\r\n}\r\n\r\n.vc-styles-presets .vg-toggle-button {\r\n    border-radius: 3px;\r\n    display: inline-flex;\r\n}\r\n\r\n</style>\r\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	var __vue_scope_id__$b = undefined;
	/* module identifier */

	var __vue_module_identifier__$b = undefined;
	/* functional template */

	var __vue_is_functional_template__$b = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$b = normalizeComponent({
	  render: __vue_render__$b,
	  staticRenderFns: __vue_staticRenderFns__$b
	}, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, false, createInjector, undefined, undefined);

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	var script$c = {
	  props: {
	    value: Object
	  },
	  computed: {
	    gradient: function gradient() {
	      return this.value;
	    },
	    pointerTop: function pointerTop() {
	      return '0';
	    },
	    pointerLeft: function pointerLeft() {
	      if (this.gradient.angle === 0) {
	        return '0';
	      } else if (this.gradient.angle === 360) {
	        return '100%';
	      } else {
	        return this.gradient.angle * 100 / 360 + "%";
	      }
	    }
	  },
	  methods: {
	    handleChange: function handleChange(e, skip) {
	      !skip && e.preventDefault();
	      var container = this.$refs.container;
	      var containerWidth = container.clientWidth;
	      var containerHeight = container.clientHeight;
	      var xOffset = container.getBoundingClientRect().left + window.pageXOffset;
	      var yOffset = container.getBoundingClientRect().top + window.pageYOffset;
	      var pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0);
	      var pageY = e.pageY || (e.touches ? e.touches[0].pageY : 0);
	      var left = pageX - xOffset;
	      var angle;
	      var percent;

	      if (left < 0) {
	        angle = 0;
	      } else if (left > containerWidth) {
	        angle = 360;
	      } else {
	        percent = left * 100 / containerWidth; //angle = (360 * percent / 100)

	        angle = Math.round(360 * percent / 100); //Math.round(left * 100 / containerWidth) / 100
	      }

	      if (this.gradient.angle !== angle) {
	        this.$emit('change', {
	          angle: angle,
	          type: this.gradient.type,
	          stops: this.gradient.stops
	        });
	      }
	    },
	    handleMouseDown: function handleMouseDown(e) {
	      this.handleChange(e, true);
	      window.addEventListener('mousemove', this.handleChange);
	      window.addEventListener('mouseup', this.handleMouseUp);
	    },
	    handleMouseUp: function handleMouseUp(e) {
	      this.unbindEventListeners();
	    },
	    unbindEventListeners: function unbindEventListeners() {
	      window.removeEventListener('mousemove', this.handleChange);
	      window.removeEventListener('mouseup', this.handleMouseUp);
	    }
	  }
	};

	/* script */
	var __vue_script__$c = script$c;
	/* template */

	var __vue_render__$c = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "vg-angle"
	  }, [_c("div", {
	    ref: "container",
	    staticClass: "vg-angle-container",
	    attrs: {
	      role: "slider",
	      "aria-valuenow": _vm.gradient.angle,
	      "aria-valuemin": "0",
	      "aria-valuemax": "360"
	    },
	    on: {
	      mousedown: _vm.handleMouseDown,
	      touchmove: _vm.handleChange,
	      touchstart: _vm.handleChange
	    }
	  }, [_c("div", {
	    staticClass: "vg-angle-pointer",
	    style: {
	      top: _vm.pointerTop,
	      left: _vm.pointerLeft
	    },
	    attrs: {
	      role: "presentation"
	    }
	  }, [_c("div", {
	    staticClass: "vg-angle-picker"
	  })])])]);
	};

	var __vue_staticRenderFns__$c = [];
	__vue_render__$c._withStripped = true;
	/* style */

	var __vue_inject_styles__$c = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-c6da8e94_0", {
	    source: "\n.vg-angle {\r\n    position: absolute;\r\n    top: 0px;\r\n    right: 0px;\r\n    bottom: 0px;\r\n    left: 0px;\r\n    border-radius: 2px;\r\n    background: #f2f2f2;\n}\n.vg-angle-container {\r\n    cursor: pointer;\r\n    margin: 0 2px;\r\n    position: relative;\r\n    height: 100%;\n}\n.vg-angle-pointer {\r\n    z-index: 2;\r\n    position: absolute;\n}\n.vg-angle-picker {\r\n    cursor: pointer;\r\n    margin-top: 1px;\r\n    width: 4px;\r\n    border-radius: 1px;\r\n    height: 8px;\r\n    box-shadow: 0 0 2px rgba(0, 0, 0, .6);\r\n    background: #fff;\r\n    transform: translateX(-2px);\n}\r\n\r\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\vendor\\assets\\js\\components\\common\\Angle.vue"],
	      "names": [],
	      "mappings": ";AAgHA;IACA,kBAAA;IACA,QAAA;IACA,UAAA;IACA,WAAA;IACA,SAAA;IACA,kBAAA;IACA,mBAAA;AACA;AAEA;IACA,eAAA;IACA,aAAA;IACA,kBAAA;IACA,YAAA;AACA;AAEA;IACA,UAAA;IACA,kBAAA;AACA;AAEA;IACA,eAAA;IACA,eAAA;IACA,UAAA;IACA,kBAAA;IACA,WAAA;IACA,qCAAA;IACA,gBAAA;IACA,2BAAA;AACA",
	      "file": "Angle.vue",
	      "sourcesContent": ["<template>\r\n    <div class=\"vg-angle\">\r\n        <div class=\"vg-angle-container\"\r\n            role=\"slider\"\r\n            :aria-valuenow=\"gradient.angle\"\r\n            aria-valuemin=\"0\"\r\n            aria-valuemax=\"360\"\r\n            ref=\"container\"\r\n            @mousedown=\"handleMouseDown\"\r\n            @touchmove=\"handleChange\"\r\n            @touchstart=\"handleChange\"\r\n        >\r\n            <div class=\"vg-angle-pointer\" :style=\"{ top: pointerTop, left: pointerLeft }\" role=\"presentation\">\r\n                <div class=\"vg-angle-picker\" />\r\n            </div>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n\r\nexport default {\r\n\r\n    props: {\r\n        value: Object\r\n    },\r\n\r\n    computed: {\r\n\r\n        gradient () {\r\n            return this.value\r\n        },\r\n\r\n        pointerTop () {\r\n            return '0'\r\n        },\r\n\r\n        pointerLeft () {\r\n            if (this.gradient.angle === 0) {\r\n                return '0'\r\n            } else if (this.gradient.angle === 360) {\r\n                return '100%'\r\n            } else {\r\n                return `${(this.gradient.angle * 100) / 360}%`\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    methods: {\r\n\r\n        handleChange (e, skip) {\r\n            !skip && e.preventDefault()\r\n\r\n            const container = this.$refs.container\r\n            const containerWidth = container.clientWidth\r\n            const containerHeight = container.clientHeight\r\n\r\n            const xOffset = container.getBoundingClientRect().left + window.pageXOffset\r\n            const yOffset = container.getBoundingClientRect().top + window.pageYOffset\r\n            const pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0)\r\n            const pageY = e.pageY || (e.touches ? e.touches[0].pageY : 0)\r\n            const left = pageX - xOffset\r\n            const top = pageY - yOffset\r\n\r\n            let angle\r\n            let percent\r\n\r\n            if (left < 0) {\r\n                angle = 0\r\n            } else if (left > containerWidth) {\r\n                angle = 360\r\n            } else {\r\n                percent = left * 100 / containerWidth\r\n                //angle = (360 * percent / 100)\r\n                angle = Math.round(360 * percent / 100)\r\n                //Math.round(left * 100 / containerWidth) / 100\r\n            }\r\n\r\n            if (this.gradient.angle !== angle) {\r\n                this.$emit('change', {\r\n                    angle,\r\n                    type:  this.gradient.type,\r\n                    stops: this.gradient.stops\r\n                })\r\n            }\r\n\r\n        },\r\n\r\n        handleMouseDown (e) {\r\n            this.handleChange(e, true)\r\n            window.addEventListener('mousemove', this.handleChange)\r\n            window.addEventListener('mouseup', this.handleMouseUp)\r\n        },\r\n\r\n        handleMouseUp (e) {\r\n            this.unbindEventListeners()\r\n        },\r\n\r\n        unbindEventListeners () {\r\n            window.removeEventListener('mousemove', this.handleChange)\r\n            window.removeEventListener('mouseup', this.handleMouseUp)\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\n\r\n.vg-angle {\r\n    position: absolute;\r\n    top: 0px;\r\n    right: 0px;\r\n    bottom: 0px;\r\n    left: 0px;\r\n    border-radius: 2px;\r\n    background: #f2f2f2;\r\n}\r\n\r\n.vg-angle-container {\r\n    cursor: pointer;\r\n    margin: 0 2px;\r\n    position: relative;\r\n    height: 100%;\r\n}\r\n\r\n.vg-angle-pointer {\r\n    z-index: 2;\r\n    position: absolute;\r\n}\r\n\r\n.vg-angle-picker {\r\n    cursor: pointer;\r\n    margin-top: 1px;\r\n    width: 4px;\r\n    border-radius: 1px;\r\n    height: 8px;\r\n    box-shadow: 0 0 2px rgba(0, 0, 0, .6);\r\n    background: #fff;\r\n    transform: translateX(-2px);\r\n}\r\n\r\n</style>\r\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	var __vue_scope_id__$c = undefined;
	/* module identifier */

	var __vue_module_identifier__$c = undefined;
	/* functional template */

	var __vue_is_functional_template__$c = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$c = normalizeComponent({
	  render: __vue_render__$c,
	  staticRenderFns: __vue_staticRenderFns__$c
	}, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$c, false, createInjector, undefined, undefined);

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	var script$d = {
	  props: {
	    current: Number,
	    index: Number,
	    value: Object
	  },
	  computed: {
	    gradient: function gradient() {
	      return this.value;
	    },
	    color: function color() {
	      return this.gradient.stops[this.index][0];
	    },
	    left: function left() {
	      return this.gradient.stops[this.index][1] * 100 + "%";
	    }
	  },
	  methods: {
	    handleChange: function handleChange(e, skip) {
	      !skip && e.preventDefault();
	      var container = this.$parent.$el;
	      var containerWidth = container.clientWidth;
	      var containerHeight = container.clientHeight;
	      var xOffset = container.getBoundingClientRect().left + window.pageXOffset;
	      var yOffset = container.getBoundingClientRect().top + window.pageYOffset;
	      var pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0);
	      var pageY = e.pageY || (e.touches ? e.touches[0].pageY : 0);
	      var left = pageX - xOffset;

	      if (this.gradient.stops.length > 2) {
	        var y = (e.touches ? e.touches[0].clientY : e.clientY) || 0;
	        var verticalDistance = Math.abs(y - container.getBoundingClientRect().bottom);

	        if (verticalDistance > containerHeight) {
	          this.gradient.stops.splice(this.index, 1);

	          if (this.current > 0) {
	            this.$emit('setIndex', this.current - 1);
	          }

	          this.unbindEventListeners();
	          this.$emit('change', {
	            type: this.gradient.type,
	            angle: this.gradient.angle,
	            stops: this.gradient.stops
	          });
	          return;
	        }
	      }

	      var position;

	      if (left < 0) {
	        position = 0;
	      } else if (left > containerWidth) {
	        position = 1;
	      } else {
	        position = Math.round(left * 100 / containerWidth) / 100;
	      }

	      var previousPosition = this.gradient.stops[this.index][1];
	      this.gradient.stops[this.index][1] = position;

	      if (previousPosition != position) {
	        this.$emit('change', {
	          type: this.gradient.type,
	          angle: this.gradient.angle,
	          stops: this.gradient.stops
	        });
	      }
	    },
	    handleMouseDown: function handleMouseDown(e) {
	      this.handleChange(e, true);
	      window.addEventListener('mousemove', this.handleChange);
	      window.addEventListener('mouseup', this.handleMouseUp);
	    },
	    handleMouseUp: function handleMouseUp(e) {
	      this.unbindEventListeners();
	    },
	    unbindEventListeners: function unbindEventListeners() {
	      window.removeEventListener('mousemove', this.handleChange);
	      window.removeEventListener('mouseup', this.handleMouseUp);
	    }
	  }
	};

	/* script */
	var __vue_script__$d = script$d;
	/* template */

	var __vue_render__$d = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "vg-stop",
	    style: {
	      color: _vm.color,
	      left: _vm.left
	    },
	    attrs: {
	      role: "presentation"
	    },
	    on: {
	      mousedown: function mousedown($event) {
	        _vm.$emit("setIndex", _vm.index);

	        _vm.handleMouseDown($event);
	      },
	      touchmove: _vm.handleChange,
	      touchstart: function touchstart($event) {
	        _vm.$emit("setIndex", _vm.index);

	        _vm.handleChange($event);
	      }
	    }
	  });
	};

	var __vue_staticRenderFns__$d = [];
	__vue_render__$d._withStripped = true;
	/* style */

	var __vue_inject_styles__$d = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-c40d14e6_0", {
	    source: "\n.vg-stop {\r\n    z-index: 2;\r\n    position: absolute;\r\n    bottom: 0;\r\n    width: 12px;\r\n    height: 12px;\r\n    transform: translate(-6px, 6px);\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    cursor: pointer;\n}\n.vg-stop::before {\r\n    content: '';\r\n    width: 4px;\r\n    height: 4px;\r\n    box-shadow: 0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3), 0 0 1px 2px rgba(0,0,0,.4);\r\n    border-radius: 50%;\r\n    background: currentColor;\n}\n.vg-stop.active {\r\n    z-index: 3;\n}\n.vg-stop.active::before {\r\n    content: '';\r\n    box-shadow: 0 0 0 2.5px #fff, inset 0 0 1px 1px rgba(0, 0, 0, 0.3), 0 0 1px 3px rgba(0,0,0,.4);\r\n    width: 6px;\r\n    height: 6px;\n}\r\n\r\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\vendor\\assets\\js\\components\\common\\Stop.vue"],
	      "names": [],
	      "mappings": ";AAsHA;IACA,UAAA;IACA,kBAAA;IACA,SAAA;IACA,WAAA;IACA,YAAA;IACA,+BAAA;IACA,aAAA;IACA,uBAAA;IACA,mBAAA;IACA,eAAA;AACA;AAEA;IACA,WAAA;IACA,UAAA;IACA,WAAA;IACA,0FAAA;IACA,kBAAA;IACA,wBAAA;AACA;AAEA;IACA,UAAA;AACA;AAEA;IACA,WAAA;IACA,8FAAA;IACA,UAAA;IACA,WAAA;AACA",
	      "file": "Stop.vue",
	      "sourcesContent": ["<template>\r\n    <div\r\n        class=\"vg-stop\"\r\n        role=\"presentation\"\r\n        :style=\"{ color, left }\"\r\n        @mousedown=\"$emit('setIndex', index); handleMouseDown($event)\"\r\n        @touchmove=\"handleChange\"\r\n        @touchstart=\"$emit('setIndex', index); handleChange($event)\"\r\n    />\r\n</template>\r\n\r\n<script>\r\n\r\nexport default {\r\n\r\n    props: {\r\n        current: Number,\r\n        index: Number,\r\n        value: Object\r\n    },\r\n\r\n    computed: {\r\n\r\n        gradient () {\r\n            return this.value\r\n        },\r\n\r\n        color () {\r\n            return this.gradient.stops[this.index][0]\r\n        },\r\n\r\n        left () {\r\n            return `${this.gradient.stops[this.index][1] * 100}%`\r\n        }\r\n\r\n    },\r\n\r\n    methods: {\r\n\r\n        handleChange (e, skip) {\r\n            !skip && e.preventDefault()\r\n\r\n            const container = this.$parent.$el\r\n            const containerWidth = container.clientWidth\r\n            const containerHeight = container.clientHeight\r\n\r\n            const xOffset = container.getBoundingClientRect().left + window.pageXOffset\r\n            const yOffset = container.getBoundingClientRect().top + window.pageYOffset\r\n            const pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0)\r\n            const pageY = e.pageY || (e.touches ? e.touches[0].pageY : 0)\r\n            const left = pageX - xOffset\r\n            const top = pageY - yOffset\r\n\r\n             // Gradient must have at least 2 stops\r\n            if (this.gradient.stops.length > 2) {\r\n                const y = (e.touches ? e.touches[0].clientY : e.clientY) || 0\r\n                const verticalDistance = Math.abs(y - container.getBoundingClientRect().bottom)\r\n                if (verticalDistance > containerHeight) {\r\n                    this.gradient.stops.splice(this.index, 1)\r\n                    if (this.current > 0) {\r\n                        this.$emit('setIndex', this.current - 1)\r\n                    }\r\n                    this.unbindEventListeners()\r\n                    this.$emit('change', {\r\n                        type:  this.gradient.type,\r\n                        angle: this.gradient.angle,\r\n                        stops: this.gradient.stops\r\n                    })\r\n                    return\r\n                }\r\n            }\r\n\r\n            let position\r\n            if (left < 0) {\r\n                position = 0\r\n            } else if (left > containerWidth) {\r\n                position = 1\r\n            } else {\r\n                position = Math.round(left * 100 / containerWidth) / 100\r\n            }\r\n\r\n            const previousPosition = this.gradient.stops[this.index][1]\r\n\r\n            this.gradient.stops[this.index][1] = position\r\n\r\n            if (previousPosition != position) {\r\n                this.$emit('change', {\r\n                    type:  this.gradient.type,\r\n                    angle: this.gradient.angle,\r\n                    stops: this.gradient.stops\r\n                })\r\n            }\r\n\r\n        },\r\n\r\n        handleMouseDown (e) {\r\n            this.handleChange(e, true)\r\n            window.addEventListener('mousemove', this.handleChange)\r\n            window.addEventListener('mouseup', this.handleMouseUp)\r\n        },\r\n\r\n        handleMouseUp (e) {\r\n            this.unbindEventListeners()\r\n        },\r\n\r\n        unbindEventListeners () {\r\n            window.removeEventListener('mousemove', this.handleChange)\r\n            window.removeEventListener('mouseup', this.handleMouseUp)\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\n\r\n.vg-stop {\r\n    z-index: 2;\r\n    position: absolute;\r\n    bottom: 0;\r\n    width: 12px;\r\n    height: 12px;\r\n    transform: translate(-6px, 6px);\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    cursor: pointer;\r\n}\r\n\r\n.vg-stop::before {\r\n    content: '';\r\n    width: 4px;\r\n    height: 4px;\r\n    box-shadow: 0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3), 0 0 1px 2px rgba(0,0,0,.4);\r\n    border-radius: 50%;\r\n    background: currentColor;\r\n}\r\n\r\n.vg-stop.active {\r\n    z-index: 3;\r\n}\r\n\r\n.vg-stop.active::before {\r\n    content: '';\r\n    box-shadow: 0 0 0 2.5px #fff, inset 0 0 1px 1px rgba(0, 0, 0, 0.3), 0 0 1px 3px rgba(0,0,0,.4);\r\n    width: 6px;\r\n    height: 6px;\r\n}\r\n\r\n</style>\r\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	var __vue_scope_id__$d = undefined;
	/* module identifier */

	var __vue_module_identifier__$d = undefined;
	/* functional template */

	var __vue_is_functional_template__$d = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$d = normalizeComponent({
	  render: __vue_render__$d,
	  staticRenderFns: __vue_staticRenderFns__$d
	}, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$d, false, createInjector, undefined, undefined);

	//
	var script$e = {
	  components: {
	    Checkboard: __vue_component__$4,
	    Stop: __vue_component__$d
	  },
	  props: {
	    current: Number,
	    value: Object
	  },
	  computed: {
	    gradient: function gradient() {
	      return this.value;
	    },
	    background: function background() {
	      var stops = this.gradient.stops.slice().sort(function (a, b) {
	        return a[1] - b[1];
	      }).map(function (stop) {
	        return stop[0] + " " + stop[1] * 100 + "%";
	      }).join(',');
	      return "linear-gradient(to right, " + stops + ")";
	    }
	  },
	  methods: {
	    addStop: function addStop(e) {
	      var position = Math.round(e.offsetX * 100 / e.target.offsetWidth) / 100;
	      var index = this.gradient.stops.length;
	      this.gradient.stops.push([this.gradient.stops[this.current][0], position]);
	      this.$emit('setIndex', index);
	      this.$emit('change', {
	        type: this.gradient.type,
	        angle: this.gradient.angle,
	        stops: this.gradient.stops
	      });
	    }
	  }
	};

	/* script */
	var __vue_script__$e = script$e;
	/* template */

	var __vue_render__$e = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "vg-stops"
	  }, [_c("div", {
	    staticClass: "vg-stops-checkboard-wrap"
	  }, [_c("checkboard")], 1), _vm._v(" "), _c("div", {
	    staticClass: "vg-stops-gradient",
	    style: {
	      background: _vm.background
	    }
	  }), _vm._v(" "), _c("div", {
	    staticClass: "vg-stops-container",
	    attrs: {
	      role: "slider"
	    },
	    on: {
	      click: function click($event) {
	        if ($event.target !== $event.currentTarget) {
	          return null;
	        }

	        $event.preventDefault();
	        return _vm.addStop($event);
	      }
	    }
	  }, _vm._l(_vm.gradient.stops, function (stop, index) {
	    return _c("stop", {
	      key: index,
	      "class": {
	        active: index == _vm.current
	      },
	      attrs: {
	        current: _vm.current,
	        index: index,
	        value: _vm.gradient
	      },
	      on: {
	        change: function change($event) {
	          return _vm.$emit("change", $event);
	        },
	        setIndex: function setIndex($event) {
	          return _vm.$emit("setIndex", $event);
	        }
	      }
	    });
	  }), 1)]);
	};

	var __vue_staticRenderFns__$e = [];
	__vue_render__$e._withStripped = true;
	/* style */

	var __vue_inject_styles__$e = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-02a2ae62_0", {
	    source: "\n.vg-stops {\r\n    position: absolute;\r\n    top: 0px;\r\n    right: 0px;\r\n    bottom: 0px;\r\n    left: 0px;\n}\n.vg-stops-checkboard-wrap {\r\n    position: absolute;\r\n    top: 0px;\r\n    right: 0px;\r\n    bottom: 0px;\r\n    left: 0px;\r\n    overflow: hidden;\n}\n.vg-stops-checkboard-wrap .vc-checkerboard {\r\n    background-size: auto;\n}\n.vg-stops-gradient {\r\n    position: absolute;\r\n    top: 0px;\r\n    right: 0px;\r\n    bottom: 0px;\r\n    left: 0px;\r\n    border-radius: 2px;\n}\n.vg-stops-container {\r\n    cursor: pointer;\r\n    position: relative;\r\n    height: 100%;\n}\r\n\r\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\vendor\\assets\\js\\components\\common\\Stops.vue"],
	      "names": [],
	      "mappings": ";AA4EA;IACA,kBAAA;IACA,QAAA;IACA,UAAA;IACA,WAAA;IACA,SAAA;AACA;AAEA;IACA,kBAAA;IACA,QAAA;IACA,UAAA;IACA,WAAA;IACA,SAAA;IACA,gBAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,kBAAA;IACA,QAAA;IACA,UAAA;IACA,WAAA;IACA,SAAA;IACA,kBAAA;AACA;AAEA;IACA,eAAA;IACA,kBAAA;IACA,YAAA;AACA",
	      "file": "Stops.vue",
	      "sourcesContent": ["<template>\r\n    <div class=\"vg-stops\">\r\n        <div class=\"vg-stops-checkboard-wrap\">\r\n            <checkboard />\r\n        </div>\r\n        <div class=\"vg-stops-gradient\" :style=\"{ background }\" />\r\n        <div class=\"vg-stops-container\"\r\n            role=\"slider\"\r\n            @click.self.prevent=\"addStop($event)\"\r\n        >\r\n            <stop\r\n                v-for=\"(stop, index) in gradient.stops\"\r\n                :key=\"index\"\r\n                :current=\"current\"\r\n                :index=\"index\"\r\n                :value=\"gradient\"\r\n                :class=\"{ active: index == current }\"\r\n                @change=\"$emit('change', $event)\"\r\n                @setIndex=\"$emit('setIndex', $event)\"\r\n            />\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n\r\nimport Checkboard from 'vue-color/src/components/common/Checkboard.vue'\r\nimport Stop from './Stop.vue'\r\n\r\nexport default {\r\n\r\n    components: {\r\n        Checkboard,\r\n        Stop\r\n    },\r\n\r\n    props: {\r\n        current: Number,\r\n        value: Object\r\n    },\r\n\r\n    computed: {\r\n\r\n        gradient () {\r\n            return this.value\r\n        },\r\n\r\n        background () {\r\n            const stops = this.gradient.stops.slice().sort((a, b) => a[1] - b[1]).map(stop => `${stop[0]} ${stop[1] * 100}%`).join(',')\r\n            return `linear-gradient(to right, ${stops})`\r\n        }\r\n\r\n    },\r\n\r\n    methods: {\r\n\r\n        addStop (e) {\r\n            const position = Math.round(e.offsetX * 100 / e.target.offsetWidth) / 100\r\n            const index = this.gradient.stops.length\r\n            this.gradient.stops.push([this.gradient.stops[this.current][0], position])\r\n            this.$emit('setIndex', index)\r\n            this.$emit('change', {\r\n                type:  this.gradient.type,\r\n                angle: this.gradient.angle,\r\n                stops: this.gradient.stops\r\n            })\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\n\r\n.vg-stops {\r\n    position: absolute;\r\n    top: 0px;\r\n    right: 0px;\r\n    bottom: 0px;\r\n    left: 0px;\r\n}\r\n\r\n.vg-stops-checkboard-wrap {\r\n    position: absolute;\r\n    top: 0px;\r\n    right: 0px;\r\n    bottom: 0px;\r\n    left: 0px;\r\n    overflow: hidden;\r\n}\r\n\r\n.vg-stops-checkboard-wrap .vc-checkerboard {\r\n    background-size: auto;\r\n}\r\n\r\n.vg-stops-gradient {\r\n    position: absolute;\r\n    top: 0px;\r\n    right: 0px;\r\n    bottom: 0px;\r\n    left: 0px;\r\n    border-radius: 2px;\r\n}\r\n\r\n.vg-stops-container {\r\n    cursor: pointer;\r\n    position: relative;\r\n    height: 100%;\r\n}\r\n\r\n</style>\r\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	var __vue_scope_id__$e = undefined;
	/* module identifier */

	var __vue_module_identifier__$e = undefined;
	/* functional template */

	var __vue_is_functional_template__$e = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$e = normalizeComponent({
	  render: __vue_render__$e,
	  staticRenderFns: __vue_staticRenderFns__$e
	}, __vue_inject_styles__$e, __vue_script__$e, __vue_scope_id__$e, __vue_is_functional_template__$e, __vue_module_identifier__$e, false, createInjector, undefined, undefined);

	var webgradients = [
		"linear-gradient(45deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%)",
		"linear-gradient(to top, #a18cd1 0%, #fbc2eb 100%)",
		"linear-gradient(to top, #fad0c4 0%, #ffd1ff 100%)",
		"linear-gradient(to right, #ffecd2 0%, #fcb69f 100%)",
		"linear-gradient(to right, #ff8177 0%, #ff867a 0%, #ff8c7f 21%, #f99185 52%, #cf556c 78%, #b12a5b 100%)",
		"linear-gradient(to top, #ff9a9e 0%, #fecfef 99%, #fecfef 100%)",
		"linear-gradient(120deg, #f6d365 0%, #fda085 100%)",
		"linear-gradient(to top, #fbc2eb 0%, #a6c1ee 100%)",
		"linear-gradient(to top, #fdcbf1 0%, #fdcbf1 1%, #e6dee9 100%)",
		"linear-gradient(120deg, #a1c4fd 0%, #c2e9fb 100%)",
		"linear-gradient(120deg, #d4fc79 0%, #96e6a1 100%)",
		"linear-gradient(120deg, #84fab0 0%, #8fd3f4 100%)",
		"linear-gradient(to top, #cfd9df 0%, #e2ebf0 100%)",
		"linear-gradient(120deg, #a6c0fe 0%, #f68084 100%)",
		"linear-gradient(120deg, #fccb90 0%, #d57eeb 100%)",
		"linear-gradient(120deg, #e0c3fc 0%, #8ec5fc 100%)",
		"linear-gradient(120deg, #f093fb 0%, #f5576c 100%)",
		"linear-gradient(120deg, #fdfbfb 0%, #ebedee 100%)",
		"linear-gradient(to right, #4facfe 0%, #00f2fe 100%)",
		"linear-gradient(to right, #43e97b 0%, #38f9d7 100%)",
		"linear-gradient(to right, #fa709a 0%, #fee140 100%)",
		"linear-gradient(to top, #30cfd0 0%, #330867 100%)",
		"linear-gradient(to top, #a8edea 0%, #fed6e3 100%)",
		"linear-gradient(to top, #5ee7df 0%, #b490ca 100%)",
		"linear-gradient(to top, #d299c2 0%, #fef9d7 100%)",
		"linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)",
		"linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
		"linear-gradient(135deg, #fdfcfb 0%, #e2d1c3 100%)",
		"linear-gradient(120deg, #89f7fe 0%, #66a6ff 100%)",
		"linear-gradient(to top, #fddb92 0%, #d1fdff 100%)",
		"linear-gradient(to top, #9890e3 0%, #b1f4cf 100%)",
		"linear-gradient(to top, #ebc0fd 0%, #d9ded8 100%)",
		"linear-gradient(to top, #96fbc4 0%, #f9f586 100%)",
		"linear-gradient(180deg, #2af598 0%, #009efd 100%)",
		"linear-gradient(to top, #cd9cf2 0%, #f6f3ff 100%)",
		"linear-gradient(to right, #e4afcb 0%, #b8cbb8 0%, #b8cbb8 0%, #e2c58b 30%, #c2ce9c 64%, #7edbdc 100%)",
		"linear-gradient(to right, #b8cbb8 0%, #b8cbb8 0%, #b465da 0%, #cf6cc9 33%, #ee609c 66%, #ee609c 100%)",
		"linear-gradient(to right, #6a11cb 0%, #2575fc 100%)",
		"linear-gradient(to top, #37ecba 0%, #72afd3 100%)",
		"linear-gradient(to top, #ebbba7 0%, #cfc7f8 100%)",
		"linear-gradient(to top, #fff1eb 0%, #ace0f9 100%)",
		"linear-gradient(to right, #eea2a2 0%, #bbc1bf 19%, #57c6e1 42%, #b49fda 79%, #7ac5d8 100%)",
		"linear-gradient(to top, #c471f5 0%, #fa71cd 100%)",
		"linear-gradient(to top, #48c6ef 0%, #6f86d6 100%)",
		"linear-gradient(to right, #f78ca0 0%, #f9748f 19%, #fd868c 60%, #fe9a8b 100%)",
		"linear-gradient(to top, #feada6 0%, #f5efef 100%)",
		"linear-gradient(to top, #e6e9f0 0%, #eef1f5 100%)",
		"linear-gradient(to top, #accbee 0%, #e7f0fd 100%)",
		"linear-gradient(-20deg, #e9defa 0%, #fbfcdb 100%)",
		"linear-gradient(to top, #c1dfc4 0%, #deecdd 100%)",
		"linear-gradient(to top, #0ba360 0%, #3cba92 100%)",
		"linear-gradient(to top, #00c6fb 0%, #005bea 100%)",
		"linear-gradient(to right, #74ebd5 0%, #9face6 100%)",
		"linear-gradient(to top, #6a85b6 0%, #bac8e0 100%)",
		"linear-gradient(to top, #a3bded 0%, #6991c7 100%)",
		"linear-gradient(to top, #9795f0 0%, #fbc8d4 100%)",
		"linear-gradient(to top, #a7a6cb 0%, #8989ba 52%, #8989ba 100%)",
		"linear-gradient(to top, #3f51b1 0%, #5a55ae 13%, #7b5fac 25%, #8f6aae 38%, #a86aa4 50%, #cc6b8e 62%, #f18271 75%, #f3a469 87%, #f7c978 100%)",
		"linear-gradient(to top, #fcc5e4 0%, #fda34b 15%, #ff7882 35%, #c8699e 52%, #7046aa 71%, #0c1db8 87%, #020f75 100%)",
		"linear-gradient(to top, #dbdcd7 0%, #dddcd7 24%, #e2c9cc 30%, #e7627d 46%, #b8235a 59%, #801357 71%, #3d1635 84%, #1c1a27 100%)",
		"linear-gradient(to top, #f43b47 0%, #453a94 100%)",
		"linear-gradient(to top, #4fb576 0%, #44c489 30%, #28a9ae 46%, #28a2b7 59%, #4c7788 71%, #6c4f63 86%, #432c39 100%)",
		"linear-gradient(to top, #0250c5 0%, #d43f8d 100%)",
		"linear-gradient(to top, #88d3ce 0%, #6e45e2 100%)",
		"linear-gradient(to top, #d9afd9 0%, #97d9e1 100%)",
		"linear-gradient(to top, #7028e4 0%, #e5b2ca 100%)",
		"linear-gradient(15deg, #13547a 0%, #80d0c7 100%)",
		"linear-gradient(to top, #505285 0%, #585e92 12%, #65689f 25%, #7474b0 37%, #7e7ebb 50%, #8389c7 62%, #9795d4 75%, #a2a1dc 87%, #b5aee4 100%)",
		"linear-gradient(to top, #ff0844 0%, #ffb199 100%)",
		"linear-gradient(45deg, #93a5cf 0%, #e4efe9 100%)",
		"linear-gradient(to right, #434343 0%, black 100%)",
		"linear-gradient(to top, #0c3483 0%, #a2b6df 100%, #6b8cce 100%, #a2b6df 100%)",
		"linear-gradient(45deg, #93a5cf 0%, #e4efe9 100%)",
		"linear-gradient(to right, #92fe9d 0%, #00c9ff 100%)",
		"linear-gradient(to right, #ff758c 0%, #ff7eb3 100%)",
		"linear-gradient(to right, #868f96 0%, #596164 100%)",
		"linear-gradient(to top, #c79081 0%, #dfa579 100%)",
		"linear-gradient(45deg, #8baaaa 0%, #ae8b9c 100%)",
		"linear-gradient(to right, #f83600 0%, #f9d423 100%)",
		"linear-gradient(-20deg, #b721ff 0%, #21d4fd 100%)",
		"linear-gradient(-20deg, #6e45e2 0%, #88d3ce 100%)",
		"linear-gradient(-20deg, #d558c8 0%, #24d292 100%)",
		"linear-gradient(60deg, #abecd6 0%, #fbed96 100%)",
		"linear-gradient(to top, #d5d4d0 0%, #d5d4d0 1%, #eeeeec 31%, #efeeec 75%, #e9e9e7 100%)",
		"linear-gradient(to top, #5f72bd 0%, #9b23ea 100%)",
		"linear-gradient(to top, #09203f 0%, #537895 100%)",
		"linear-gradient(-20deg, #ddd6f3 0%, #faaca8 100%, #faaca8 100%)",
		"linear-gradient(-20deg, #dcb0ed 0%, #99c99c 100%)",
		"linear-gradient(to top, #f3e7e9 0%, #e3eeff 99%, #e3eeff 100%)",
		"linear-gradient(to top, #c71d6f 0%, #d09693 100%)",
		"linear-gradient(60deg, #96deda 0%, #50c9c3 100%)",
		"linear-gradient(to top, #f77062 0%, #fe5196 100%)",
		"linear-gradient(to top, #c4c5c7 0%, #dcdddf 52%, #ebebeb 100%)",
		"linear-gradient(to right, #a8caba 0%, #5d4157 100%)",
		"linear-gradient(60deg, #29323c 0%, #485563 100%)",
		"linear-gradient(-60deg, #16a085 0%, #f4d03f 100%)",
		"linear-gradient(-60deg, #ff5858 0%, #f09819 100%)",
		"linear-gradient(-20deg, #2b5876 0%, #4e4376 100%)",
		"linear-gradient(-20deg, #00cdac 0%, #8ddad5 100%)",
		"linear-gradient(to top, #4481eb 0%, #04befe 100%)",
		"linear-gradient(to top, #dad4ec 0%, #dad4ec 1%, #f3e7e9 100%)",
		"linear-gradient(45deg, #874da2 0%, #c43a30 100%)",
		"linear-gradient(to top, #4481eb 0%, #04befe 100%)",
		"linear-gradient(to top, #e8198b 0%, #c7eafd 100%)",
		"linear-gradient(-20deg, #f794a4 0%, #fdd6bd 100%)",
		"linear-gradient(60deg, #64b3f4 0%, #c2e59c 100%)",
		"linear-gradient(to top, #3b41c5 0%, #a981bb 49%, #ffc8a9 100%)",
		"linear-gradient(to top, #0fd850 0%, #f9f047 100%)",
		"linear-gradient(to top, lightgrey 0%, lightgrey 1%, #e0e0e0 26%, #efefef 48%, #d9d9d9 75%, #bcbcbc 100%)",
		"linear-gradient(45deg, #ee9ca7 0%, #ffdde1 100%)",
		"linear-gradient(to right, #3ab5b0 0%, #3d99be 31%, #56317a 100%)",
		"linear-gradient(to top, #209cff 0%, #68e0cf 100%)",
		"linear-gradient(to top, #bdc2e8 0%, #bdc2e8 1%, #e6dee9 100%)",
		"linear-gradient(to top, #e6b980 0%, #eacda3 100%)",
		"linear-gradient(to top, #1e3c72 0%, #1e3c72 1%, #2a5298 100%)",
		"linear-gradient(to top, #d5dee7 0%, #ffafbd 0%, #c9ffbf 100%)",
		"linear-gradient(to top, #9be15d 0%, #00e3ae 100%)",
		"linear-gradient(to right, #ed6ea0 0%, #ec8c69 100%)",
		"linear-gradient(to right, #ffc3a0 0%, #ffafbd 100%)",
		"linear-gradient(to top, #cc208e 0%, #6713d2 100%)",
		"linear-gradient(to top, #b3ffab 0%, #12fff7 100%)",
		"linear-gradient(-45deg, #FFC796 0%, #FF6B95 100%)",
		"linear-gradient(to right, #243949 0%, #517fa4 100%)",
		"linear-gradient(-20deg, #fc6076 0%, #ff9a44 100%)",
		"linear-gradient(to top, #dfe9f3 0%, white 100%)",
		"linear-gradient(to right, #00dbde 0%, #fc00ff 100%)",
		"linear-gradient(to right, #f9d423 0%, #ff4e50 100%)",
		"linear-gradient(to top, #50cc7f 0%, #f5d100 100%)",
		"linear-gradient(to right, #0acffe 0%, #495aff 100%)",
		"linear-gradient(-20deg, #616161 0%, #9bc5c3 100%)",
		"linear-gradient(60deg, #3d3393 0%, #2b76b9 37%, #2cacd1 65%, #35eb93 100%)",
		"linear-gradient(to top, #df89b5 0%, #bfd9fe 100%)",
		"linear-gradient(to right, #ed6ea0 0%, #ec8c69 100%)",
		"linear-gradient(to right, #d7d2cc 0%, #304352 100%)",
		"linear-gradient(to top, #e14fad 0%, #f9d423 100%)",
		"linear-gradient(to top, #b224ef 0%, #7579ff 100%)",
		"linear-gradient(to right, #c1c161 0%, #c1c161 0%, #d4d4b1 100%)",
		"linear-gradient(to right, #ec77ab 0%, #7873f5 100%)",
		"linear-gradient(to top, #007adf 0%, #00ecbc 100%)",
		"linear-gradient(-225deg, #20E2D7 0%, #F9FEA5 100%)",
		"linear-gradient(-225deg, #2CD8D5 0%, #C5C1FF 56%, #FFBAC3 100%)",
		"linear-gradient(-225deg, #2CD8D5 0%, #6B8DD6 48%, #8E37D7 100%)",
		"linear-gradient(-225deg, #DFFFCD 0%, #90F9C4 48%, #39F3BB 100%)",
		"linear-gradient(-225deg, #5D9FFF 0%, #B8DCFF 48%, #6BBBFF 100%)",
		"linear-gradient(-225deg, #A8BFFF 0%, #884D80 100%)",
		"linear-gradient(-225deg, #5271C4 0%, #B19FFF 48%, #ECA1FE 100%)",
		"linear-gradient(-225deg, #FFE29F 0%, #FFA99F 48%, #FF719A 100%)",
		"linear-gradient(-225deg, #22E1FF 0%, #1D8FE1 48%, #625EB1 100%)",
		"linear-gradient(-225deg, #B6CEE8 0%, #F578DC 100%)",
		"linear-gradient(-225deg, #FFFEFF 0%, #D7FFFE 100%)",
		"linear-gradient(-225deg, #E3FDF5 0%, #FFE6FA 100%)",
		"linear-gradient(-225deg, #7DE2FC 0%, #B9B6E5 100%)",
		"linear-gradient(-225deg, #CBBACC 0%, #2580B3 100%)",
		"linear-gradient(-225deg, #B7F8DB 0%, #50A7C2 100%)",
		"linear-gradient(-225deg, #7085B6 0%, #87A7D9 50%, #DEF3F8 100%)",
		"linear-gradient(-225deg, #77FFD2 0%, #6297DB 48%, #1EECFF 100%)",
		"linear-gradient(-225deg, #AC32E4 0%, #7918F2 48%, #4801FF 100%)",
		"linear-gradient(-225deg, #D4FFEC 0%, #57F2CC 48%, #4596FB 100%)",
		"linear-gradient(-225deg, #9EFBD3 0%, #57E9F2 48%, #45D4FB 100%)",
		"linear-gradient(-225deg, #473B7B 0%, #3584A7 51%, #30D2BE 100%)",
		"linear-gradient(-225deg, #65379B 0%, #886AEA 53%, #6457C6 100%)",
		"linear-gradient(-225deg, #A445B2 0%, #D41872 52%, #FF0066 100%)",
		"linear-gradient(-225deg, #7742B2 0%, #F180FF 52%, #FD8BD9 100%)",
		"linear-gradient(-225deg, #FF3CAC 0%, #562B7C 52%, #2B86C5 100%)",
		"linear-gradient(-225deg, #FF057C 0%, #8D0B93 50%, #321575 100%)",
		"linear-gradient(-225deg, #FF057C 0%, #7C64D5 48%, #4CC3FF 100%)",
		"linear-gradient(-225deg, #69EACB 0%, #EACCF8 48%, #6654F1 100%)",
		"linear-gradient(-225deg, #231557 0%, #44107A 29%, #FF1361 67%, #FFF800 100%)",
		"linear-gradient(-225deg, #3D4E81 0%, #5753C9 48%, #6E7FF3 100%)"
	];

	var tokens = {
	  linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
	  repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
	  radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
	  repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
	  sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
	  extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
	  positionKeywords: /^(left|center|right|top|bottom)/i,
	  pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
	  percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
	  emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
	  // angleValue:              /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
	  degValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
	  gradValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))grad/,
	  radValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))rad/,
	  turnValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))turn/,
	  startCall: /^\(/,
	  endCall: /^\)/,
	  comma: /^,/,
	  hexColor: /^\#([0-9a-fA-F]+)/,
	  literalColor: /^([a-zA-Z]+)/,
	  rgbColor: /^rgb/i,
	  rgbaColor: /^rgba/i,
	  hslColor: /^hsl/i,
	  hslaColor: /^hsla/i,
	  number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?\%?))/
	};
	var input = '';

	var error = function error(msg) {
	  var err = new Error(input + ": " + msg);
	  err.source = input;
	  throw err;
	};

	var getAST = function getAST() {
	  var ast = matchDefinition();
	  input.length > 0 && error('Invalid input not EOF');
	  return ast;
	};

	var matchDefinition = function matchDefinition() {
	  return matchGradient('linear-gradient', tokens.linearGradient, matchLinearOrientation) || matchGradient('repeating-linear-gradient', tokens.repeatingLinearGradient, matchLinearOrientation) || matchGradient('radial-gradient', tokens.radialGradient, matchListRadialOrientations) || matchGradient('repeating-radial-gradient', tokens.repeatingRadialGradient, matchListRadialOrientations);
	};

	var matchGradient = function matchGradient(type, pattern, orientationMatcher) {
	  return matchCall(pattern, function (captures) {
	    var orientation = orientationMatcher();
	    orientation && !scan(tokens.comma) && error('Missing comma before color stops');
	    var angle = orientation.value;
	    return {
	      type: type,
	      angle: angle,
	      stops: matchListing(matchColorStop)
	    };
	  });
	};

	var matchCall = function matchCall(pattern, callback) {
	  var captures = scan(pattern);

	  if (captures) {
	    !scan(tokens.startCall) && error('Missing (');
	    var result = callback(captures);
	    !scan(tokens.endCall) && error('Missing )');
	    return result;
	  }
	};

	var matchLinearOrientation = function matchLinearOrientation() {
	  return matchSideOrCorner() || matchAngle();
	}; // const matchSideOrCorner = () => match('directional', tokens.sideOrCorner, 1)
	//const matchAngle = () => match('angular', tokens.angleValue, 1)


	var matchSideOrCorner = function matchSideOrCorner() {
	  var directional = match('directional', tokens.sideOrCorner, 1);

	  if (directional) {
	    var type = 'deg';
	    var value;

	    switch (directional.value) {
	      case 'top':
	        value = '0';
	        break;

	      case 'bottom':
	        value = '180';
	        break;

	      case 'left':
	        value = '270';
	        break;

	      case 'right':
	        value = '90';
	        break;

	      case 'top left':
	      case 'left top':
	        value = '315';
	        break;

	      case 'top right':
	      case 'right top':
	        value = '45';
	        break;

	      case 'bottom left':
	      case 'left bottom':
	        value = '225';
	        break;

	      case 'bottom right':
	      case 'right bottom':
	        value = '135';
	        break;

	      default:
	        value = '0';
	        break;
	    }

	    return {
	      type: type,
	      value: value
	    };
	  }
	};

	var matchAngle = function matchAngle() {
	  return matchDeg() || matchGrad() || matchRad() || matchTurn();
	}; // const matchDeg = () => match('deg', tokens.degValue, 1)


	var matchDeg = function matchDeg() {
	  var angle = match('deg', tokens.degValue, 1);

	  if (angle) {
	    if (angle.value < 0) {
	      angle.value = angle.value * 1 + 360;
	    }

	    return angle;
	  }
	}; // grad -> deg
	// Math.round(VALUE * 9 / 10)


	var matchGrad = function matchGrad() {
	  return match('grad', tokens.gradValue, 1);
	}; // rad -> deg
	// Math.round(VALUE * 180 / Math.PI)


	var matchRad = function matchRad() {
	  return match('rad', tokens.radValue, 1);
	}; // turn -> deg
	// Math.round(VALUE * 360)


	var matchTurn = function matchTurn() {
	  return match('turn', tokens.turnValue, 1);
	};

	var matchListRadialOrientations = function matchListRadialOrientations() {
	  var radialOrientations;
	  var radialOrientation = matchRadialOrientation();
	  var lookaheadCache;

	  if (radialOrientation) {
	    radialOrientations = [];
	    radialOrientations.push(radialOrientation);
	    lookaheadCache = input;

	    if (scan(tokens.comma)) {
	      radialOrientation = matchRadialOrientation();

	      if (radialOrientation) {
	        radialOrientations.push(radialOrientation);
	      } else {
	        input = lookaheadCache;
	      }
	    }
	  }

	  return radialOrientations;
	};

	var matchRadialOrientation = function matchRadialOrientation() {
	  var positionAt;
	  var radialType = matchCircle() || matchEllipse();

	  if (radialType) {
	    radialType.at = matchAtPosition();
	  } else {
	    var extent = matchExtentKeyword();

	    if (extent) {
	      radialType = extent;
	      positionAt = matchAtPosition();

	      if (positionAt) {
	        radialType.at = positionAt;
	      }
	    } else {
	      var defaultPosition = matchPositioning();

	      if (defaultPosition) {
	        /*
	        radialType = {
	            type: 'default-radial',
	            at: defaultPosition
	        }
	        */
	        radialType = defaultPosition;
	      } else {
	        positionAt = matchAtPosition();

	        if (positionAt) {
	          radialType = {
	            type: 'default-radial',
	            at: positionAt
	          };
	        }
	      }
	    }
	  }

	  return radialType;
	};

	var matchCircle = function matchCircle() {
	  var circle = match('shape', /^(circle)/i, 0);

	  if (circle) {
	    circle.style = matchLength() || matchExtentKeyword();
	  }

	  return circle;
	};

	var matchEllipse = function matchEllipse() {
	  var ellipse = match('shape', /^(ellipse)/i, 0);

	  if (ellipse) {
	    ellipse.style = matchPositioning() || matchDistance() || matchExtentKeyword();
	  }

	  return ellipse;
	};

	var matchExtentKeyword = function matchExtentKeyword() {
	  return match('extent-keyword', tokens.extentKeywords, 1);
	};

	var matchAtPosition = function matchAtPosition() {
	  if (match('position', /^at/, 0)) {
	    var positioning = matchPositioning();
	    !positioning && error('Missing positioning value');
	    return positioning;
	  }
	};

	var matchPositioning = function matchPositioning() {
	  var location = matchCoordinates();

	  if (location.x || location.y) {
	    return {
	      type: 'position',
	      value: location
	    };
	  }
	};

	var matchCoordinates = function matchCoordinates() {
	  return {
	    x: matchDistance(),
	    y: matchDistance()
	  };
	};

	var matchListing = function matchListing(matcher) {
	  var captures = matcher();
	  var result = [];

	  if (captures) {
	    result.push(captures);

	    while (scan(tokens.comma)) {
	      captures = matcher();

	      if (captures) {
	        result.push(captures);
	      } else {
	        error('One extra comma');
	      }
	    }
	  }

	  return result;
	};

	var matchColorStop = function matchColorStop() {
	  var position = matchDistance();

	  if (position) {
	    return ['', position.value / 100];
	  }

	  var color = matchColor();
	  !color && error('Expected color definition');

	  switch (color.type) {
	    case 'rgb':
	    case 'rgba':
	    case 'hsl':
	    case 'hsla':
	      color = color.type + "(" + color.value.join(', ') + ")";
	      break;

	    case 'hex':
	      color = "#" + color.value;
	      break;

	    case 'literal':
	      color = color.value;
	      break;
	  } // position = matchPositioning() // matchDistance()


	  position = matchDistance();
	  return [color, position ? position.value / 100 : 0];
	};

	var matchColor = function matchColor() {
	  return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchHSLAColor() || matchHSLColor() || matchLiteralColor();
	};

	var matchLiteralColor = function matchLiteralColor() {
	  return match('literal', tokens.literalColor, 0);
	};

	var matchHexColor = function matchHexColor() {
	  return match('hex', tokens.hexColor, 1);
	};

	var matchRGBColor = function matchRGBColor() {
	  return matchCall(tokens.rgbColor, function () {
	    return {
	      type: 'rgb',
	      value: matchListing(matchNumber)
	    };
	  });
	};

	var matchRGBAColor = function matchRGBAColor() {
	  return matchCall(tokens.rgbaColor, function () {
	    return {
	      type: 'rgba',
	      value: matchListing(matchNumber)
	    };
	  });
	};

	var matchHSLColor = function matchHSLColor() {
	  return matchCall(tokens.hslColor, function () {
	    return {
	      type: 'hsl',
	      value: matchListing(matchNumber)
	    };
	  });
	};

	var matchHSLAColor = function matchHSLAColor() {
	  return matchCall(tokens.hslaColor, function () {
	    return {
	      type: 'hsla',
	      value: matchListing(matchNumber)
	    };
	  });
	};

	var matchNumber = function matchNumber() {
	  return scan(tokens.number)[1];
	};

	var matchDistance = function matchDistance() {
	  return matchPercentage() || matchPositionKeyword() || matchLength();
	};

	var matchPercentage = function matchPercentage() {
	  return match('%', tokens.percentageValue, 1);
	};

	var matchPositionKeyword = function matchPositionKeyword() {
	  return match('position-keyword', tokens.positionKeywords, 1);
	};

	var matchLength = function matchLength() {
	  return match('px', tokens.pixelValue, 1) || match('em', tokens.emValue, 1);
	};

	var match = function match(type, pattern, captureIndex) {
	  var captures = scan(pattern);

	  if (captures) {
	    return {
	      type: type,
	      value: captures[captureIndex]
	    };
	  }
	};

	var scan = function scan(regexp) {
	  var captures;
	  var blankCaptures;
	  blankCaptures = /^[\n\r\t\s]+/.exec(input);

	  if (blankCaptures) {
	    consume(blankCaptures[0].length);
	  }

	  captures = regexp.exec(input);

	  if (captures) {
	    consume(captures[0].length);
	  }

	  return captures;
	};

	var consume = function consume(size) {
	  return input = input.substr(size);
	};

	var parse = function parse(code) {
	  input = code.toString();
	  return getAST();
	};

	//

	var script$f = {
	  components: {
	    ColorControls: __vue_component__$b,
	    Checkboard: __vue_component__$4,
	    Colorsymbol: __vue_component__$5,
	    ToggleButton: __vue_component__$a,
	    Angle: __vue_component__$c,
	    Stops: __vue_component__$e
	  },
	  props: {
	    value: String,
	    presetGradientsUsed: {
	      type: Array,
	      "default": function _default() {
	        return [];
	      }
	    },
	    presetGradients: {
	      type: Array,
	      "default": function _default() {
	        return webgradients;
	      }
	    },
	    presetLength: {
	      type: Number,
	      "default": function _default() {
	        return 16;
	      }
	    }
	  },
	  data: function data() {
	    return {
	      val: this.hasValid(this.value) ? parse(this.value) : defaultGradient(),
	      current: 0,
	      showAllGradients: false,
	      showAllGradientsUsed: false
	    };
	  },
	  computed: {
	    gradient: {
	      get: function get() {
	        return this.val;
	      },
	      set: function set(newVal) {
	        this.val = newVal;
	        this.$emit('input', newVal.type ? this.background : '');
	      }
	    },
	    background: function background() {
	      var stops = this.gradient.stops.slice().sort(function (a, b) {
	        return a[1] - b[1];
	      }).map(function (stop) {
	        return stop[0] + " " + stop[1] * 100 + "%";
	      }).join(',');
	      return "linear-gradient(" + this.gradient.angle + "deg, " + stops + ")";
	    },
	    isValid: function isValid() {
	      return this.hasValid(this.value);
	    }
	  },
	  watch: {
	    value: function value(newVal) {
	      this.val = this.hasValid(newVal) ? parse(newVal) : defaultGradient();
	    }
	  },
	  methods: {
	    handlePreset: function handlePreset(g) {
	      this.gradient = this.hasValid(g) ? parse(g) : defaultGradient();
	    },
	    hasValid: function hasValid(v) {
	      return v && v !== 'none';
	    },
	    handleColor: function handleColor(color) {
	      var _this = this;

	      this.gradient = {
	        angle: this.gradient.angle,
	        type: this.gradient.type,
	        stops: this.gradient.stops.reduce(function (stops, stop, i) {
	          if (i === _this.current) {
	            stop[0] = color;
	          }

	          stops[i] = stop;
	          return stops;
	        }, [])
	      };
	    }
	  }
	};

	function defaultGradient() {
	  return {
	    angle: 0,
	    stops: [['#0359b5', 0], ['#f6ce01', 1]]
	  };
	}

	/* script */
	var __vue_script__$f = script$f;
	/* template */

	var __vue_render__$f = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "vg-styles",
	    attrs: {
	      role: "application",
	      "aria-label": "styles gradient picker"
	    }
	  }, [_c("div", {
	    staticClass: "vg-styles-gradient-wrap"
	  }, [_c("div", {
	    staticClass: "vg-styles-gradient",
	    style: {
	      background: _vm.isValid && _vm.background
	    },
	    attrs: {
	      "aria-label": "Current gradient is " + _vm.background
	    }
	  }), _vm._v(" "), _c("checkboard")], 1), _vm._v(" "), _c("div", {
	    staticClass: "vg-styles-stops-wrap"
	  }, [_c("stops", {
	    attrs: {
	      current: _vm.current,
	      value: _vm.gradient
	    },
	    on: {
	      setIndex: function setIndex($event) {
	        _vm.current = $event;
	      },
	      change: function change($event) {
	        _vm.gradient = $event;
	      }
	    }
	  })], 1), _vm._v(" "), _c("div", {
	    staticClass: "vg-styles-controls"
	  }, [_c("div", {
	    staticClass: "vg-styles-angle-slider"
	  }, [_c("div", {
	    staticClass: "vg-editable-input"
	  }, [_c("div", {
	    staticClass: "vg-styles-angle-wrap"
	  }, [_c("angle", {
	    attrs: {
	      value: _vm.gradient
	    },
	    on: {
	      change: function change($event) {
	        _vm.gradient = $event;
	      }
	    }
	  })], 1), _vm._v(" "), _c("span", {
	    staticClass: "vg-input__label"
	  }, [_vm._v("Angle")])])]), _vm._v(" "), _c("div", {
	    staticClass: "vg-styles-angle-input"
	  }, [_c("div", {
	    staticClass: "vg-editable-input"
	  }, [_c("input", {
	    staticClass: "vg-input__input",
	    domProps: {
	      value: _vm.gradient.angle
	    },
	    on: {
	      input: function input($event) {
	        _vm.gradient = {
	          angle: $event.target.value,
	          type: _vm.gradient.type,
	          stops: _vm.gradient.stops
	        };
	      }
	    }
	  }), _vm._v(" "), _c("span", {
	    staticClass: "vg-input__label"
	  }, [_vm._v("Deg°")])])])]), _vm._v(" "), _c("color-controls", {
	    attrs: {
	      value: _vm.gradient.stops[_vm.current][0],
	      "preset-colors": null
	    },
	    on: {
	      input: _vm.handleColor
	    }
	  }), _vm._v(" "), _vm.presetGradientsUsed && _vm.presetGradientsUsed.length ? _c("div", {
	    staticClass: "vc-styles-presets",
	    attrs: {
	      role: "group",
	      "aria-label": "A gradient preset, pick one to set as current gradient"
	    }
	  }, [_c("div", {
	    staticClass: "uk-width-expand"
	  }, [_vm._l(_vm.presetGradientsUsed, function (g, i) {
	    return [_vm.showAllGradientsUsed || i < _vm.presetLength ? _c("div", {
	      key: g.value,
	      staticClass: "vc-styles-presets-color",
	      attrs: {
	        "aria-label": "Gradient:" + g.value,
	        title: g.name
	      },
	      on: {
	        click: function click($event) {
	          return _vm.handlePreset(g.value);
	        }
	      }
	    }, [_c("div", {
	      staticClass: "vc-styles-active-color",
	      style: {
	        background: g.value
	      }
	    }), _vm._v(" "), !_vm.hasValid(g.value) ? _c("colorsymbol") : _c("checkboard")], 1) : _vm._e()];
	  })], 2), _vm._v(" "), _vm.presetGradientsUsed.length > _vm.presetLength ? _c("div", {
	    staticClass: "vc-styles-presets-toggle-button-wrap"
	  }, [_c("toggle-button", {
	    on: {
	      toggle: function toggle($event) {
	        _vm.showAllGradientsUsed = !_vm.showAllGradientsUsed;
	      }
	    }
	  })], 1) : _vm._e()]) : _vm._e(), _vm._v(" "), _vm.presetGradients && _vm.presetGradients.length ? _c("div", {
	    staticClass: "vc-styles-presets",
	    attrs: {
	      role: "group",
	      "aria-label": "A gradient preset, pick one to set as current gradient"
	    }
	  }, [_c("div", {
	    staticClass: "uk-width-expand"
	  }, [_vm._l(_vm.presetGradients, function (g, i) {
	    return [_vm.showAllGradients || i < _vm.presetLength ? _c("div", {
	      key: g,
	      staticClass: "vc-styles-presets-color",
	      attrs: {
	        "aria-label": "Gradient:" + g
	      },
	      on: {
	        click: function click($event) {
	          return _vm.handlePreset(g);
	        }
	      }
	    }, [_c("div", {
	      staticClass: "vc-styles-active-color",
	      style: {
	        background: g
	      }
	    }), _vm._v(" "), !_vm.hasValid(g) ? _c("colorsymbol") : _c("checkboard")], 1) : _vm._e()];
	  })], 2), _vm._v(" "), _vm.presetGradients.length > _vm.presetLength ? _c("div", {
	    staticClass: "vc-styles-presets-toggle-button-wrap"
	  }, [_c("toggle-button", {
	    on: {
	      toggle: function toggle($event) {
	        _vm.showAllGradients = !_vm.showAllGradients;
	      }
	    }
	  })], 1) : _vm._e()]) : _vm._e()], 1);
	};

	var __vue_staticRenderFns__$f = [];
	__vue_render__$f._withStripped = true;
	/* style */

	var __vue_inject_styles__$f = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-32cbae9d_0", {
	    source: "\n.vg-styles {\r\n    position: relative;\r\n    background: #fff;\n}\n.vg-styles-angle-wrap {\r\n    position: relative;\r\n    height: 10px;\r\n    margin-top: 6px;\r\n    margin-bottom: 4px;\n}\n.vg-styles-stops-wrap {\r\n    position: relative;\r\n    height: 24px;\r\n    margin-top: 4px;\n}\n.vg-styles-gradient-wrap {\r\n    padding-bottom: 50%;\r\n    position: relative;\r\n    overflow: hidden;\n}\n.vg-styles-gradient {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    /*\r\n    border-radius: 2px;\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15);\r\n    */\r\n    z-index: 2;\n}\n.vg-styles-gradient-wrap .vc-checkerboard {\r\n    background-size: auto;\n}\n.vg-styles-controls {\r\n    display: flex;\r\n    margin-top: 8px;\n}\n.vg-styles-angle-slider {\r\n    flex: 1;\n}\n.vg-styles-angle-input {\r\n    width: calc(100% * 1 / 6.001);\r\n    padding-left: 6px;\n}\n.vg-editable-input {\r\n    position: relative;\n}\n.vg-input__input {\r\n    outline: none;\r\n    width: 100%;\r\n    padding: 4px 2px 3px;\r\n    border: none;\r\n    box-shadow: inset 0 0 0 1px #ccc;\r\n    font-size: 10px;\r\n    text-align: center;\r\n    vertical-align: top;\n}\n.vg-input__label {\r\n    display: block;\r\n    text-align: center;\r\n    font-size: 11px;\r\n    color: #222;\r\n    padding-top: 3px;\r\n    padding-bottom: 4px;\r\n    text-transform: capitalize;\n}\r\n\r\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\vendor\\assets\\js\\components\\common\\GradientControls.vue"],
	      "names": [],
	      "mappings": ";AA2MA;IACA,kBAAA;IACA,gBAAA;AACA;AAEA;IACA,kBAAA;IACA,YAAA;IACA,eAAA;IACA,kBAAA;AACA;AAEA;IACA,kBAAA;IACA,YAAA;IACA,eAAA;AACA;AAEA;IACA,mBAAA;IACA,kBAAA;IACA,gBAAA;AACA;AAEA;IACA,kBAAA;IACA,MAAA;IACA,OAAA;IACA,QAAA;IACA,SAAA;IACA;;;KAGA;IACA,UAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,aAAA;IACA,eAAA;AACA;AAEA;IACA,OAAA;AACA;AAEA;IACA,6BAAA;IACA,iBAAA;AACA;AAEA;IACA,kBAAA;AACA;AAEA;IACA,aAAA;IACA,WAAA;IACA,oBAAA;IACA,YAAA;IACA,gCAAA;IACA,eAAA;IACA,kBAAA;IACA,mBAAA;AACA;AAEA;IACA,cAAA;IACA,kBAAA;IACA,eAAA;IACA,WAAA;IACA,gBAAA;IACA,mBAAA;IACA,0BAAA;AACA",
	      "file": "GradientControls.vue",
	      "sourcesContent": ["<template>\r\n\r\n    <div role=\"application\" aria-label=\"styles gradient picker\" class=\"vg-styles\">\r\n\r\n        <div class=\"vg-styles-gradient-wrap\">\r\n            <div class=\"vg-styles-gradient\" :aria-label=\"`Current gradient is ${background}`\" :style=\"{ background: isValid && background }\"></div>\r\n            <!--colorsymbol v-if=\"!isValid\" /-->\r\n            <checkboard />\r\n        </div>\r\n\r\n        <div class=\"vg-styles-stops-wrap\">\r\n            <stops :current=\"current\" :value=\"gradient\" @setIndex=\"current = $event\" @change=\"gradient = $event\" />\r\n        </div>\r\n\r\n        <div class=\"vg-styles-controls\">\r\n            <div class=\"vg-styles-angle-slider\">\r\n                <div class=\"vg-editable-input\">\r\n                    <div class=\"vg-styles-angle-wrap\">\r\n                        <angle :value=\"gradient\" @change=\"gradient = $event\" />\r\n                    </div>\r\n                    <span class=\"vg-input__label\">Angle</span>\r\n                </div>\r\n            </div>\r\n            <div class=\"vg-styles-angle-input\">\r\n                <div class=\"vg-editable-input\">\r\n                    <input class=\"vg-input__input\" :value=\"gradient.angle\" @input=\"gradient = { angle: $event.target.value, type: gradient.type, stops: gradient.stops }\"/>\r\n                    <span class=\"vg-input__label\">Deg&deg;</span>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <!--color-controls v-model=\"gradient.stops[current][0]\" :preset-colors=\"null\" /-->\r\n        <!--color-controls :value=\"gradient.stops[current][0]\" @input=\"gradient = { angle: gradient.angle, type: gradient.type, stops: ((gradient.stops[current][0] = $event) && gradient.stops) }\" :preset-colors=\"null\" /-->\r\n        <color-controls :value=\"gradient.stops[current][0]\" @input=\"handleColor\" :preset-colors=\"null\" />\r\n\r\n        <div v-if=\"presetGradientsUsed && presetGradientsUsed.length\" class=\"vc-styles-presets\" role=\"group\" aria-label=\"A gradient preset, pick one to set as current gradient\">\r\n            <div class=\"uk-width-expand\">\r\n                <template v-for=\"(g, i) in presetGradientsUsed\">\r\n                    <div v-if=\"showAllGradientsUsed || i < presetLength\" class=\"vc-styles-presets-color\" :key=\"g.value\" :aria-label=\"'Gradient:' + g.value\" :title=\"g.name\" @click=\"handlePreset(g.value)\">\r\n                        <div class=\"vc-styles-active-color\" :style=\"{ background: g.value }\" />\r\n                        <colorsymbol v-if=\"!hasValid(g.value)\" />\r\n                        <checkboard v-else />\r\n                    </div>\r\n                </template>\r\n            </div>\r\n            <div v-if=\"presetGradientsUsed.length > presetLength\" class=\"vc-styles-presets-toggle-button-wrap\">\r\n                <toggle-button @toggle=\"showAllGradientsUsed = !showAllGradientsUsed\" />\r\n            </div>\r\n        </div>\r\n\r\n        <div v-if=\"presetGradients && presetGradients.length\" class=\"vc-styles-presets\" role=\"group\" aria-label=\"A gradient preset, pick one to set as current gradient\">\r\n            <div class=\"uk-width-expand\">\r\n                <template v-for=\"(g, i) in presetGradients\">\r\n                    <div v-if=\"showAllGradients || i < presetLength\" class=\"vc-styles-presets-color\" :key=\"g\" :aria-label=\"'Gradient:' + g\" @click=\"handlePreset(g)\">\r\n                        <div class=\"vc-styles-active-color\" :style=\"{ background: g }\" />\r\n                        <colorsymbol v-if=\"!hasValid(g)\" />\r\n                        <checkboard v-else />\r\n                    </div>\r\n                </template>\r\n            </div>\r\n            <div v-if=\"presetGradients.length > presetLength\" class=\"vc-styles-presets-toggle-button-wrap\">\r\n                <toggle-button @toggle=\"showAllGradients = !showAllGradients\" />\r\n            </div>\r\n        </div>\r\n\r\n    </div>\r\n\r\n</template>\r\n\r\n<script>\r\n\r\nimport Checkboard from 'vue-color/src/components/common/Checkboard.vue'\r\nimport Colorsymbol from './Colorsymbol.vue'\r\nimport ColorControls from './ColorControls.vue'\r\nimport ToggleButton from './ToggleButton.vue'\r\nimport Angle from './Angle.vue'\r\nimport Stops from './Stops.vue'\r\nimport presetGradients from '../../gradients'\r\nimport { parse } from '../../gradient-parser'\r\nimport { assign } from '../../util'\r\n// import LinearGradient from './LinearGradient';\r\n\r\nexport default {\r\n\r\n    components: {\r\n        ColorControls,\r\n        Checkboard,\r\n        Colorsymbol,\r\n        ToggleButton,\r\n        Angle,\r\n        Stops\r\n    },\r\n\r\n    props: {\r\n\r\n        value: String,\r\n\r\n        presetGradientsUsed: {\r\n            type: Array,\r\n            default () {\r\n                return []\r\n            }\r\n        },\r\n\r\n        presetGradients: {\r\n            type: Array,\r\n            default () {\r\n                return presetGradients\r\n            }\r\n        },\r\n\r\n        presetLength: {\r\n            type: Number,\r\n            default () {\r\n                return 16\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    data () {\r\n        return {\r\n            val: this.hasValid(this.value) ? parse(this.value) : defaultGradient(),\r\n            current: 0,\r\n            showAllGradients: false,\r\n            showAllGradientsUsed: false\r\n        }\r\n    },\r\n\r\n    computed: {\r\n\r\n        gradient: {\r\n\r\n            get () {\r\n                return this.val\r\n            },\r\n\r\n            set (newVal) {\r\n                this.val = newVal\r\n                this.$emit('input', newVal.type ? this.background : '')\r\n            }\r\n\r\n        },\r\n\r\n        background () {\r\n            const stops = this.gradient.stops.slice().sort((a, b) => a[1] - b[1]).map(stop => `${stop[0]} ${stop[1] * 100}%`).join(',')\r\n            return `linear-gradient(${this.gradient.angle}deg, ${stops})`\r\n        },\r\n\r\n        isValid () {\r\n            return this.hasValid(this.value)\r\n        }\r\n\r\n    },\r\n\r\n    watch: {\r\n        value (newVal) {\r\n            this.val = this.hasValid(newVal) ? parse(newVal) : defaultGradient()\r\n        }\r\n    },\r\n\r\n    methods: {\r\n\r\n        handlePreset (g) {\r\n            this.gradient = this.hasValid(g) ? parse(g) : defaultGradient()\r\n        },\r\n\r\n        hasValid (v) {\r\n            return v && v !== 'none'\r\n        },\r\n\r\n        handleColor (color) {\r\n            this.gradient = {\r\n                angle: this.gradient.angle,\r\n                type:  this.gradient.type,\r\n                stops: this.gradient.stops.reduce((stops, stop, i) => {\r\n                    if (i === this.current) {\r\n                        stop[0] = color\r\n                    }\r\n                    stops[i] = stop\r\n                    return stops\r\n                }, [])\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nfunction defaultGradient () {\r\n    return {\r\n        angle: 0,\r\n        stops: [\r\n            ['#0359b5', 0],\r\n            ['#f6ce01', 1]\r\n        ]\r\n    }\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\n\r\n.vg-styles {\r\n    position: relative;\r\n    background: #fff;\r\n}\r\n\r\n.vg-styles-angle-wrap {\r\n    position: relative;\r\n    height: 10px;\r\n    margin-top: 6px;\r\n    margin-bottom: 4px;\r\n}\r\n\r\n.vg-styles-stops-wrap {\r\n    position: relative;\r\n    height: 24px;\r\n    margin-top: 4px;\r\n}\r\n\r\n.vg-styles-gradient-wrap {\r\n    padding-bottom: 50%;\r\n    position: relative;\r\n    overflow: hidden;\r\n}\r\n\r\n.vg-styles-gradient {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    /*\r\n    border-radius: 2px;\r\n    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .15);\r\n    */\r\n    z-index: 2;\r\n}\r\n\r\n.vg-styles-gradient-wrap .vc-checkerboard {\r\n    background-size: auto;\r\n}\r\n\r\n.vg-styles-controls {\r\n    display: flex;\r\n    margin-top: 8px;\r\n}\r\n\r\n.vg-styles-angle-slider {\r\n    flex: 1;\r\n}\r\n\r\n.vg-styles-angle-input {\r\n    width: calc(100% * 1 / 6.001);\r\n    padding-left: 6px;\r\n}\r\n\r\n.vg-editable-input {\r\n    position: relative;\r\n}\r\n\r\n.vg-input__input {\r\n    outline: none;\r\n    width: 100%;\r\n    padding: 4px 2px 3px;\r\n    border: none;\r\n    box-shadow: inset 0 0 0 1px #ccc;\r\n    font-size: 10px;\r\n    text-align: center;\r\n    vertical-align: top;\r\n}\r\n\r\n.vg-input__label {\r\n    display: block;\r\n    text-align: center;\r\n    font-size: 11px;\r\n    color: #222;\r\n    padding-top: 3px;\r\n    padding-bottom: 4px;\r\n    text-transform: capitalize;\r\n}\r\n\r\n</style>\r\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	var __vue_scope_id__$f = undefined;
	/* module identifier */

	var __vue_module_identifier__$f = undefined;
	/* functional template */

	var __vue_is_functional_template__$f = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$f = normalizeComponent({
	  render: __vue_render__$f,
	  staticRenderFns: __vue_staticRenderFns__$f
	}, __vue_inject_styles__$f, __vue_script__$f, __vue_scope_id__$f, __vue_is_functional_template__$f, __vue_module_identifier__$f, false, createInjector, undefined, undefined);

	var script$g = {
	  components: {
	    Picker: __vue_component__$3,
	    GradientControls: __vue_component__$f,
	    ColorControls: __vue_component__$b,
	    Colorsymbol: __vue_component__$5,
	    Checkboard: __vue_component__$4,
	    ToggleButton: __vue_component__$a
	  },
	  props: {
	    value: String,
	    internal: {
	      type: [Object, Boolean],
	      "default": function _default() {
	        return false;
	      }
	    }
	  },
	  data: function data() {
	    return {
	      color: this.value,
	      gradient: '',
	      fieldsIndex: 0
	    };
	  },
	  computed: _extends({}, vuex.mapState('styles', ['variables', 'vars']), {
	    presetColors: function presetColors() {
	      var _this = this;

	      // const colors = Object.keys(this.variables).filter(n => matchName(n, this.$parent.vars)).map(n => this.variables[n].value)
	      // const list = parse(colors).sortByLuma()
	      // return Array.from(new Set(list.toArray()))
	      return Object.keys(this.variables).filter(function (n) {
	        return matchName(n, '@global*-background');
	      }).map(function (n) {
	        return {
	          name: _this.variables[n].name,
	          value: _this.variables[n].value
	        };
	      }).filter(function (v) {
	        return v.value;
	      });
	    },
	    presetGradients: function presetGradients() {
	      var _this2 = this;

	      // const gradients = Object.keys(this.variables).filter(n => matchName(n, '@internal-*-gradient')).map(n => this.variables[n].value).filter(Boolean)
	      // Array.prototype.push.apply(gradients, presetGradients)
	      // gradients.unshift('')
	      // return Array.from(new Set(gradients))
	      var gradients = Object.keys(this.variables).filter(function (n) {
	        return matchName(n, '@internal-*-gradient');
	      }).map(function (n) {
	        return {
	          name: _this2.variables[n].name,
	          value: _this2.variables[n].value
	        };
	      }).filter(function (v) {
	        return v.value;
	      }); // add gradient reset

	      gradients.unshift({
	        name: 'none',
	        value: ''
	      });
	      return gradients;
	    },

	    /*
	            internal () {
	                const name  = this.$parent.name.replace(/^\@/, '@internal-').replace(/-background$/, '-gradient')
	                return this.variables[name]
	                    ? {
	                        name,
	                        value: (this.vars[name] || this.variables[name].value).replace(/~'([^']*)'/, '$1')
	                    }
	                    : false
	            },
	    */
	    preview: function preview() {
	      return [this.internal && this.internal.value, this.value].filter(Boolean).join(' ').trim();
	    },
	    background: function background() {
	      return [this.gradient, this.color].filter(Boolean).join(' ').trim();
	    }
	  }),
	  watch: {
	    internal: {
	      immediate: true,
	      handler: function handler(v) {
	        this.gradient = v ? v.value : '';
	      }
	    },
	    value: function value(newVal) {
	      this.color = newVal;
	    }
	  },
	  methods: {
	    change: function change() {
	      if (this.internal) {
	        this.$store.commit('styles/setState', {
	          name: "vars." + this.internal.name,
	          value: "~'" + this.gradient + "'"
	        });
	        this.$emit('input'); // fix for internal
	      }

	      this.$emit('input', this.color);
	    },
	    hidden: function hidden() {
	      this.gradient = this.internal && this.internal.value || '';
	      this.color = this.value;
	    }
	  }
	};

	/* script */
	var __vue_script__$g = script$g;
	/* template */

	var __vue_render__$g = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("picker", {
	    attrs: {
	      value: _vm.preview
	    },
	    on: {
	      change: _vm.change,
	      hidden: _vm.hidden
	    },
	    scopedSlots: _vm._u([{
	      key: "preview",
	      fn: function fn() {
	        return [_c("checkboard")];
	      },
	      proxy: true
	    }])
	  }, [_vm._v(" "), _c("div", {
	    staticClass: "uk-grid uk-grid-small uk-flex-middle uk-margin-small"
	  }, [_c("div", {
	    staticClass: "uk-width-expand uk-flex uk-flex-middle"
	  }, [_c("span", {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.fieldsIndex === 0,
	      expression: "fieldsIndex === 0"
	    }],
	    key: 0,
	    staticClass: "uk-label uk-label-muted"
	  }, [_vm._v("Color")]), _vm._v(" "), _c("span", {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.fieldsIndex === 1,
	      expression: "fieldsIndex === 1"
	    }],
	    key: 1,
	    staticClass: "uk-label uk-label-muted"
	  }, [_vm._v("Gradient")])]), _vm._v(" "), _c("div", {
	    staticClass: "uk-flex uk-flex-middle"
	  }, [_c("toggle-button", {
	    on: {
	      toggle: function toggle($event) {
	        _vm.fieldsIndex = _vm.fieldsIndex >= 1 ? 0 : _vm.fieldsIndex + 1;
	      }
	    }
	  })], 1)]), _vm._v(" "), _c("color-controls", {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.fieldsIndex === 0,
	      expression: "fieldsIndex === 0"
	    }],
	    attrs: {
	      "preset-colors-used": _vm.presetColors
	    },
	    model: {
	      value: _vm.color,
	      callback: function callback($$v) {
	        _vm.color = $$v;
	      },
	      expression: "color"
	    }
	  }), _vm._v(" "), _c("gradient-controls", {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.fieldsIndex === 1,
	      expression: "fieldsIndex === 1"
	    }],
	    attrs: {
	      "preset-gradients-used": _vm.presetGradients
	    },
	    model: {
	      value: _vm.gradient,
	      callback: function callback($$v) {
	        _vm.gradient = $$v;
	      },
	      expression: "gradient"
	    }
	  })], 1);
	};

	var __vue_staticRenderFns__$g = [];
	__vue_render__$g._withStripped = true;
	/* style */

	var __vue_inject_styles__$g = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-a67fb4ce_0", {
	    source: "\n.uk-label {\r\n    line-height: 18px;\r\n    font-size: 10px;\r\n    padding: 0 10px;\n}\n.uk-label-muted {\r\n    background: #f8f8f8;\r\n    color: #222;\n}\n.vg-styles-gradient-wrap.styles-background-picker-preview {\r\n    padding-bottom: 25%;\n}\r\n\r\n",
	    map: {
	      "version": 3,
	      "sources": ["D:\\OPENSERVER\\OSPanel\\domains\\s8.loc\\wa-apps\\customizer\\plugins\\styles\\vendor\\assets\\js\\components\\BackgroundPicker.vue"],
	      "names": [],
	      "mappings": ";AA4LA;IACA,iBAAA;IACA,eAAA;IACA,eAAA;AACA;AACA;IACA,mBAAA;IACA,WAAA;AACA;AAEA;IACA,mBAAA;AACA",
	      "file": "BackgroundPicker.vue",
	      "sourcesContent": ["<template>\r\n\r\n    <picker :value=\"preview\" @change=\"change\" @hidden=\"hidden\">\r\n\r\n        <template v-slot:preview>\r\n            <checkboard />\r\n        </template>\r\n\r\n        <!--div class=\"vg-styles-gradient-wrap styles-background-picker-preview\">\r\n            <div class=\"vg-styles-gradient\" :aria-label=\"`Current background is ${background}`\" :style=\"{ background }\"></div>\r\n            <checkboard />\r\n        </div-->\r\n\r\n        <div class=\"uk-grid uk-grid-small uk-flex-middle uk-margin-small\">\r\n            <div class=\"uk-width-expand uk-flex uk-flex-middle\">\r\n                <span v-show=\"fieldsIndex === 0\" :key=\"0\" class=\"uk-label uk-label-muted\">Color</span>\r\n                <span v-show=\"fieldsIndex === 1\" :key=\"1\" class=\"uk-label uk-label-muted\">Gradient</span>\r\n            </div>\r\n            <div class=\"uk-flex uk-flex-middle\">\r\n                <toggle-button @toggle=\"fieldsIndex = fieldsIndex >= 1 ? 0 : fieldsIndex + 1\" />\r\n            </div>\r\n        </div>\r\n        <color-controls v-show=\"fieldsIndex === 0\" v-model=\"color\" :preset-colors-used=\"presetColors\" />\r\n        <gradient-controls v-show=\"fieldsIndex === 1\" v-model=\"gradient\" :preset-gradients-used=\"presetGradients\" />\r\n\r\n        <!--ul class=\"uk-flex-center uk-margin-small\" uk-tab>\r\n            <li class=\"uk-active\"><a href=\"#\">Color</a></li>\r\n            <li><a href=\"#\">Gradient</a></li>\r\n        </ul>\r\n\r\n        <ul class=\"uk-switcher\">\r\n            <li>\r\n                <color-controls v-model=\"color\" :preset-colors-used=\"presetColors\" />\r\n            </li>\r\n            <li>\r\n                <gradient-controls v-model=\"gradient\" :preset-gradients-used=\"presetGradients\" />\r\n            </li>\r\n        </ul-->\r\n\r\n    </picker>\r\n\r\n</template>\r\n\r\n<script>\r\n\r\nimport Picker from './common/Picker.vue'\r\nimport GradientControls from './common/GradientControls.vue'\r\nimport ColorControls from './common/ColorControls.vue'\r\nimport Colorsymbol from './common/Colorsymbol.vue'\r\nimport Checkboard from 'vue-color/src/components/common/Checkboard.vue'\r\nimport ToggleButton from './common/ToggleButton.vue'\r\nimport { mapState } from 'vuex'\r\nimport { matchName } from '../util'\r\nimport { parse } from '../color-parser'\r\nimport presetGradients from '../gradients'\r\n\r\nexport default {\r\n\r\n    components: {\r\n        Picker,\r\n        GradientControls,\r\n        ColorControls,\r\n        Colorsymbol,\r\n        Checkboard,\r\n        ToggleButton\r\n    },\r\n\r\n    props: {\r\n\r\n        value: String,\r\n\r\n        internal: {\r\n            type: [ Object, Boolean ],\r\n            default () {\r\n                return false\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    data () {\r\n        return {\r\n            color: this.value,\r\n            gradient: '',\r\n            fieldsIndex: 0\r\n        }\r\n    },\r\n\r\n    computed: {\r\n\r\n        ...mapState('styles', [ 'variables', 'vars' ]),\r\n\r\n        presetColors () {\r\n            // const colors = Object.keys(this.variables).filter(n => matchName(n, this.$parent.vars)).map(n => this.variables[n].value)\r\n            // const list = parse(colors).sortByLuma()\r\n            // return Array.from(new Set(list.toArray()))\r\n            return Object.keys(this.variables)\r\n                .filter(n => matchName(n, '@global*-background'))\r\n                .map(n => ({\r\n                    name: this.variables[n].name,\r\n                    value: this.variables[n].value\r\n                }))\r\n                .filter(v => v.value)\r\n        },\r\n\r\n        presetGradients () {\r\n            // const gradients = Object.keys(this.variables).filter(n => matchName(n, '@internal-*-gradient')).map(n => this.variables[n].value).filter(Boolean)\r\n            // Array.prototype.push.apply(gradients, presetGradients)\r\n            // gradients.unshift('')\r\n            // return Array.from(new Set(gradients))\r\n            const gradients = Object.keys(this.variables)\r\n                .filter(n => matchName(n, '@internal-*-gradient'))\r\n                .map(n => ({\r\n                    name: this.variables[n].name,\r\n                    value: this.variables[n].value\r\n                }))\r\n                .filter(v => v.value)\r\n\r\n            // add gradient reset\r\n            gradients.unshift({\r\n                name: 'none',\r\n                value: ''\r\n            })\r\n\r\n            return gradients\r\n        },\r\n/*\r\n        internal () {\r\n            const name  = this.$parent.name.replace(/^\\@/, '@internal-').replace(/-background$/, '-gradient')\r\n            return this.variables[name]\r\n                ? {\r\n                    name,\r\n                    value: (this.vars[name] || this.variables[name].value).replace(/~'([^']*)'/, '$1')\r\n                }\r\n                : false\r\n        },\r\n*/\r\n        preview () {\r\n            return [ this.internal && this.internal.value, this.value ].filter(Boolean).join(' ').trim()\r\n        },\r\n\r\n        background () {\r\n            return [ this.gradient, this.color ].filter(Boolean).join(' ').trim()\r\n        }\r\n\r\n    },\r\n\r\n    watch: {\r\n\r\n        internal: {\r\n\r\n            immediate: true,\r\n\r\n            handler (v) {\r\n                this.gradient = v ? v.value : ''\r\n            }\r\n\r\n        },\r\n\r\n        value (newVal) {\r\n            this.color = newVal\r\n        }\r\n\r\n    },\r\n\r\n    methods: {\r\n\r\n        change () {\r\n            if (this.internal) {\r\n                this.$store.commit('styles/setState', { name: `vars.${this.internal.name}`, value: `~'${this.gradient}'` })\r\n                this.$emit('input') // fix for internal\r\n            }\r\n            this.$emit('input', this.color)\r\n        },\r\n\r\n        hidden () {\r\n            this.gradient = this.internal && this.internal.value || ''\r\n            this.color = this.value\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\n\r\n.uk-label {\r\n    line-height: 18px;\r\n    font-size: 10px;\r\n    padding: 0 10px;\r\n}\r\n.uk-label-muted {\r\n    background: #f8f8f8;\r\n    color: #222;\r\n}\r\n\r\n.vg-styles-gradient-wrap.styles-background-picker-preview {\r\n    padding-bottom: 25%;\r\n}\r\n\r\n</style>\r\n"]
	    },
	    media: undefined
	  });
	};
	/* scoped */


	var __vue_scope_id__$g = undefined;
	/* module identifier */

	var __vue_module_identifier__$g = undefined;
	/* functional template */

	var __vue_is_functional_template__$g = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$g = normalizeComponent({
	  render: __vue_render__$g,
	  staticRenderFns: __vue_staticRenderFns__$g
	}, __vue_inject_styles__$g, __vue_script__$g, __vue_scope_id__$g, __vue_is_functional_template__$g, __vue_module_identifier__$g, false, createInjector, undefined, undefined);

	var script$h = {
	  components: {
	    Picker: __vue_component__$3,
	    ColorControls: __vue_component__$b,
	    Colorsymbol: __vue_component__$5,
	    Checkboard: __vue_component__$4
	  },
	  props: ['value'],
	  computed: _extends({}, vuex.mapState('styles', ['variables']), {
	    presetColors: function presetColors() {
	      var _this = this;

	      // const colors = Object.keys(this.variables).filter(n => matchName(n, this.$parent.vars)).map(n => this.variables[n].value)
	      // const list = parse(colors).sortByLuma()
	      // return Array.from(new Set(list.toArray()))
	      return Object.keys(this.variables).filter(function (n) {
	        return matchName(n, ['@global*-color', '@global*-border', '@global*-background']);
	      }).map(function (n) {
	        return {
	          name: _this.variables[n].name,
	          value: _this.variables[n].value
	        };
	      }).filter(function (v) {
	        return v.value;
	      });
	    },
	    color: function color() {
	      return this.value;
	    }
	  }),
	  methods: {
	    hasNone: function hasNone(color) {
	      return __vue_component__$b.methods.hasNone(color);
	    },
	    hasKeyword: function hasKeyword(color) {
	      return __vue_component__$b.methods.hasKeyword(color);
	    }
	  }
	};

	/* script */
	var __vue_script__$h = script$h;
	/* template */

	var __vue_render__$h = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("picker", {
	    attrs: {
	      value: _vm.color
	    },
	    on: {
	      change: function change($event) {
	        return _vm.$emit("input", _vm.$refs.colorcontrols.color);
	      }
	    },
	    scopedSlots: _vm._u([{
	      key: "preview",
	      fn: function fn() {
	        return [_vm.hasNone(_vm.color) || _vm.hasKeyword(_vm.color) ? _c("colorsymbol", {
	          attrs: {
	            type: _vm.color
	          }
	        }) : _c("checkboard")];
	      },
	      proxy: true
	    }])
	  }, [_vm._v(" "), _c("color-controls", {
	    ref: "colorcontrols",
	    attrs: {
	      value: _vm.color,
	      "preset-colors-used": _vm.presetColors
	    }
	  })], 1);
	};

	var __vue_staticRenderFns__$h = [];
	__vue_render__$h._withStripped = true;
	/* style */

	var __vue_inject_styles__$h = undefined;
	/* scoped */

	var __vue_scope_id__$h = undefined;
	/* module identifier */

	var __vue_module_identifier__$h = undefined;
	/* functional template */

	var __vue_is_functional_template__$h = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$h = normalizeComponent({
	  render: __vue_render__$h,
	  staticRenderFns: __vue_staticRenderFns__$h
	}, __vue_inject_styles__$h, __vue_script__$h, __vue_scope_id__$h, __vue_is_functional_template__$h, __vue_module_identifier__$h, false, undefined, undefined, undefined);

	var script$i = {
	  components: {
	    BackgroundPicker: __vue_component__$g,
	    ColorPicker: __vue_component__$h
	  },
	  computed: _extends({}, vuex.mapState('styles', {
	    variables: function variables(state) {
	      return state.variables;
	    },
	    changedVars: function changedVars(state) {
	      return state.vars;
	    }
	  }), {
	    internal: function internal() {
	      var name = this.name.replace(/^\@/, '@internal-').replace(/-background$/, '-gradient');
	      return this.variables[name] ? {
	        name: name,
	        value: (this.changedVars[name] || this.variables[name].value).replace(/~'([^']*)'/, '$1')
	      } : false;
	    }
	  }),
	  "extends": Vue$1.component('field')
	};

	/* script */
	var __vue_script__$i = script$i;
	/* template */

	var __vue_render__$i = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _vm.internal ? _c("background-picker", _vm._b({
	    attrs: {
	      internal: _vm.internal
	    },
	    model: {
	      value: _vm.value,
	      callback: function callback($$v) {
	        _vm.value = $$v;
	      },
	      expression: "value"
	    }
	  }, "background-picker", _vm.attributes, false)) : _c("color-picker", _vm._b({
	    model: {
	      value: _vm.value,
	      callback: function callback($$v) {
	        _vm.value = $$v;
	      },
	      expression: "value"
	    }
	  }, "color-picker", _vm.attributes, false));
	};

	var __vue_staticRenderFns__$i = [];
	__vue_render__$i._withStripped = true;
	/* style */

	var __vue_inject_styles__$i = undefined;
	/* scoped */

	var __vue_scope_id__$i = undefined;
	/* module identifier */

	var __vue_module_identifier__$i = undefined;
	/* functional template */

	var __vue_is_functional_template__$i = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$i = normalizeComponent({
	  render: __vue_render__$i,
	  staticRenderFns: __vue_staticRenderFns__$i
	}, __vue_inject_styles__$i, __vue_script__$i, __vue_scope_id__$i, __vue_is_functional_template__$i, __vue_module_identifier__$i, false, undefined, undefined, undefined);

	/**!
	 * Sortable 1.10.2
	 * @author	RubaXa   <trash@rubaxa.org>
	 * @author	owenm    <owen23355@gmail.com>
	 * @license MIT
	 */
	function _typeof(obj) {
	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _extends$1() {
	  _extends$1 = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends$1.apply(this, arguments);
	}

	function _objectSpread(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};
	    var ownKeys = Object.keys(source);

	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	      }));
	    }

	    ownKeys.forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    });
	  }

	  return target;
	}

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};

	  var target = _objectWithoutPropertiesLoose(source, excluded);

	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	var version = "1.10.2";

	function userAgent(pattern) {
	  if (typeof window !== 'undefined' && window.navigator) {
	    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
	  }
	}

	var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
	var Edge = userAgent(/Edge/i);
	var FireFox = userAgent(/firefox/i);
	var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
	var IOS = userAgent(/iP(ad|od|hone)/i);
	var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
	var captureMode = {
	  capture: false,
	  passive: false
	};

	function on$1(el, event, fn) {
	  el.addEventListener(event, fn, !IE11OrLess && captureMode);
	}

	function off$1(el, event, fn) {
	  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
	}

	function matches$1(
	/**HTMLElement*/
	el,
	/**String*/
	selector) {
	  if (!selector) return;
	  selector[0] === '>' && (selector = selector.substring(1));

	  if (el) {
	    try {
	      if (el.matches) {
	        return el.matches(selector);
	      } else if (el.msMatchesSelector) {
	        return el.msMatchesSelector(selector);
	      } else if (el.webkitMatchesSelector) {
	        return el.webkitMatchesSelector(selector);
	      }
	    } catch (_) {
	      return false;
	    }
	  }

	  return false;
	}

	function getParentOrHost(el) {
	  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
	}

	function closest$1(
	/**HTMLElement*/
	el,
	/**String*/
	selector,
	/**HTMLElement*/
	ctx, includeCTX) {
	  if (el) {
	    ctx = ctx || document;

	    do {
	      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches$1(el, selector) : matches$1(el, selector)) || includeCTX && el === ctx) {
	        return el;
	      }

	      if (el === ctx) break;
	      /* jshint boss:true */
	    } while (el = getParentOrHost(el));
	  }

	  return null;
	}

	var R_SPACE = /\s+/g;

	function toggleClass(el, name, state) {
	  if (el && name) {
	    if (el.classList) {
	      el.classList[state ? 'add' : 'remove'](name);
	    } else {
	      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
	      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
	    }
	  }
	}

	function css$1(el, prop, val) {
	  var style = el && el.style;

	  if (style) {
	    if (val === void 0) {
	      if (document.defaultView && document.defaultView.getComputedStyle) {
	        val = document.defaultView.getComputedStyle(el, '');
	      } else if (el.currentStyle) {
	        val = el.currentStyle;
	      }

	      return prop === void 0 ? val : val[prop];
	    } else {
	      if (!(prop in style) && prop.indexOf('webkit') === -1) {
	        prop = '-webkit-' + prop;
	      }

	      style[prop] = val + (typeof val === 'string' ? '' : 'px');
	    }
	  }
	}

	function matrix(el, selfOnly) {
	  var appliedTransforms = '';

	  if (typeof el === 'string') {
	    appliedTransforms = el;
	  } else {
	    do {
	      var transform = css$1(el, 'transform');

	      if (transform && transform !== 'none') {
	        appliedTransforms = transform + ' ' + appliedTransforms;
	      }
	      /* jshint boss:true */

	    } while (!selfOnly && (el = el.parentNode));
	  }

	  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
	  /*jshint -W056 */

	  return matrixFn && new matrixFn(appliedTransforms);
	}

	function find$1(ctx, tagName, iterator) {
	  if (ctx) {
	    var list = ctx.getElementsByTagName(tagName),
	        i = 0,
	        n = list.length;

	    if (iterator) {
	      for (; i < n; i++) {
	        iterator(list[i], i);
	      }
	    }

	    return list;
	  }

	  return [];
	}

	function getWindowScrollingElement() {
	  var scrollingElement = document.scrollingElement;

	  if (scrollingElement) {
	    return scrollingElement;
	  } else {
	    return document.documentElement;
	  }
	}
	/**
	 * Returns the "bounding client rect" of given element
	 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
	 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
	 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
	 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
	 * @param  {[HTMLElement]} container              The parent the element will be placed in
	 * @return {Object}                               The boundingClientRect of el, with specified adjustments
	 */


	function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
	  if (!el.getBoundingClientRect && el !== window) return;
	  var elRect, top, left, bottom, right, height, width;

	  if (el !== window && el !== getWindowScrollingElement()) {
	    elRect = el.getBoundingClientRect();
	    top = elRect.top;
	    left = elRect.left;
	    bottom = elRect.bottom;
	    right = elRect.right;
	    height = elRect.height;
	    width = elRect.width;
	  } else {
	    top = 0;
	    left = 0;
	    bottom = window.innerHeight;
	    right = window.innerWidth;
	    height = window.innerHeight;
	    width = window.innerWidth;
	  }

	  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
	    // Adjust for translate()
	    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
	    // Not needed on <= IE11

	    if (!IE11OrLess) {
	      do {
	        if (container && container.getBoundingClientRect && (css$1(container, 'transform') !== 'none' || relativeToNonStaticParent && css$1(container, 'position') !== 'static')) {
	          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

	          top -= containerRect.top + parseInt(css$1(container, 'border-top-width'));
	          left -= containerRect.left + parseInt(css$1(container, 'border-left-width'));
	          bottom = top + elRect.height;
	          right = left + elRect.width;
	          break;
	        }
	        /* jshint boss:true */

	      } while (container = container.parentNode);
	    }
	  }

	  if (undoScale && el !== window) {
	    // Adjust for scale()
	    var elMatrix = matrix(container || el),
	        scaleX = elMatrix && elMatrix.a,
	        scaleY = elMatrix && elMatrix.d;

	    if (elMatrix) {
	      top /= scaleY;
	      left /= scaleX;
	      width /= scaleX;
	      height /= scaleY;
	      bottom = top + height;
	      right = left + width;
	    }
	  }

	  return {
	    top: top,
	    left: left,
	    bottom: bottom,
	    right: right,
	    width: width,
	    height: height
	  };
	}
	/**
	 * Checks if a side of an element is scrolled past a side of its parents
	 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
	 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
	 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
	 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
	 */


	function isScrolledPast(el, elSide, parentSide) {
	  var parent = getParentAutoScrollElement(el, true),
	      elSideVal = getRect(el)[elSide];
	  /* jshint boss:true */

	  while (parent) {
	    var parentSideVal = getRect(parent)[parentSide],
	        visible = void 0;

	    if (parentSide === 'top' || parentSide === 'left') {
	      visible = elSideVal >= parentSideVal;
	    } else {
	      visible = elSideVal <= parentSideVal;
	    }

	    if (!visible) return parent;
	    if (parent === getWindowScrollingElement()) break;
	    parent = getParentAutoScrollElement(parent, false);
	  }

	  return false;
	}
	/**
	 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
	 * and non-draggable elements
	 * @param  {HTMLElement} el       The parent element
	 * @param  {Number} childNum      The index of the child
	 * @param  {Object} options       Parent Sortable's options
	 * @return {HTMLElement}          The child at index childNum, or null if not found
	 */


	function getChild(el, childNum, options) {
	  var currentChild = 0,
	      i = 0,
	      children = el.children;

	  while (i < children.length) {
	    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest$1(children[i], options.draggable, el, false)) {
	      if (currentChild === childNum) {
	        return children[i];
	      }

	      currentChild++;
	    }

	    i++;
	  }

	  return null;
	}
	/**
	 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
	 * @param  {HTMLElement} el       Parent element
	 * @param  {selector} selector    Any other elements that should be ignored
	 * @return {HTMLElement}          The last child, ignoring ghostEl
	 */


	function lastChild(el, selector) {
	  var last = el.lastElementChild;

	  while (last && (last === Sortable.ghost || css$1(last, 'display') === 'none' || selector && !matches$1(last, selector))) {
	    last = last.previousElementSibling;
	  }

	  return last || null;
	}
	/**
	 * Returns the index of an element within its parent for a selected set of
	 * elements
	 * @param  {HTMLElement} el
	 * @param  {selector} selector
	 * @return {number}
	 */


	function index(el, selector) {
	  var index = 0;

	  if (!el || !el.parentNode) {
	    return -1;
	  }
	  /* jshint boss:true */


	  while (el = el.previousElementSibling) {
	    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches$1(el, selector))) {
	      index++;
	    }
	  }

	  return index;
	}
	/**
	 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
	 * The value is returned in real pixels.
	 * @param  {HTMLElement} el
	 * @return {Array}             Offsets in the format of [left, top]
	 */


	function getRelativeScrollOffset(el) {
	  var offsetLeft = 0,
	      offsetTop = 0,
	      winScroller = getWindowScrollingElement();

	  if (el) {
	    do {
	      var elMatrix = matrix(el),
	          scaleX = elMatrix.a,
	          scaleY = elMatrix.d;
	      offsetLeft += el.scrollLeft * scaleX;
	      offsetTop += el.scrollTop * scaleY;
	    } while (el !== winScroller && (el = el.parentNode));
	  }

	  return [offsetLeft, offsetTop];
	}
	/**
	 * Returns the index of the object within the given array
	 * @param  {Array} arr   Array that may or may not hold the object
	 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
	 * @return {Number}      The index of the object in the array, or -1
	 */


	function indexOfObject(arr, obj) {
	  for (var i in arr) {
	    if (!arr.hasOwnProperty(i)) continue;

	    for (var key in obj) {
	      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
	    }
	  }

	  return -1;
	}

	function getParentAutoScrollElement(el, includeSelf) {
	  // skip to window
	  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
	  var elem = el;
	  var gotSelf = false;

	  do {
	    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
	    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
	      var elemCSS = css$1(elem);

	      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
	        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
	        if (gotSelf || includeSelf) return elem;
	        gotSelf = true;
	      }
	    }
	    /* jshint boss:true */

	  } while (elem = elem.parentNode);

	  return getWindowScrollingElement();
	}

	function extend(dst, src) {
	  if (dst && src) {
	    for (var key in src) {
	      if (src.hasOwnProperty(key)) {
	        dst[key] = src[key];
	      }
	    }
	  }

	  return dst;
	}

	function isRectEqual(rect1, rect2) {
	  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
	}

	var _throttleTimeout;

	function throttle$1(callback, ms) {
	  return function () {
	    if (!_throttleTimeout) {
	      var args = arguments,
	          _this = this;

	      if (args.length === 1) {
	        callback.call(_this, args[0]);
	      } else {
	        callback.apply(_this, args);
	      }

	      _throttleTimeout = setTimeout(function () {
	        _throttleTimeout = void 0;
	      }, ms);
	    }
	  };
	}

	function cancelThrottle() {
	  clearTimeout(_throttleTimeout);
	  _throttleTimeout = void 0;
	}

	function scrollBy(el, x, y) {
	  el.scrollLeft += x;
	  el.scrollTop += y;
	}

	function clone(el) {
	  var Polymer = window.Polymer;
	  var $ = window.jQuery || window.Zepto;

	  if (Polymer && Polymer.dom) {
	    return Polymer.dom(el).cloneNode(true);
	  } else if ($) {
	    return $(el).clone(true)[0];
	  } else {
	    return el.cloneNode(true);
	  }
	}

	var expando = 'Sortable' + new Date().getTime();

	function AnimationStateManager() {
	  var animationStates = [],
	      animationCallbackId;
	  return {
	    captureAnimationState: function captureAnimationState() {
	      animationStates = [];
	      if (!this.options.animation) return;
	      var children = [].slice.call(this.el.children);
	      children.forEach(function (child) {
	        if (css$1(child, 'display') === 'none' || child === Sortable.ghost) return;
	        animationStates.push({
	          target: child,
	          rect: getRect(child)
	        });

	        var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


	        if (child.thisAnimationDuration) {
	          var childMatrix = matrix(child, true);

	          if (childMatrix) {
	            fromRect.top -= childMatrix.f;
	            fromRect.left -= childMatrix.e;
	          }
	        }

	        child.fromRect = fromRect;
	      });
	    },
	    addAnimationState: function addAnimationState(state) {
	      animationStates.push(state);
	    },
	    removeAnimationState: function removeAnimationState(target) {
	      animationStates.splice(indexOfObject(animationStates, {
	        target: target
	      }), 1);
	    },
	    animateAll: function animateAll(callback) {
	      var _this = this;

	      if (!this.options.animation) {
	        clearTimeout(animationCallbackId);
	        if (typeof callback === 'function') callback();
	        return;
	      }

	      var animating = false,
	          animationTime = 0;
	      animationStates.forEach(function (state) {
	        var time = 0,
	            target = state.target,
	            fromRect = target.fromRect,
	            toRect = getRect(target),
	            prevFromRect = target.prevFromRect,
	            prevToRect = target.prevToRect,
	            animatingRect = state.rect,
	            targetMatrix = matrix(target, true);

	        if (targetMatrix) {
	          // Compensate for current animation
	          toRect.top -= targetMatrix.f;
	          toRect.left -= targetMatrix.e;
	        }

	        target.toRect = toRect;

	        if (target.thisAnimationDuration) {
	          // Could also check if animatingRect is between fromRect and toRect
	          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
	          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
	            // If returning to same place as started from animation and on same axis
	            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
	          }
	        } // if fromRect != toRect: animate


	        if (!isRectEqual(toRect, fromRect)) {
	          target.prevFromRect = fromRect;
	          target.prevToRect = toRect;

	          if (!time) {
	            time = _this.options.animation;
	          }

	          _this.animate(target, animatingRect, toRect, time);
	        }

	        if (time) {
	          animating = true;
	          animationTime = Math.max(animationTime, time);
	          clearTimeout(target.animationResetTimer);
	          target.animationResetTimer = setTimeout(function () {
	            target.animationTime = 0;
	            target.prevFromRect = null;
	            target.fromRect = null;
	            target.prevToRect = null;
	            target.thisAnimationDuration = null;
	          }, time);
	          target.thisAnimationDuration = time;
	        }
	      });
	      clearTimeout(animationCallbackId);

	      if (!animating) {
	        if (typeof callback === 'function') callback();
	      } else {
	        animationCallbackId = setTimeout(function () {
	          if (typeof callback === 'function') callback();
	        }, animationTime);
	      }

	      animationStates = [];
	    },
	    animate: function animate(target, currentRect, toRect, duration) {
	      if (duration) {
	        css$1(target, 'transition', '');
	        css$1(target, 'transform', '');
	        var elMatrix = matrix(this.el),
	            scaleX = elMatrix && elMatrix.a,
	            scaleY = elMatrix && elMatrix.d,
	            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
	            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
	        target.animatingX = !!translateX;
	        target.animatingY = !!translateY;
	        css$1(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
	        repaint(target); // repaint

	        css$1(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
	        css$1(target, 'transform', 'translate3d(0,0,0)');
	        typeof target.animated === 'number' && clearTimeout(target.animated);
	        target.animated = setTimeout(function () {
	          css$1(target, 'transition', '');
	          css$1(target, 'transform', '');
	          target.animated = false;
	          target.animatingX = false;
	          target.animatingY = false;
	        }, duration);
	      }
	    }
	  };
	}

	function repaint(target) {
	  return target.offsetWidth;
	}

	function calculateRealTime(animatingRect, fromRect, toRect, options) {
	  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
	}

	var plugins = [];
	var defaults = {
	  initializeByDefault: true
	};
	var PluginManager = {
	  mount: function mount(plugin) {
	    // Set default static properties
	    for (var option in defaults) {
	      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
	        plugin[option] = defaults[option];
	      }
	    }

	    plugins.push(plugin);
	  },
	  pluginEvent: function pluginEvent(eventName, sortable, evt) {
	    var _this = this;

	    this.eventCanceled = false;

	    evt.cancel = function () {
	      _this.eventCanceled = true;
	    };

	    var eventNameGlobal = eventName + 'Global';
	    plugins.forEach(function (plugin) {
	      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

	      if (sortable[plugin.pluginName][eventNameGlobal]) {
	        sortable[plugin.pluginName][eventNameGlobal](_objectSpread({
	          sortable: sortable
	        }, evt));
	      } // Only fire plugin event if plugin is enabled in this sortable,
	      // and plugin has event defined


	      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
	        sortable[plugin.pluginName][eventName](_objectSpread({
	          sortable: sortable
	        }, evt));
	      }
	    });
	  },
	  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
	    plugins.forEach(function (plugin) {
	      var pluginName = plugin.pluginName;
	      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
	      var initialized = new plugin(sortable, el, sortable.options);
	      initialized.sortable = sortable;
	      initialized.options = sortable.options;
	      sortable[pluginName] = initialized; // Add default options from plugin

	      _extends$1(defaults, initialized.defaults);
	    });

	    for (var option in sortable.options) {
	      if (!sortable.options.hasOwnProperty(option)) continue;
	      var modified = this.modifyOption(sortable, option, sortable.options[option]);

	      if (typeof modified !== 'undefined') {
	        sortable.options[option] = modified;
	      }
	    }
	  },
	  getEventProperties: function getEventProperties(name, sortable) {
	    var eventProperties = {};
	    plugins.forEach(function (plugin) {
	      if (typeof plugin.eventProperties !== 'function') return;

	      _extends$1(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
	    });
	    return eventProperties;
	  },
	  modifyOption: function modifyOption(sortable, name, value) {
	    var modifiedValue;
	    plugins.forEach(function (plugin) {
	      // Plugin must exist on the Sortable
	      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

	      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
	        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
	      }
	    });
	    return modifiedValue;
	  }
	};

	function dispatchEvent(_ref) {
	  var sortable = _ref.sortable,
	      rootEl = _ref.rootEl,
	      name = _ref.name,
	      targetEl = _ref.targetEl,
	      cloneEl = _ref.cloneEl,
	      toEl = _ref.toEl,
	      fromEl = _ref.fromEl,
	      oldIndex = _ref.oldIndex,
	      newIndex = _ref.newIndex,
	      oldDraggableIndex = _ref.oldDraggableIndex,
	      newDraggableIndex = _ref.newDraggableIndex,
	      originalEvent = _ref.originalEvent,
	      putSortable = _ref.putSortable,
	      extraEventProperties = _ref.extraEventProperties;
	  sortable = sortable || rootEl && rootEl[expando];
	  if (!sortable) return;
	  var evt,
	      options = sortable.options,
	      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

	  if (window.CustomEvent && !IE11OrLess && !Edge) {
	    evt = new CustomEvent(name, {
	      bubbles: true,
	      cancelable: true
	    });
	  } else {
	    evt = document.createEvent('Event');
	    evt.initEvent(name, true, true);
	  }

	  evt.to = toEl || rootEl;
	  evt.from = fromEl || rootEl;
	  evt.item = targetEl || rootEl;
	  evt.clone = cloneEl;
	  evt.oldIndex = oldIndex;
	  evt.newIndex = newIndex;
	  evt.oldDraggableIndex = oldDraggableIndex;
	  evt.newDraggableIndex = newDraggableIndex;
	  evt.originalEvent = originalEvent;
	  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

	  var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));

	  for (var option in allEventProperties) {
	    evt[option] = allEventProperties[option];
	  }

	  if (rootEl) {
	    rootEl.dispatchEvent(evt);
	  }

	  if (options[onName]) {
	    options[onName].call(sortable, evt);
	  }
	}

	var pluginEvent = function pluginEvent(eventName, sortable) {
	  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	      originalEvent = _ref.evt,
	      data = _objectWithoutProperties(_ref, ["evt"]);

	  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({
	    dragEl: dragEl,
	    parentEl: parentEl,
	    ghostEl: ghostEl,
	    rootEl: rootEl,
	    nextEl: nextEl,
	    lastDownEl: lastDownEl,
	    cloneEl: cloneEl,
	    cloneHidden: cloneHidden,
	    dragStarted: moved,
	    putSortable: putSortable,
	    activeSortable: Sortable.active,
	    originalEvent: originalEvent,
	    oldIndex: oldIndex,
	    oldDraggableIndex: oldDraggableIndex,
	    newIndex: newIndex,
	    newDraggableIndex: newDraggableIndex,
	    hideGhostForTarget: _hideGhostForTarget,
	    unhideGhostForTarget: _unhideGhostForTarget,
	    cloneNowHidden: function cloneNowHidden() {
	      cloneHidden = true;
	    },
	    cloneNowShown: function cloneNowShown() {
	      cloneHidden = false;
	    },
	    dispatchSortableEvent: function dispatchSortableEvent(name) {
	      _dispatchEvent({
	        sortable: sortable,
	        name: name,
	        originalEvent: originalEvent
	      });
	    }
	  }, data));
	};

	function _dispatchEvent(info) {
	  dispatchEvent(_objectSpread({
	    putSortable: putSortable,
	    cloneEl: cloneEl,
	    targetEl: dragEl,
	    rootEl: rootEl,
	    oldIndex: oldIndex,
	    oldDraggableIndex: oldDraggableIndex,
	    newIndex: newIndex,
	    newDraggableIndex: newDraggableIndex
	  }, info));
	}

	var dragEl,
	    parentEl,
	    ghostEl,
	    rootEl,
	    nextEl,
	    lastDownEl,
	    cloneEl,
	    cloneHidden,
	    oldIndex,
	    newIndex,
	    oldDraggableIndex,
	    newDraggableIndex,
	    activeGroup,
	    putSortable,
	    awaitingDragStarted = false,
	    ignoreNextClick = false,
	    sortables = [],
	    tapEvt,
	    touchEvt,
	    lastDx,
	    lastDy,
	    tapDistanceLeft,
	    tapDistanceTop,
	    moved,
	    lastTarget,
	    lastDirection,
	    pastFirstInvertThresh = false,
	    isCircumstantialInvert = false,
	    targetMoveDistance,
	    // For positioning ghost absolutely
	ghostRelativeParent,
	    ghostRelativeParentInitialScroll = [],
	    // (left, top)
	_silent = false,
	    savedInputChecked = [];
	/** @const */

	var documentExists = typeof document !== 'undefined',
	    PositionGhostAbsolutely = IOS,
	    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
	    // This will not pass for IE9, because IE9 DnD only works on anchors
	supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
	    supportCssPointerEvents = function () {
	  if (!documentExists) return; // false when <= IE11

	  if (IE11OrLess) {
	    return false;
	  }

	  var el = document.createElement('x');
	  el.style.cssText = 'pointer-events:auto';
	  return el.style.pointerEvents === 'auto';
	}(),
	    _detectDirection = function _detectDirection(el, options) {
	  var elCSS = css$1(el),
	      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
	      child1 = getChild(el, 0, options),
	      child2 = getChild(el, 1, options),
	      firstChildCSS = child1 && css$1(child1),
	      secondChildCSS = child2 && css$1(child2),
	      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
	      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

	  if (elCSS.display === 'flex') {
	    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
	  }

	  if (elCSS.display === 'grid') {
	    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
	  }

	  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
	    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
	    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
	  }

	  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
	},
	    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
	  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
	      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
	      dragElOppLength = vertical ? dragRect.width : dragRect.height,
	      targetS1Opp = vertical ? targetRect.left : targetRect.top,
	      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
	      targetOppLength = vertical ? targetRect.width : targetRect.height;
	  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
	},

	/**
	 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
	 * @param  {Number} x      X position
	 * @param  {Number} y      Y position
	 * @return {HTMLElement}   Element of the first found nearest Sortable
	 */
	_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
	  var ret;
	  sortables.some(function (sortable) {
	    if (lastChild(sortable)) return;
	    var rect = getRect(sortable),
	        threshold = sortable[expando].options.emptyInsertThreshold,
	        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
	        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

	    if (threshold && insideHorizontally && insideVertically) {
	      return ret = sortable;
	    }
	  });
	  return ret;
	},
	    _prepareGroup = function _prepareGroup(options) {
	  function toFn(value, pull) {
	    return function (to, from, dragEl, evt) {
	      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

	      if (value == null && (pull || sameGroup)) {
	        // Default pull value
	        // Default pull and put value if same group
	        return true;
	      } else if (value == null || value === false) {
	        return false;
	      } else if (pull && value === 'clone') {
	        return value;
	      } else if (typeof value === 'function') {
	        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
	      } else {
	        var otherGroup = (pull ? to : from).options.group.name;
	        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
	      }
	    };
	  }

	  var group = {};
	  var originalGroup = options.group;

	  if (!originalGroup || _typeof(originalGroup) != 'object') {
	    originalGroup = {
	      name: originalGroup
	    };
	  }

	  group.name = originalGroup.name;
	  group.checkPull = toFn(originalGroup.pull, true);
	  group.checkPut = toFn(originalGroup.put);
	  group.revertClone = originalGroup.revertClone;
	  options.group = group;
	},
	    _hideGhostForTarget = function _hideGhostForTarget() {
	  if (!supportCssPointerEvents && ghostEl) {
	    css$1(ghostEl, 'display', 'none');
	  }
	},
	    _unhideGhostForTarget = function _unhideGhostForTarget() {
	  if (!supportCssPointerEvents && ghostEl) {
	    css$1(ghostEl, 'display', '');
	  }
	}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


	if (documentExists) {
	  document.addEventListener('click', function (evt) {
	    if (ignoreNextClick) {
	      evt.preventDefault();
	      evt.stopPropagation && evt.stopPropagation();
	      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
	      ignoreNextClick = false;
	      return false;
	    }
	  }, true);
	}

	var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
	  if (dragEl) {
	    evt = evt.touches ? evt.touches[0] : evt;

	    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

	    if (nearest) {
	      // Create imitation event
	      var event = {};

	      for (var i in evt) {
	        if (evt.hasOwnProperty(i)) {
	          event[i] = evt[i];
	        }
	      }

	      event.target = event.rootEl = nearest;
	      event.preventDefault = void 0;
	      event.stopPropagation = void 0;

	      nearest[expando]._onDragOver(event);
	    }
	  }
	};

	var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
	  if (dragEl) {
	    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
	  }
	};
	/**
	 * @class  Sortable
	 * @param  {HTMLElement}  el
	 * @param  {Object}       [options]
	 */


	function Sortable(el, options) {
	  if (!(el && el.nodeType && el.nodeType === 1)) {
	    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
	  }

	  this.el = el; // root element

	  this.options = options = _extends$1({}, options); // Export instance

	  el[expando] = this;
	  var defaults = {
	    group: null,
	    sort: true,
	    disabled: false,
	    store: null,
	    handle: null,
	    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
	    swapThreshold: 1,
	    // percentage; 0 <= x <= 1
	    invertSwap: false,
	    // invert always
	    invertedSwapThreshold: null,
	    // will be set to same as swapThreshold if default
	    removeCloneOnHide: true,
	    direction: function direction() {
	      return _detectDirection(el, this.options);
	    },
	    ghostClass: 'sortable-ghost',
	    chosenClass: 'sortable-chosen',
	    dragClass: 'sortable-drag',
	    ignore: 'a, img',
	    filter: null,
	    preventOnFilter: true,
	    animation: 0,
	    easing: null,
	    setData: function setData(dataTransfer, dragEl) {
	      dataTransfer.setData('Text', dragEl.textContent);
	    },
	    dropBubble: false,
	    dragoverBubble: false,
	    dataIdAttr: 'data-id',
	    delay: 0,
	    delayOnTouchOnly: false,
	    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
	    forceFallback: false,
	    fallbackClass: 'sortable-fallback',
	    fallbackOnBody: false,
	    fallbackTolerance: 0,
	    fallbackOffset: {
	      x: 0,
	      y: 0
	    },
	    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,
	    emptyInsertThreshold: 5
	  };
	  PluginManager.initializePlugins(this, el, defaults); // Set default options

	  for (var name in defaults) {
	    !(name in options) && (options[name] = defaults[name]);
	  }

	  _prepareGroup(options); // Bind all private methods


	  for (var fn in this) {
	    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
	      this[fn] = this[fn].bind(this);
	    }
	  } // Setup drag mode


	  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

	  if (this.nativeDraggable) {
	    // Touch start threshold cannot be greater than the native dragstart threshold
	    this.options.touchStartThreshold = 1;
	  } // Bind events


	  if (options.supportPointer) {
	    on$1(el, 'pointerdown', this._onTapStart);
	  } else {
	    on$1(el, 'mousedown', this._onTapStart);
	    on$1(el, 'touchstart', this._onTapStart);
	  }

	  if (this.nativeDraggable) {
	    on$1(el, 'dragover', this);
	    on$1(el, 'dragenter', this);
	  }

	  sortables.push(this.el); // Restore sorting

	  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

	  _extends$1(this, AnimationStateManager());
	}

	Sortable.prototype =
	/** @lends Sortable.prototype */
	{
	  constructor: Sortable,
	  _isOutsideThisEl: function _isOutsideThisEl(target) {
	    if (!this.el.contains(target) && target !== this.el) {
	      lastTarget = null;
	    }
	  },
	  _getDirection: function _getDirection(evt, target) {
	    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
	  },
	  _onTapStart: function _onTapStart(
	  /** Event|TouchEvent */
	  evt) {
	    if (!evt.cancelable) return;

	    var _this = this,
	        el = this.el,
	        options = this.options,
	        preventOnFilter = options.preventOnFilter,
	        type = evt.type,
	        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
	        target = (touch || evt).target,
	        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
	        filter = options.filter;

	    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


	    if (dragEl) {
	      return;
	    }

	    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
	      return; // only left button and enabled
	    } // cancel dnd if original target is content editable


	    if (originalTarget.isContentEditable) {
	      return;
	    }

	    target = closest$1(target, options.draggable, el, false);

	    if (target && target.animated) {
	      return;
	    }

	    if (lastDownEl === target) {
	      // Ignoring duplicate `down`
	      return;
	    } // Get the index of the dragged element within its parent


	    oldIndex = index(target);
	    oldDraggableIndex = index(target, options.draggable); // Check filter

	    if (typeof filter === 'function') {
	      if (filter.call(this, evt, target, this)) {
	        _dispatchEvent({
	          sortable: _this,
	          rootEl: originalTarget,
	          name: 'filter',
	          targetEl: target,
	          toEl: el,
	          fromEl: el
	        });

	        pluginEvent('filter', _this, {
	          evt: evt
	        });
	        preventOnFilter && evt.cancelable && evt.preventDefault();
	        return; // cancel dnd
	      }
	    } else if (filter) {
	      filter = filter.split(',').some(function (criteria) {
	        criteria = closest$1(originalTarget, criteria.trim(), el, false);

	        if (criteria) {
	          _dispatchEvent({
	            sortable: _this,
	            rootEl: criteria,
	            name: 'filter',
	            targetEl: target,
	            fromEl: el,
	            toEl: el
	          });

	          pluginEvent('filter', _this, {
	            evt: evt
	          });
	          return true;
	        }
	      });

	      if (filter) {
	        preventOnFilter && evt.cancelable && evt.preventDefault();
	        return; // cancel dnd
	      }
	    }

	    if (options.handle && !closest$1(originalTarget, options.handle, el, false)) {
	      return;
	    } // Prepare `dragstart`


	    this._prepareDragStart(evt, touch, target);
	  },
	  _prepareDragStart: function _prepareDragStart(
	  /** Event */
	  evt,
	  /** Touch */
	  touch,
	  /** HTMLElement */
	  target) {
	    var _this = this,
	        el = _this.el,
	        options = _this.options,
	        ownerDocument = el.ownerDocument,
	        dragStartFn;

	    if (target && !dragEl && target.parentNode === el) {
	      var dragRect = getRect(target);
	      rootEl = el;
	      dragEl = target;
	      parentEl = dragEl.parentNode;
	      nextEl = dragEl.nextSibling;
	      lastDownEl = target;
	      activeGroup = options.group;
	      Sortable.dragged = dragEl;
	      tapEvt = {
	        target: dragEl,
	        clientX: (touch || evt).clientX,
	        clientY: (touch || evt).clientY
	      };
	      tapDistanceLeft = tapEvt.clientX - dragRect.left;
	      tapDistanceTop = tapEvt.clientY - dragRect.top;
	      this._lastX = (touch || evt).clientX;
	      this._lastY = (touch || evt).clientY;
	      dragEl.style['will-change'] = 'all';

	      dragStartFn = function dragStartFn() {
	        pluginEvent('delayEnded', _this, {
	          evt: evt
	        });

	        if (Sortable.eventCanceled) {
	          _this._onDrop();

	          return;
	        } // Delayed drag has been triggered
	        // we can re-enable the events: touchmove/mousemove


	        _this._disableDelayedDragEvents();

	        if (!FireFox && _this.nativeDraggable) {
	          dragEl.draggable = true;
	        } // Bind the events: dragstart/dragend


	        _this._triggerDragStart(evt, touch); // Drag start event


	        _dispatchEvent({
	          sortable: _this,
	          name: 'choose',
	          originalEvent: evt
	        }); // Chosen item


	        toggleClass(dragEl, options.chosenClass, true);
	      }; // Disable "draggable"


	      options.ignore.split(',').forEach(function (criteria) {
	        find$1(dragEl, criteria.trim(), _disableDraggable);
	      });
	      on$1(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
	      on$1(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
	      on$1(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
	      on$1(ownerDocument, 'mouseup', _this._onDrop);
	      on$1(ownerDocument, 'touchend', _this._onDrop);
	      on$1(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

	      if (FireFox && this.nativeDraggable) {
	        this.options.touchStartThreshold = 4;
	        dragEl.draggable = true;
	      }

	      pluginEvent('delayStart', this, {
	        evt: evt
	      }); // Delay is impossible for native DnD in Edge or IE

	      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
	        if (Sortable.eventCanceled) {
	          this._onDrop();

	          return;
	        } // If the user moves the pointer or let go the click or touch
	        // before the delay has been reached:
	        // disable the delayed drag


	        on$1(ownerDocument, 'mouseup', _this._disableDelayedDrag);
	        on$1(ownerDocument, 'touchend', _this._disableDelayedDrag);
	        on$1(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
	        on$1(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
	        on$1(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
	        options.supportPointer && on$1(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
	        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
	      } else {
	        dragStartFn();
	      }
	    }
	  },
	  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
	  /** TouchEvent|PointerEvent **/
	  e) {
	    var touch = e.touches ? e.touches[0] : e;

	    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
	      this._disableDelayedDrag();
	    }
	  },
	  _disableDelayedDrag: function _disableDelayedDrag() {
	    dragEl && _disableDraggable(dragEl);
	    clearTimeout(this._dragStartTimer);

	    this._disableDelayedDragEvents();
	  },
	  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
	    var ownerDocument = this.el.ownerDocument;
	    off$1(ownerDocument, 'mouseup', this._disableDelayedDrag);
	    off$1(ownerDocument, 'touchend', this._disableDelayedDrag);
	    off$1(ownerDocument, 'touchcancel', this._disableDelayedDrag);
	    off$1(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
	    off$1(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
	    off$1(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
	  },
	  _triggerDragStart: function _triggerDragStart(
	  /** Event */
	  evt,
	  /** Touch */
	  touch) {
	    touch = touch || evt.pointerType == 'touch' && evt;

	    if (!this.nativeDraggable || touch) {
	      if (this.options.supportPointer) {
	        on$1(document, 'pointermove', this._onTouchMove);
	      } else if (touch) {
	        on$1(document, 'touchmove', this._onTouchMove);
	      } else {
	        on$1(document, 'mousemove', this._onTouchMove);
	      }
	    } else {
	      on$1(dragEl, 'dragend', this);
	      on$1(rootEl, 'dragstart', this._onDragStart);
	    }

	    try {
	      if (document.selection) {
	        // Timeout neccessary for IE9
	        _nextTick(function () {
	          document.selection.empty();
	        });
	      } else {
	        window.getSelection().removeAllRanges();
	      }
	    } catch (err) {}
	  },
	  _dragStarted: function _dragStarted(fallback, evt) {
	    awaitingDragStarted = false;

	    if (rootEl && dragEl) {
	      pluginEvent('dragStarted', this, {
	        evt: evt
	      });

	      if (this.nativeDraggable) {
	        on$1(document, 'dragover', _checkOutsideTargetEl);
	      }

	      var options = this.options; // Apply effect

	      !fallback && toggleClass(dragEl, options.dragClass, false);
	      toggleClass(dragEl, options.ghostClass, true);
	      Sortable.active = this;
	      fallback && this._appendGhost(); // Drag start event

	      _dispatchEvent({
	        sortable: this,
	        name: 'start',
	        originalEvent: evt
	      });
	    } else {
	      this._nulling();
	    }
	  },
	  _emulateDragOver: function _emulateDragOver() {
	    if (touchEvt) {
	      this._lastX = touchEvt.clientX;
	      this._lastY = touchEvt.clientY;

	      _hideGhostForTarget();

	      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
	      var parent = target;

	      while (target && target.shadowRoot) {
	        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
	        if (target === parent) break;
	        parent = target;
	      }

	      dragEl.parentNode[expando]._isOutsideThisEl(target);

	      if (parent) {
	        do {
	          if (parent[expando]) {
	            var inserted = void 0;
	            inserted = parent[expando]._onDragOver({
	              clientX: touchEvt.clientX,
	              clientY: touchEvt.clientY,
	              target: target,
	              rootEl: parent
	            });

	            if (inserted && !this.options.dragoverBubble) {
	              break;
	            }
	          }

	          target = parent; // store last element
	        }
	        /* jshint boss:true */
	        while (parent = parent.parentNode);
	      }

	      _unhideGhostForTarget();
	    }
	  },
	  _onTouchMove: function _onTouchMove(
	  /**TouchEvent*/
	  evt) {
	    if (tapEvt) {
	      var options = this.options,
	          fallbackTolerance = options.fallbackTolerance,
	          fallbackOffset = options.fallbackOffset,
	          touch = evt.touches ? evt.touches[0] : evt,
	          ghostMatrix = ghostEl && matrix(ghostEl, true),
	          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
	          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
	          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
	          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
	          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

	      if (!Sortable.active && !awaitingDragStarted) {
	        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
	          return;
	        }

	        this._onDragStart(evt, true);
	      }

	      if (ghostEl) {
	        if (ghostMatrix) {
	          ghostMatrix.e += dx - (lastDx || 0);
	          ghostMatrix.f += dy - (lastDy || 0);
	        } else {
	          ghostMatrix = {
	            a: 1,
	            b: 0,
	            c: 0,
	            d: 1,
	            e: dx,
	            f: dy
	          };
	        }

	        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
	        css$1(ghostEl, 'webkitTransform', cssMatrix);
	        css$1(ghostEl, 'mozTransform', cssMatrix);
	        css$1(ghostEl, 'msTransform', cssMatrix);
	        css$1(ghostEl, 'transform', cssMatrix);
	        lastDx = dx;
	        lastDy = dy;
	        touchEvt = touch;
	      }

	      evt.cancelable && evt.preventDefault();
	    }
	  },
	  _appendGhost: function _appendGhost() {
	    // Bug if using scale(): https://stackoverflow.com/questions/2637058
	    // Not being adjusted for
	    if (!ghostEl) {
	      var container = this.options.fallbackOnBody ? document.body : rootEl,
	          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
	          options = this.options; // Position absolutely

	      if (PositionGhostAbsolutely) {
	        // Get relatively positioned parent
	        ghostRelativeParent = container;

	        while (css$1(ghostRelativeParent, 'position') === 'static' && css$1(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
	          ghostRelativeParent = ghostRelativeParent.parentNode;
	        }

	        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
	          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
	          rect.top += ghostRelativeParent.scrollTop;
	          rect.left += ghostRelativeParent.scrollLeft;
	        } else {
	          ghostRelativeParent = getWindowScrollingElement();
	        }

	        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
	      }

	      ghostEl = dragEl.cloneNode(true);
	      toggleClass(ghostEl, options.ghostClass, false);
	      toggleClass(ghostEl, options.fallbackClass, true);
	      toggleClass(ghostEl, options.dragClass, true);
	      css$1(ghostEl, 'transition', '');
	      css$1(ghostEl, 'transform', '');
	      css$1(ghostEl, 'box-sizing', 'border-box');
	      css$1(ghostEl, 'margin', 0);
	      css$1(ghostEl, 'top', rect.top);
	      css$1(ghostEl, 'left', rect.left);
	      css$1(ghostEl, 'width', rect.width);
	      css$1(ghostEl, 'height', rect.height);
	      css$1(ghostEl, 'opacity', '0.8');
	      css$1(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
	      css$1(ghostEl, 'zIndex', '100000');
	      css$1(ghostEl, 'pointerEvents', 'none');
	      Sortable.ghost = ghostEl;
	      container.appendChild(ghostEl); // Set transform-origin

	      css$1(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
	    }
	  },
	  _onDragStart: function _onDragStart(
	  /**Event*/
	  evt,
	  /**boolean*/
	  fallback) {
	    var _this = this;

	    var dataTransfer = evt.dataTransfer;
	    var options = _this.options;
	    pluginEvent('dragStart', this, {
	      evt: evt
	    });

	    if (Sortable.eventCanceled) {
	      this._onDrop();

	      return;
	    }

	    pluginEvent('setupClone', this);

	    if (!Sortable.eventCanceled) {
	      cloneEl = clone(dragEl);
	      cloneEl.draggable = false;
	      cloneEl.style['will-change'] = '';

	      this._hideClone();

	      toggleClass(cloneEl, this.options.chosenClass, false);
	      Sortable.clone = cloneEl;
	    } // #1143: IFrame support workaround


	    _this.cloneId = _nextTick(function () {
	      pluginEvent('clone', _this);
	      if (Sortable.eventCanceled) return;

	      if (!_this.options.removeCloneOnHide) {
	        rootEl.insertBefore(cloneEl, dragEl);
	      }

	      _this._hideClone();

	      _dispatchEvent({
	        sortable: _this,
	        name: 'clone'
	      });
	    });
	    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

	    if (fallback) {
	      ignoreNextClick = true;
	      _this._loopId = setInterval(_this._emulateDragOver, 50);
	    } else {
	      // Undo what was set in _prepareDragStart before drag started
	      off$1(document, 'mouseup', _this._onDrop);
	      off$1(document, 'touchend', _this._onDrop);
	      off$1(document, 'touchcancel', _this._onDrop);

	      if (dataTransfer) {
	        dataTransfer.effectAllowed = 'move';
	        options.setData && options.setData.call(_this, dataTransfer, dragEl);
	      }

	      on$1(document, 'drop', _this); // #1276 fix:

	      css$1(dragEl, 'transform', 'translateZ(0)');
	    }

	    awaitingDragStarted = true;
	    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
	    on$1(document, 'selectstart', _this);
	    moved = true;

	    if (Safari) {
	      css$1(document.body, 'user-select', 'none');
	    }
	  },
	  // Returns true - if no further action is needed (either inserted or another condition)
	  _onDragOver: function _onDragOver(
	  /**Event*/
	  evt) {
	    var el = this.el,
	        target = evt.target,
	        dragRect,
	        targetRect,
	        revert,
	        options = this.options,
	        group = options.group,
	        activeSortable = Sortable.active,
	        isOwner = activeGroup === group,
	        canSort = options.sort,
	        fromSortable = putSortable || activeSortable,
	        vertical,
	        _this = this,
	        completedFired = false;

	    if (_silent) return;

	    function dragOverEvent(name, extra) {
	      pluginEvent(name, _this, _objectSpread({
	        evt: evt,
	        isOwner: isOwner,
	        axis: vertical ? 'vertical' : 'horizontal',
	        revert: revert,
	        dragRect: dragRect,
	        targetRect: targetRect,
	        canSort: canSort,
	        fromSortable: fromSortable,
	        target: target,
	        completed: completed,
	        onMove: function onMove(target, after) {
	          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
	        },
	        changed: changed
	      }, extra));
	    } // Capture animation state


	    function capture() {
	      dragOverEvent('dragOverAnimationCapture');

	      _this.captureAnimationState();

	      if (_this !== fromSortable) {
	        fromSortable.captureAnimationState();
	      }
	    } // Return invocation when dragEl is inserted (or completed)


	    function completed(insertion) {
	      dragOverEvent('dragOverCompleted', {
	        insertion: insertion
	      });

	      if (insertion) {
	        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
	        if (isOwner) {
	          activeSortable._hideClone();
	        } else {
	          activeSortable._showClone(_this);
	        }

	        if (_this !== fromSortable) {
	          // Set ghost class to new sortable's ghost class
	          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
	          toggleClass(dragEl, options.ghostClass, true);
	        }

	        if (putSortable !== _this && _this !== Sortable.active) {
	          putSortable = _this;
	        } else if (_this === Sortable.active && putSortable) {
	          putSortable = null;
	        } // Animation


	        if (fromSortable === _this) {
	          _this._ignoreWhileAnimating = target;
	        }

	        _this.animateAll(function () {
	          dragOverEvent('dragOverAnimationComplete');
	          _this._ignoreWhileAnimating = null;
	        });

	        if (_this !== fromSortable) {
	          fromSortable.animateAll();
	          fromSortable._ignoreWhileAnimating = null;
	        }
	      } // Null lastTarget if it is not inside a previously swapped element


	      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
	        lastTarget = null;
	      } // no bubbling and not fallback


	      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
	        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


	        !insertion && nearestEmptyInsertDetectEvent(evt);
	      }

	      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
	      return completedFired = true;
	    } // Call when dragEl has been inserted


	    function changed() {
	      newIndex = index(dragEl);
	      newDraggableIndex = index(dragEl, options.draggable);

	      _dispatchEvent({
	        sortable: _this,
	        name: 'change',
	        toEl: el,
	        newIndex: newIndex,
	        newDraggableIndex: newDraggableIndex,
	        originalEvent: evt
	      });
	    }

	    if (evt.preventDefault !== void 0) {
	      evt.cancelable && evt.preventDefault();
	    }

	    target = closest$1(target, options.draggable, el, true);
	    dragOverEvent('dragOver');
	    if (Sortable.eventCanceled) return completedFired;

	    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
	      return completed(false);
	    }

	    ignoreNextClick = false;

	    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
	    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
	      vertical = this._getDirection(evt, target) === 'vertical';
	      dragRect = getRect(dragEl);
	      dragOverEvent('dragOverValid');
	      if (Sortable.eventCanceled) return completedFired;

	      if (revert) {
	        parentEl = rootEl; // actualization

	        capture();

	        this._hideClone();

	        dragOverEvent('revert');

	        if (!Sortable.eventCanceled) {
	          if (nextEl) {
	            rootEl.insertBefore(dragEl, nextEl);
	          } else {
	            rootEl.appendChild(dragEl);
	          }
	        }

	        return completed(true);
	      }

	      var elLastChild = lastChild(el, options.draggable);

	      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
	        // If already at end of list: Do not insert
	        if (elLastChild === dragEl) {
	          return completed(false);
	        } // assign target only if condition is true


	        if (elLastChild && el === evt.target) {
	          target = elLastChild;
	        }

	        if (target) {
	          targetRect = getRect(target);
	        }

	        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
	          capture();
	          el.appendChild(dragEl);
	          parentEl = el; // actualization

	          changed();
	          return completed(true);
	        }
	      } else if (target.parentNode === el) {
	        targetRect = getRect(target);
	        var direction = 0,
	            targetBeforeFirstSwap,
	            differentLevel = dragEl.parentNode !== el,
	            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
	            side1 = vertical ? 'top' : 'left',
	            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
	            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

	        if (lastTarget !== target) {
	          targetBeforeFirstSwap = targetRect[side1];
	          pastFirstInvertThresh = false;
	          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
	        }

	        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
	        var sibling;

	        if (direction !== 0) {
	          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
	          var dragIndex = index(dragEl);

	          do {
	            dragIndex -= direction;
	            sibling = parentEl.children[dragIndex];
	          } while (sibling && (css$1(sibling, 'display') === 'none' || sibling === ghostEl));
	        } // If dragEl is already beside target: Do not insert


	        if (direction === 0 || sibling === target) {
	          return completed(false);
	        }

	        lastTarget = target;
	        lastDirection = direction;
	        var nextSibling = target.nextElementSibling,
	            after = false;
	        after = direction === 1;

	        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

	        if (moveVector !== false) {
	          if (moveVector === 1 || moveVector === -1) {
	            after = moveVector === 1;
	          }

	          _silent = true;
	          setTimeout(_unsilent, 30);
	          capture();

	          if (after && !nextSibling) {
	            el.appendChild(dragEl);
	          } else {
	            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
	          } // Undo chrome's scroll adjustment (has no effect on other browsers)


	          if (scrolledPastTop) {
	            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
	          }

	          parentEl = dragEl.parentNode; // actualization
	          // must be done before animation

	          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
	            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
	          }

	          changed();
	          return completed(true);
	        }
	      }

	      if (el.contains(dragEl)) {
	        return completed(false);
	      }
	    }

	    return false;
	  },
	  _ignoreWhileAnimating: null,
	  _offMoveEvents: function _offMoveEvents() {
	    off$1(document, 'mousemove', this._onTouchMove);
	    off$1(document, 'touchmove', this._onTouchMove);
	    off$1(document, 'pointermove', this._onTouchMove);
	    off$1(document, 'dragover', nearestEmptyInsertDetectEvent);
	    off$1(document, 'mousemove', nearestEmptyInsertDetectEvent);
	    off$1(document, 'touchmove', nearestEmptyInsertDetectEvent);
	  },
	  _offUpEvents: function _offUpEvents() {
	    var ownerDocument = this.el.ownerDocument;
	    off$1(ownerDocument, 'mouseup', this._onDrop);
	    off$1(ownerDocument, 'touchend', this._onDrop);
	    off$1(ownerDocument, 'pointerup', this._onDrop);
	    off$1(ownerDocument, 'touchcancel', this._onDrop);
	    off$1(document, 'selectstart', this);
	  },
	  _onDrop: function _onDrop(
	  /**Event*/
	  evt) {
	    var el = this.el,
	        options = this.options; // Get the index of the dragged element within its parent

	    newIndex = index(dragEl);
	    newDraggableIndex = index(dragEl, options.draggable);
	    pluginEvent('drop', this, {
	      evt: evt
	    });
	    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

	    newIndex = index(dragEl);
	    newDraggableIndex = index(dragEl, options.draggable);

	    if (Sortable.eventCanceled) {
	      this._nulling();

	      return;
	    }

	    awaitingDragStarted = false;
	    isCircumstantialInvert = false;
	    pastFirstInvertThresh = false;
	    clearInterval(this._loopId);
	    clearTimeout(this._dragStartTimer);

	    _cancelNextTick(this.cloneId);

	    _cancelNextTick(this._dragStartId); // Unbind events


	    if (this.nativeDraggable) {
	      off$1(document, 'drop', this);
	      off$1(el, 'dragstart', this._onDragStart);
	    }

	    this._offMoveEvents();

	    this._offUpEvents();

	    if (Safari) {
	      css$1(document.body, 'user-select', '');
	    }

	    css$1(dragEl, 'transform', '');

	    if (evt) {
	      if (moved) {
	        evt.cancelable && evt.preventDefault();
	        !options.dropBubble && evt.stopPropagation();
	      }

	      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

	      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
	        // Remove clone(s)
	        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
	      }

	      if (dragEl) {
	        if (this.nativeDraggable) {
	          off$1(dragEl, 'dragend', this);
	        }

	        _disableDraggable(dragEl);

	        dragEl.style['will-change'] = ''; // Remove classes
	        // ghostClass is added in dragStarted

	        if (moved && !awaitingDragStarted) {
	          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
	        }

	        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

	        _dispatchEvent({
	          sortable: this,
	          name: 'unchoose',
	          toEl: parentEl,
	          newIndex: null,
	          newDraggableIndex: null,
	          originalEvent: evt
	        });

	        if (rootEl !== parentEl) {
	          if (newIndex >= 0) {
	            // Add event
	            _dispatchEvent({
	              rootEl: parentEl,
	              name: 'add',
	              toEl: parentEl,
	              fromEl: rootEl,
	              originalEvent: evt
	            }); // Remove event


	            _dispatchEvent({
	              sortable: this,
	              name: 'remove',
	              toEl: parentEl,
	              originalEvent: evt
	            }); // drag from one list and drop into another


	            _dispatchEvent({
	              rootEl: parentEl,
	              name: 'sort',
	              toEl: parentEl,
	              fromEl: rootEl,
	              originalEvent: evt
	            });

	            _dispatchEvent({
	              sortable: this,
	              name: 'sort',
	              toEl: parentEl,
	              originalEvent: evt
	            });
	          }

	          putSortable && putSortable.save();
	        } else {
	          if (newIndex !== oldIndex) {
	            if (newIndex >= 0) {
	              // drag & drop within the same list
	              _dispatchEvent({
	                sortable: this,
	                name: 'update',
	                toEl: parentEl,
	                originalEvent: evt
	              });

	              _dispatchEvent({
	                sortable: this,
	                name: 'sort',
	                toEl: parentEl,
	                originalEvent: evt
	              });
	            }
	          }
	        }

	        if (Sortable.active) {
	          /* jshint eqnull:true */
	          if (newIndex == null || newIndex === -1) {
	            newIndex = oldIndex;
	            newDraggableIndex = oldDraggableIndex;
	          }

	          _dispatchEvent({
	            sortable: this,
	            name: 'end',
	            toEl: parentEl,
	            originalEvent: evt
	          }); // Save sorting


	          this.save();
	        }
	      }
	    }

	    this._nulling();
	  },
	  _nulling: function _nulling() {
	    pluginEvent('nulling', this);
	    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
	    savedInputChecked.forEach(function (el) {
	      el.checked = true;
	    });
	    savedInputChecked.length = lastDx = lastDy = 0;
	  },
	  handleEvent: function handleEvent(
	  /**Event*/
	  evt) {
	    switch (evt.type) {
	      case 'drop':
	      case 'dragend':
	        this._onDrop(evt);

	        break;

	      case 'dragenter':
	      case 'dragover':
	        if (dragEl) {
	          this._onDragOver(evt);

	          _globalDragOver(evt);
	        }

	        break;

	      case 'selectstart':
	        evt.preventDefault();
	        break;
	    }
	  },

	  /**
	   * Serializes the item into an array of string.
	   * @returns {String[]}
	   */
	  toArray: function toArray() {
	    var order = [],
	        el,
	        children = this.el.children,
	        i = 0,
	        n = children.length,
	        options = this.options;

	    for (; i < n; i++) {
	      el = children[i];

	      if (closest$1(el, options.draggable, this.el, false)) {
	        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
	      }
	    }

	    return order;
	  },

	  /**
	   * Sorts the elements according to the array.
	   * @param  {String[]}  order  order of the items
	   */
	  sort: function sort(order) {
	    var items = {},
	        rootEl = this.el;
	    this.toArray().forEach(function (id, i) {
	      var el = rootEl.children[i];

	      if (closest$1(el, this.options.draggable, rootEl, false)) {
	        items[id] = el;
	      }
	    }, this);
	    order.forEach(function (id) {
	      if (items[id]) {
	        rootEl.removeChild(items[id]);
	        rootEl.appendChild(items[id]);
	      }
	    });
	  },

	  /**
	   * Save the current sorting
	   */
	  save: function save() {
	    var store = this.options.store;
	    store && store.set && store.set(this);
	  },

	  /**
	   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
	   * @param   {HTMLElement}  el
	   * @param   {String}       [selector]  default: `options.draggable`
	   * @returns {HTMLElement|null}
	   */
	  closest: function closest$1$1(el, selector) {
	    return closest$1(el, selector || this.options.draggable, this.el, false);
	  },

	  /**
	   * Set/get option
	   * @param   {string} name
	   * @param   {*}      [value]
	   * @returns {*}
	   */
	  option: function option(name, value) {
	    var options = this.options;

	    if (value === void 0) {
	      return options[name];
	    } else {
	      var modifiedValue = PluginManager.modifyOption(this, name, value);

	      if (typeof modifiedValue !== 'undefined') {
	        options[name] = modifiedValue;
	      } else {
	        options[name] = value;
	      }

	      if (name === 'group') {
	        _prepareGroup(options);
	      }
	    }
	  },

	  /**
	   * Destroy
	   */
	  destroy: function destroy() {
	    pluginEvent('destroy', this);
	    var el = this.el;
	    el[expando] = null;
	    off$1(el, 'mousedown', this._onTapStart);
	    off$1(el, 'touchstart', this._onTapStart);
	    off$1(el, 'pointerdown', this._onTapStart);

	    if (this.nativeDraggable) {
	      off$1(el, 'dragover', this);
	      off$1(el, 'dragenter', this);
	    } // Remove draggable attributes


	    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
	      el.removeAttribute('draggable');
	    });

	    this._onDrop();

	    this._disableDelayedDragEvents();

	    sortables.splice(sortables.indexOf(this.el), 1);
	    this.el = el = null;
	  },
	  _hideClone: function _hideClone() {
	    if (!cloneHidden) {
	      pluginEvent('hideClone', this);
	      if (Sortable.eventCanceled) return;
	      css$1(cloneEl, 'display', 'none');

	      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
	        cloneEl.parentNode.removeChild(cloneEl);
	      }

	      cloneHidden = true;
	    }
	  },
	  _showClone: function _showClone(putSortable) {
	    if (putSortable.lastPutMode !== 'clone') {
	      this._hideClone();

	      return;
	    }

	    if (cloneHidden) {
	      pluginEvent('showClone', this);
	      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

	      if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
	        rootEl.insertBefore(cloneEl, dragEl);
	      } else if (nextEl) {
	        rootEl.insertBefore(cloneEl, nextEl);
	      } else {
	        rootEl.appendChild(cloneEl);
	      }

	      if (this.options.group.revertClone) {
	        this.animate(dragEl, cloneEl);
	      }

	      css$1(cloneEl, 'display', '');
	      cloneHidden = false;
	    }
	  }
	};

	function _globalDragOver(
	/**Event*/
	evt) {
	  if (evt.dataTransfer) {
	    evt.dataTransfer.dropEffect = 'move';
	  }

	  evt.cancelable && evt.preventDefault();
	}

	function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
	  var evt,
	      sortable = fromEl[expando],
	      onMoveFn = sortable.options.onMove,
	      retVal; // Support for new CustomEvent feature

	  if (window.CustomEvent && !IE11OrLess && !Edge) {
	    evt = new CustomEvent('move', {
	      bubbles: true,
	      cancelable: true
	    });
	  } else {
	    evt = document.createEvent('Event');
	    evt.initEvent('move', true, true);
	  }

	  evt.to = toEl;
	  evt.from = fromEl;
	  evt.dragged = dragEl;
	  evt.draggedRect = dragRect;
	  evt.related = targetEl || toEl;
	  evt.relatedRect = targetRect || getRect(toEl);
	  evt.willInsertAfter = willInsertAfter;
	  evt.originalEvent = originalEvent;
	  fromEl.dispatchEvent(evt);

	  if (onMoveFn) {
	    retVal = onMoveFn.call(sortable, evt, originalEvent);
	  }

	  return retVal;
	}

	function _disableDraggable(el) {
	  el.draggable = false;
	}

	function _unsilent() {
	  _silent = false;
	}

	function _ghostIsLast(evt, vertical, sortable) {
	  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
	  var spacer = 10;
	  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
	}

	function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
	  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
	      targetLength = vertical ? targetRect.height : targetRect.width,
	      targetS1 = vertical ? targetRect.top : targetRect.left,
	      targetS2 = vertical ? targetRect.bottom : targetRect.right,
	      invert = false;

	  if (!invertSwap) {
	    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
	    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
	      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
	      // check if past first invert threshold on side opposite of lastDirection
	      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
	        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
	        pastFirstInvertThresh = true;
	      }

	      if (!pastFirstInvertThresh) {
	        // dragEl shadow (target move distance shadow)
	        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
	        : mouseOnAxis > targetS2 - targetMoveDistance) {
	          return -lastDirection;
	        }
	      } else {
	        invert = true;
	      }
	    } else {
	      // Regular
	      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
	        return _getInsertDirection(target);
	      }
	    }
	  }

	  invert = invert || invertSwap;

	  if (invert) {
	    // Invert of regular
	    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
	      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
	    }
	  }

	  return 0;
	}
	/**
	 * Gets the direction dragEl must be swapped relative to target in order to make it
	 * seem that dragEl has been "inserted" into that element's position
	 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
	 * @return {Number}                   Direction dragEl must be swapped
	 */


	function _getInsertDirection(target) {
	  if (index(dragEl) < index(target)) {
	    return 1;
	  } else {
	    return -1;
	  }
	}
	/**
	 * Generate id
	 * @param   {HTMLElement} el
	 * @returns {String}
	 * @private
	 */


	function _generateId(el) {
	  var str = el.tagName + el.className + el.src + el.href + el.textContent,
	      i = str.length,
	      sum = 0;

	  while (i--) {
	    sum += str.charCodeAt(i);
	  }

	  return sum.toString(36);
	}

	function _saveInputCheckedState(root) {
	  savedInputChecked.length = 0;
	  var inputs = root.getElementsByTagName('input');
	  var idx = inputs.length;

	  while (idx--) {
	    var el = inputs[idx];
	    el.checked && savedInputChecked.push(el);
	  }
	}

	function _nextTick(fn) {
	  return setTimeout(fn, 0);
	}

	function _cancelNextTick(id) {
	  return clearTimeout(id);
	} // Fixed #973:


	if (documentExists) {
	  on$1(document, 'touchmove', function (evt) {
	    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
	      evt.preventDefault();
	    }
	  });
	} // Export utils


	Sortable.utils = {
	  on: on$1,
	  off: off$1,
	  css: css$1,
	  find: find$1,
	  is: function is(el, selector) {
	    return !!closest$1(el, selector, el, false);
	  },
	  extend: extend,
	  throttle: throttle$1,
	  closest: closest$1,
	  toggleClass: toggleClass,
	  clone: clone,
	  index: index,
	  nextTick: _nextTick,
	  cancelNextTick: _cancelNextTick,
	  detectDirection: _detectDirection,
	  getChild: getChild
	};
	/**
	 * Get the Sortable instance of an element
	 * @param  {HTMLElement} element The element
	 * @return {Sortable|undefined}         The instance of Sortable
	 */

	Sortable.get = function (element) {
	  return element[expando];
	};
	/**
	 * Mount a plugin to Sortable
	 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
	 */


	Sortable.mount = function () {
	  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
	    plugins[_key] = arguments[_key];
	  }

	  if (plugins[0].constructor === Array) plugins = plugins[0];
	  plugins.forEach(function (plugin) {
	    if (!plugin.prototype || !plugin.prototype.constructor) {
	      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
	    }

	    if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);
	    PluginManager.mount(plugin);
	  });
	};
	/**
	 * Create sortable instance
	 * @param {HTMLElement}  el
	 * @param {Object}      [options]
	 */


	Sortable.create = function (el, options) {
	  return new Sortable(el, options);
	}; // Export


	Sortable.version = version;
	var autoScrolls = [],
	    scrollEl,
	    scrollRootEl,
	    scrolling = false,
	    lastAutoScrollX,
	    lastAutoScrollY,
	    touchEvt$1,
	    pointerElemChangedInterval;

	function AutoScrollPlugin() {
	  function AutoScroll() {
	    this.defaults = {
	      scroll: true,
	      scrollSensitivity: 30,
	      scrollSpeed: 10,
	      bubbleScroll: true
	    }; // Bind all private methods

	    for (var fn in this) {
	      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
	        this[fn] = this[fn].bind(this);
	      }
	    }
	  }

	  AutoScroll.prototype = {
	    dragStarted: function dragStarted(_ref) {
	      var originalEvent = _ref.originalEvent;

	      if (this.sortable.nativeDraggable) {
	        on$1(document, 'dragover', this._handleAutoScroll);
	      } else {
	        if (this.options.supportPointer) {
	          on$1(document, 'pointermove', this._handleFallbackAutoScroll);
	        } else if (originalEvent.touches) {
	          on$1(document, 'touchmove', this._handleFallbackAutoScroll);
	        } else {
	          on$1(document, 'mousemove', this._handleFallbackAutoScroll);
	        }
	      }
	    },
	    dragOverCompleted: function dragOverCompleted(_ref2) {
	      var originalEvent = _ref2.originalEvent; // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)

	      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
	        this._handleAutoScroll(originalEvent);
	      }
	    },
	    drop: function drop() {
	      if (this.sortable.nativeDraggable) {
	        off$1(document, 'dragover', this._handleAutoScroll);
	      } else {
	        off$1(document, 'pointermove', this._handleFallbackAutoScroll);
	        off$1(document, 'touchmove', this._handleFallbackAutoScroll);
	        off$1(document, 'mousemove', this._handleFallbackAutoScroll);
	      }

	      clearPointerElemChangedInterval();
	      clearAutoScrolls();
	      cancelThrottle();
	    },
	    nulling: function nulling() {
	      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
	      autoScrolls.length = 0;
	    },
	    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
	      this._handleAutoScroll(evt, true);
	    },
	    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
	      var _this = this;

	      var x = (evt.touches ? evt.touches[0] : evt).clientX,
	          y = (evt.touches ? evt.touches[0] : evt).clientY,
	          elem = document.elementFromPoint(x, y);
	      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
	      // Edge's autoscroll seems too conditional,
	      // MACOS Safari does not have autoscroll,
	      // Firefox and Chrome are good

	      if (fallback || Edge || IE11OrLess || Safari) {
	        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

	        var ogElemScroller = getParentAutoScrollElement(elem, true);

	        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
	          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

	          pointerElemChangedInterval = setInterval(function () {
	            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

	            if (newElem !== ogElemScroller) {
	              ogElemScroller = newElem;
	              clearAutoScrolls();
	            }

	            autoScroll(evt, _this.options, newElem, fallback);
	          }, 10);
	          lastAutoScrollX = x;
	          lastAutoScrollY = y;
	        }
	      } else {
	        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
	        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
	          clearAutoScrolls();
	          return;
	        }

	        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
	      }
	    }
	  };
	  return _extends$1(AutoScroll, {
	    pluginName: 'scroll',
	    initializeByDefault: true
	  });
	}

	function clearAutoScrolls() {
	  autoScrolls.forEach(function (autoScroll) {
	    clearInterval(autoScroll.pid);
	  });
	  autoScrolls = [];
	}

	function clearPointerElemChangedInterval() {
	  clearInterval(pointerElemChangedInterval);
	}

	var autoScroll = throttle$1(function (evt, options, rootEl, isFallback) {
	  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
	  if (!options.scroll) return;
	  var x = (evt.touches ? evt.touches[0] : evt).clientX,
	      y = (evt.touches ? evt.touches[0] : evt).clientY,
	      sens = options.scrollSensitivity,
	      speed = options.scrollSpeed,
	      winScroller = getWindowScrollingElement();
	  var scrollThisInstance = false,
	      scrollCustomFn; // New scroll root, set scrollEl

	  if (scrollRootEl !== rootEl) {
	    scrollRootEl = rootEl;
	    clearAutoScrolls();
	    scrollEl = options.scroll;
	    scrollCustomFn = options.scrollFn;

	    if (scrollEl === true) {
	      scrollEl = getParentAutoScrollElement(rootEl, true);
	    }
	  }

	  var layersOut = 0;
	  var currentParent = scrollEl;

	  do {
	    var el = currentParent,
	        rect = getRect(el),
	        top = rect.top,
	        bottom = rect.bottom,
	        left = rect.left,
	        right = rect.right,
	        width = rect.width,
	        height = rect.height,
	        canScrollX = void 0,
	        canScrollY = void 0,
	        scrollWidth = el.scrollWidth,
	        scrollHeight = el.scrollHeight,
	        elCSS = css$1(el),
	        scrollPosX = el.scrollLeft,
	        scrollPosY = el.scrollTop;

	    if (el === winScroller) {
	      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
	      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
	    } else {
	      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
	      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
	    }

	    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
	    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

	    if (!autoScrolls[layersOut]) {
	      for (var i = 0; i <= layersOut; i++) {
	        if (!autoScrolls[i]) {
	          autoScrolls[i] = {};
	        }
	      }
	    }

	    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
	      autoScrolls[layersOut].el = el;
	      autoScrolls[layersOut].vx = vx;
	      autoScrolls[layersOut].vy = vy;
	      clearInterval(autoScrolls[layersOut].pid);

	      if (vx != 0 || vy != 0) {
	        scrollThisInstance = true;
	        /* jshint loopfunc:true */

	        autoScrolls[layersOut].pid = setInterval(function () {
	          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
	          if (isFallback && this.layer === 0) {
	            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

	          }

	          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
	          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

	          if (typeof scrollCustomFn === 'function') {
	            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
	              return;
	            }
	          }

	          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
	        }.bind({
	          layer: layersOut
	        }), 24);
	      }
	    }

	    layersOut++;
	  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

	  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
	}, 30);

	var drop = function drop(_ref) {
	  var originalEvent = _ref.originalEvent,
	      putSortable = _ref.putSortable,
	      dragEl = _ref.dragEl,
	      activeSortable = _ref.activeSortable,
	      dispatchSortableEvent = _ref.dispatchSortableEvent,
	      hideGhostForTarget = _ref.hideGhostForTarget,
	      unhideGhostForTarget = _ref.unhideGhostForTarget;
	  if (!originalEvent) return;
	  var toSortable = putSortable || activeSortable;
	  hideGhostForTarget();
	  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
	  var target = document.elementFromPoint(touch.clientX, touch.clientY);
	  unhideGhostForTarget();

	  if (toSortable && !toSortable.el.contains(target)) {
	    dispatchSortableEvent('spill');
	    this.onSpill({
	      dragEl: dragEl,
	      putSortable: putSortable
	    });
	  }
	};

	function Revert() {}

	Revert.prototype = {
	  startIndex: null,
	  dragStart: function dragStart(_ref2) {
	    var oldDraggableIndex = _ref2.oldDraggableIndex;
	    this.startIndex = oldDraggableIndex;
	  },
	  onSpill: function onSpill(_ref3) {
	    var dragEl = _ref3.dragEl,
	        putSortable = _ref3.putSortable;
	    this.sortable.captureAnimationState();

	    if (putSortable) {
	      putSortable.captureAnimationState();
	    }

	    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

	    if (nextSibling) {
	      this.sortable.el.insertBefore(dragEl, nextSibling);
	    } else {
	      this.sortable.el.appendChild(dragEl);
	    }

	    this.sortable.animateAll();

	    if (putSortable) {
	      putSortable.animateAll();
	    }
	  },
	  drop: drop
	};

	_extends$1(Revert, {
	  pluginName: 'revertOnSpill'
	});

	function Remove() {}

	Remove.prototype = {
	  onSpill: function onSpill(_ref4) {
	    var dragEl = _ref4.dragEl,
	        putSortable = _ref4.putSortable;
	    var parentSortable = putSortable || this.sortable;
	    parentSortable.captureAnimationState();
	    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
	    parentSortable.animateAll();
	  },
	  drop: drop
	};

	_extends$1(Remove, {
	  pluginName: 'removeOnSpill'
	});

	Sortable.mount(new AutoScrollPlugin());
	Sortable.mount(Remove, Revert);

	var vuedraggable_umd = createCommonjsModule(function (module, exports) {
	  (function webpackUniversalModuleDefinition(root, factory) {
	    module.exports = factory(Sortable);
	  })(typeof self !== 'undefined' ? self : commonjsGlobal, function (__WEBPACK_EXTERNAL_MODULE_a352__) {
	    return (
	      /******/
	      function (modules) {
	        // webpackBootstrap

	        /******/
	        // The module cache

	        /******/
	        var installedModules = {};
	        /******/

	        /******/
	        // The require function

	        /******/

	        function __webpack_require__(moduleId) {
	          /******/

	          /******/
	          // Check if module is in cache

	          /******/
	          if (installedModules[moduleId]) {
	            /******/
	            return installedModules[moduleId].exports;
	            /******/
	          }
	          /******/
	          // Create a new module (and put it into the cache)

	          /******/


	          var module = installedModules[moduleId] = {
	            /******/
	            i: moduleId,

	            /******/
	            l: false,

	            /******/
	            exports: {}
	            /******/

	          };
	          /******/

	          /******/
	          // Execute the module function

	          /******/

	          modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	          /******/

	          /******/
	          // Flag the module as loaded

	          /******/

	          module.l = true;
	          /******/

	          /******/
	          // Return the exports of the module

	          /******/

	          return module.exports;
	          /******/
	        }
	        /******/

	        /******/

	        /******/
	        // expose the modules object (__webpack_modules__)

	        /******/


	        __webpack_require__.m = modules;
	        /******/

	        /******/
	        // expose the module cache

	        /******/

	        __webpack_require__.c = installedModules;
	        /******/

	        /******/
	        // define getter function for harmony exports

	        /******/

	        __webpack_require__.d = function (exports, name, getter) {
	          /******/
	          if (!__webpack_require__.o(exports, name)) {
	            /******/
	            Object.defineProperty(exports, name, {
	              enumerable: true,
	              get: getter
	            });
	            /******/
	          }
	          /******/

	        };
	        /******/

	        /******/
	        // define __esModule on exports

	        /******/


	        __webpack_require__.r = function (exports) {
	          /******/
	          if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
	            /******/
	            Object.defineProperty(exports, Symbol.toStringTag, {
	              value: 'Module'
	            });
	            /******/
	          }
	          /******/


	          Object.defineProperty(exports, '__esModule', {
	            value: true
	          });
	          /******/
	        };
	        /******/

	        /******/
	        // create a fake namespace object

	        /******/
	        // mode & 1: value is a module id, require it

	        /******/
	        // mode & 2: merge all properties of value into the ns

	        /******/
	        // mode & 4: return value when already ns object

	        /******/
	        // mode & 8|1: behave like require

	        /******/


	        __webpack_require__.t = function (value, mode) {
	          /******/
	          if (mode & 1) value = __webpack_require__(value);
	          /******/

	          if (mode & 8) return value;
	          /******/

	          if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
	          /******/

	          var ns = Object.create(null);
	          /******/

	          __webpack_require__.r(ns);
	          /******/


	          Object.defineProperty(ns, 'default', {
	            enumerable: true,
	            value: value
	          });
	          /******/

	          if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {
	            return value[key];
	          }.bind(null, key));
	          /******/

	          return ns;
	          /******/
	        };
	        /******/

	        /******/
	        // getDefaultExport function for compatibility with non-harmony modules

	        /******/


	        __webpack_require__.n = function (module) {
	          /******/
	          var getter = module && module.__esModule ?
	          /******/
	          function getDefault() {
	            return module['default'];
	          } :
	          /******/
	          function getModuleExports() {
	            return module;
	          };
	          /******/

	          __webpack_require__.d(getter, 'a', getter);
	          /******/


	          return getter;
	          /******/
	        };
	        /******/

	        /******/
	        // Object.prototype.hasOwnProperty.call

	        /******/


	        __webpack_require__.o = function (object, property) {
	          return Object.prototype.hasOwnProperty.call(object, property);
	        };
	        /******/

	        /******/
	        // __webpack_public_path__

	        /******/


	        __webpack_require__.p = "";
	        /******/

	        /******/

	        /******/
	        // Load entry module and return exports

	        /******/

	        return __webpack_require__(__webpack_require__.s = "fb15");
	        /******/
	      }(
	      /************************************************************************/

	      /******/
	      {
	        /***/
	        "01f9":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var LIBRARY = __webpack_require__("2d00");

	          var $export = __webpack_require__("5ca1");

	          var redefine = __webpack_require__("2aba");

	          var hide = __webpack_require__("32e9");

	          var Iterators = __webpack_require__("84f2");

	          var $iterCreate = __webpack_require__("41a0");

	          var setToStringTag = __webpack_require__("7f20");

	          var getPrototypeOf = __webpack_require__("38fd");

	          var ITERATOR = __webpack_require__("2b4c")('iterator');

	          var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

	          var FF_ITERATOR = '@@iterator';
	          var KEYS = 'keys';
	          var VALUES = 'values';

	          var returnThis = function () {
	            return this;
	          };

	          module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	            $iterCreate(Constructor, NAME, next);

	            var getMethod = function (kind) {
	              if (!BUGGY && kind in proto) return proto[kind];

	              switch (kind) {
	                case KEYS:
	                  return function keys() {
	                    return new Constructor(this, kind);
	                  };

	                case VALUES:
	                  return function values() {
	                    return new Constructor(this, kind);
	                  };
	              }

	              return function entries() {
	                return new Constructor(this, kind);
	              };
	            };

	            var TAG = NAME + ' Iterator';
	            var DEF_VALUES = DEFAULT == VALUES;
	            var VALUES_BUG = false;
	            var proto = Base.prototype;
	            var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	            var $default = $native || getMethod(DEFAULT);
	            var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	            var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	            var methods, key, IteratorPrototype; // Fix native

	            if ($anyNative) {
	              IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

	              if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	                // Set @@toStringTag to native iterators
	                setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

	                if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
	              }
	            } // fix Array#{values, @@iterator}.name in V8 / FF


	            if (DEF_VALUES && $native && $native.name !== VALUES) {
	              VALUES_BUG = true;

	              $default = function values() {
	                return $native.call(this);
	              };
	            } // Define iterator


	            if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	              hide(proto, ITERATOR, $default);
	            } // Plug for library


	            Iterators[NAME] = $default;
	            Iterators[TAG] = returnThis;

	            if (DEFAULT) {
	              methods = {
	                values: DEF_VALUES ? $default : getMethod(VALUES),
	                keys: IS_SET ? $default : getMethod(KEYS),
	                entries: $entries
	              };
	              if (FORCED) for (key in methods) {
	                if (!(key in proto)) redefine(proto, key, methods[key]);
	              } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	            }

	            return methods;
	          };
	          /***/

	        },

	        /***/
	        "02f4":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var toInteger = __webpack_require__("4588");

	          var defined = __webpack_require__("be13"); // true  -> String#at
	          // false -> String#codePointAt


	          module.exports = function (TO_STRING) {
	            return function (that, pos) {
	              var s = String(defined(that));
	              var i = toInteger(pos);
	              var l = s.length;
	              var a, b;
	              if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	              a = s.charCodeAt(i);
	              return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	            };
	          };
	          /***/

	        },

	        /***/
	        "0390":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var at = __webpack_require__("02f4")(true); // `AdvanceStringIndex` abstract operation
	          // https://tc39.github.io/ecma262/#sec-advancestringindex


	          module.exports = function (S, index, unicode) {
	            return index + (unicode ? at(S, index).length : 1);
	          };
	          /***/

	        },

	        /***/
	        "0bfb":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var anObject = __webpack_require__("cb7c");

	          module.exports = function () {
	            var that = anObject(this);
	            var result = '';
	            if (that.global) result += 'g';
	            if (that.ignoreCase) result += 'i';
	            if (that.multiline) result += 'm';
	            if (that.unicode) result += 'u';
	            if (that.sticky) result += 'y';
	            return result;
	          };
	          /***/

	        },

	        /***/
	        "0d58":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // 19.1.2.14 / 15.2.3.14 Object.keys(O)
	          var $keys = __webpack_require__("ce10");

	          var enumBugKeys = __webpack_require__("e11e");

	          module.exports = Object.keys || function keys(O) {
	            return $keys(O, enumBugKeys);
	          };
	          /***/

	        },

	        /***/
	        "1495":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var dP = __webpack_require__("86cc");

	          var anObject = __webpack_require__("cb7c");

	          var getKeys = __webpack_require__("0d58");

	          module.exports = __webpack_require__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
	            anObject(O);
	            var keys = getKeys(Properties);
	            var length = keys.length;
	            var i = 0;
	            var P;

	            while (length > i) dP.f(O, P = keys[i++], Properties[P]);

	            return O;
	          };
	          /***/
	        },

	        /***/
	        "214f":
	        /***/
	        function (module, exports, __webpack_require__) {

	          __webpack_require__("b0c5");

	          var redefine = __webpack_require__("2aba");

	          var hide = __webpack_require__("32e9");

	          var fails = __webpack_require__("79e5");

	          var defined = __webpack_require__("be13");

	          var wks = __webpack_require__("2b4c");

	          var regexpExec = __webpack_require__("520a");

	          var SPECIES = wks('species');
	          var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	            // #replace needs built-in support for named groups.
	            // #match works fine because it just return the exec results, even if it has
	            // a "grops" property.
	            var re = /./;

	            re.exec = function () {
	              var result = [];
	              result.groups = {
	                a: '7'
	              };
	              return result;
	            };

	            return ''.replace(re, '$<a>') !== '7';
	          });

	          var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
	            // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	            var re = /(?:)/;
	            var originalExec = re.exec;

	            re.exec = function () {
	              return originalExec.apply(this, arguments);
	            };

	            var result = 'ab'.split(re);
	            return result.length === 2 && result[0] === 'a' && result[1] === 'b';
	          }();

	          module.exports = function (KEY, length, exec) {
	            var SYMBOL = wks(KEY);
	            var DELEGATES_TO_SYMBOL = !fails(function () {
	              // String methods call symbol-named RegEp methods
	              var O = {};

	              O[SYMBOL] = function () {
	                return 7;
	              };

	              return ''[KEY](O) != 7;
	            });
	            var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
	              // Symbol-named RegExp methods call .exec
	              var execCalled = false;
	              var re = /a/;

	              re.exec = function () {
	                execCalled = true;
	                return null;
	              };

	              if (KEY === 'split') {
	                // RegExp[@@split] doesn't call the regex's exec method, but first creates
	                // a new one. We need to return the patched regex when creating the new one.
	                re.constructor = {};

	                re.constructor[SPECIES] = function () {
	                  return re;
	                };
	              }

	              re[SYMBOL]('');
	              return !execCalled;
	            }) : undefined;

	            if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
	              var nativeRegExpMethod = /./[SYMBOL];
	              var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
	                if (regexp.exec === regexpExec) {
	                  if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	                    // The native String method already delegates to @@method (this
	                    // polyfilled function), leasing to infinite recursion.
	                    // We avoid it by directly calling the native @@method method.
	                    return {
	                      done: true,
	                      value: nativeRegExpMethod.call(regexp, str, arg2)
	                    };
	                  }

	                  return {
	                    done: true,
	                    value: nativeMethod.call(str, regexp, arg2)
	                  };
	                }

	                return {
	                  done: false
	                };
	              });
	              var strfn = fns[0];
	              var rxfn = fns[1];
	              redefine(String.prototype, KEY, strfn);
	              hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	              // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	              ? function (string, arg) {
	                return rxfn.call(string, this, arg);
	              } // 21.2.5.6 RegExp.prototype[@@match](string)
	              // 21.2.5.9 RegExp.prototype[@@search](string)
	              : function (string) {
	                return rxfn.call(string, this);
	              });
	            }
	          };
	          /***/

	        },

	        /***/
	        "230e":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var isObject = __webpack_require__("d3f4");

	          var document = __webpack_require__("7726").document; // typeof document.createElement is 'object' in old IE


	          var is = isObject(document) && isObject(document.createElement);

	          module.exports = function (it) {
	            return is ? document.createElement(it) : {};
	          };
	          /***/

	        },

	        /***/
	        "23c6":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // getting tag from 19.1.3.6 Object.prototype.toString()
	          var cof = __webpack_require__("2d95");

	          var TAG = __webpack_require__("2b4c")('toStringTag'); // ES3 wrong here


	          var ARG = cof(function () {
	            return arguments;
	          }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

	          var tryGet = function (it, key) {
	            try {
	              return it[key];
	            } catch (e) {
	              /* empty */
	            }
	          };

	          module.exports = function (it) {
	            var O, T, B;
	            return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
	            : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
	            : ARG ? cof(O) // ES3 arguments fallback
	            : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	          };
	          /***/

	        },

	        /***/
	        "2621":
	        /***/
	        function (module, exports) {
	          exports.f = Object.getOwnPropertySymbols;
	          /***/
	        },

	        /***/
	        "2aba":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var global = __webpack_require__("7726");

	          var hide = __webpack_require__("32e9");

	          var has = __webpack_require__("69a8");

	          var SRC = __webpack_require__("ca5a")('src');

	          var $toString = __webpack_require__("fa5b");

	          var TO_STRING = 'toString';
	          var TPL = ('' + $toString).split(TO_STRING);

	          __webpack_require__("8378").inspectSource = function (it) {
	            return $toString.call(it);
	          };

	          (module.exports = function (O, key, val, safe) {
	            var isFunction = typeof val == 'function';
	            if (isFunction) has(val, 'name') || hide(val, 'name', key);
	            if (O[key] === val) return;
	            if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

	            if (O === global) {
	              O[key] = val;
	            } else if (!safe) {
	              delete O[key];
	              hide(O, key, val);
	            } else if (O[key]) {
	              O[key] = val;
	            } else {
	              hide(O, key, val);
	            } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

	          })(Function.prototype, TO_STRING, function toString() {
	            return typeof this == 'function' && this[SRC] || $toString.call(this);
	          });
	          /***/
	        },

	        /***/
	        "2aeb":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	          var anObject = __webpack_require__("cb7c");

	          var dPs = __webpack_require__("1495");

	          var enumBugKeys = __webpack_require__("e11e");

	          var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

	          var Empty = function () {
	            /* empty */
	          };

	          var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

	          var createDict = function () {
	            // Thrash, waste and sodomy: IE GC bug
	            var iframe = __webpack_require__("230e")('iframe');

	            var i = enumBugKeys.length;
	            var lt = '<';
	            var gt = '>';
	            var iframeDocument;
	            iframe.style.display = 'none';

	            __webpack_require__("fab2").appendChild(iframe);

	            iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	            // createDict = iframe.contentWindow.Object;
	            // html.removeChild(iframe);

	            iframeDocument = iframe.contentWindow.document;
	            iframeDocument.open();
	            iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	            iframeDocument.close();
	            createDict = iframeDocument.F;

	            while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];

	            return createDict();
	          };

	          module.exports = Object.create || function create(O, Properties) {
	            var result;

	            if (O !== null) {
	              Empty[PROTOTYPE] = anObject(O);
	              result = new Empty();
	              Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

	              result[IE_PROTO] = O;
	            } else result = createDict();

	            return Properties === undefined ? result : dPs(result, Properties);
	          };
	          /***/

	        },

	        /***/
	        "2b4c":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var store = __webpack_require__("5537")('wks');

	          var uid = __webpack_require__("ca5a");

	          var Symbol = __webpack_require__("7726").Symbol;

	          var USE_SYMBOL = typeof Symbol == 'function';

	          var $exports = module.exports = function (name) {
	            return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	          };

	          $exports.store = store;
	          /***/
	        },

	        /***/
	        "2d00":
	        /***/
	        function (module, exports) {
	          module.exports = false;
	          /***/
	        },

	        /***/
	        "2d95":
	        /***/
	        function (module, exports) {
	          var toString = {}.toString;

	          module.exports = function (it) {
	            return toString.call(it).slice(8, -1);
	          };
	          /***/

	        },

	        /***/
	        "2fdb":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var $export = __webpack_require__("5ca1");

	          var context = __webpack_require__("d2c8");

	          var INCLUDES = 'includes';
	          $export($export.P + $export.F * __webpack_require__("5147")(INCLUDES), 'String', {
	            includes: function includes(searchString
	            /* , position = 0 */
	            ) {
	              return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	            }
	          });
	          /***/
	        },

	        /***/
	        "32e9":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var dP = __webpack_require__("86cc");

	          var createDesc = __webpack_require__("4630");

	          module.exports = __webpack_require__("9e1e") ? function (object, key, value) {
	            return dP.f(object, key, createDesc(1, value));
	          } : function (object, key, value) {
	            object[key] = value;
	            return object;
	          };
	          /***/
	        },

	        /***/
	        "38fd":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	          var has = __webpack_require__("69a8");

	          var toObject = __webpack_require__("4bf8");

	          var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

	          var ObjectProto = Object.prototype;

	          module.exports = Object.getPrototypeOf || function (O) {
	            O = toObject(O);
	            if (has(O, IE_PROTO)) return O[IE_PROTO];

	            if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	              return O.constructor.prototype;
	            }

	            return O instanceof Object ? ObjectProto : null;
	          };
	          /***/

	        },

	        /***/
	        "41a0":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var create = __webpack_require__("2aeb");

	          var descriptor = __webpack_require__("4630");

	          var setToStringTag = __webpack_require__("7f20");

	          var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

	          __webpack_require__("32e9")(IteratorPrototype, __webpack_require__("2b4c")('iterator'), function () {
	            return this;
	          });

	          module.exports = function (Constructor, NAME, next) {
	            Constructor.prototype = create(IteratorPrototype, {
	              next: descriptor(1, next)
	            });
	            setToStringTag(Constructor, NAME + ' Iterator');
	          };
	          /***/

	        },

	        /***/
	        "456d":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // 19.1.2.14 Object.keys(O)
	          var toObject = __webpack_require__("4bf8");

	          var $keys = __webpack_require__("0d58");

	          __webpack_require__("5eda")('keys', function () {
	            return function keys(it) {
	              return $keys(toObject(it));
	            };
	          });
	          /***/

	        },

	        /***/
	        "4588":
	        /***/
	        function (module, exports) {
	          // 7.1.4 ToInteger
	          var ceil = Math.ceil;
	          var floor = Math.floor;

	          module.exports = function (it) {
	            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	          };
	          /***/

	        },

	        /***/
	        "4630":
	        /***/
	        function (module, exports) {
	          module.exports = function (bitmap, value) {
	            return {
	              enumerable: !(bitmap & 1),
	              configurable: !(bitmap & 2),
	              writable: !(bitmap & 4),
	              value: value
	            };
	          };
	          /***/

	        },

	        /***/
	        "4bf8":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // 7.1.13 ToObject(argument)
	          var defined = __webpack_require__("be13");

	          module.exports = function (it) {
	            return Object(defined(it));
	          };
	          /***/

	        },

	        /***/
	        "5147":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var MATCH = __webpack_require__("2b4c")('match');

	          module.exports = function (KEY) {
	            var re = /./;

	            try {
	              '/./'[KEY](re);
	            } catch (e) {
	              try {
	                re[MATCH] = false;
	                return !'/./'[KEY](re);
	              } catch (f) {
	                /* empty */
	              }
	            }

	            return true;
	          };
	          /***/

	        },

	        /***/
	        "520a":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var regexpFlags = __webpack_require__("0bfb");

	          var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
	          // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	          // which loads this file before patching the method.

	          var nativeReplace = String.prototype.replace;
	          var patchedExec = nativeExec;
	          var LAST_INDEX = 'lastIndex';

	          var UPDATES_LAST_INDEX_WRONG = function () {
	            var re1 = /a/,
	                re2 = /b*/g;
	            nativeExec.call(re1, 'a');
	            nativeExec.call(re2, 'a');
	            return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
	          }(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


	          var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
	          var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

	          if (PATCH) {
	            patchedExec = function exec(str) {
	              var re = this;
	              var lastIndex, reCopy, match, i;

	              if (NPCG_INCLUDED) {
	                reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
	              }

	              if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
	              match = nativeExec.call(re, str);

	              if (UPDATES_LAST_INDEX_WRONG && match) {
	                re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
	              }

	              if (NPCG_INCLUDED && match && match.length > 1) {
	                // Fix browsers whose `exec` methods don't consistently return `undefined`
	                // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	                // eslint-disable-next-line no-loop-func
	                nativeReplace.call(match[0], reCopy, function () {
	                  for (i = 1; i < arguments.length - 2; i++) {
	                    if (arguments[i] === undefined) match[i] = undefined;
	                  }
	                });
	              }

	              return match;
	            };
	          }

	          module.exports = patchedExec;
	          /***/
	        },

	        /***/
	        "52a7":
	        /***/
	        function (module, exports) {
	          exports.f = {}.propertyIsEnumerable;
	          /***/
	        },

	        /***/
	        "5537":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var core = __webpack_require__("8378");

	          var global = __webpack_require__("7726");

	          var SHARED = '__core-js_shared__';
	          var store = global[SHARED] || (global[SHARED] = {});
	          (module.exports = function (key, value) {
	            return store[key] || (store[key] = value !== undefined ? value : {});
	          })('versions', []).push({
	            version: core.version,
	            mode: __webpack_require__("2d00") ? 'pure' : 'global',
	            copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
	          });
	          /***/
	        },

	        /***/
	        "5ca1":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var global = __webpack_require__("7726");

	          var core = __webpack_require__("8378");

	          var hide = __webpack_require__("32e9");

	          var redefine = __webpack_require__("2aba");

	          var ctx = __webpack_require__("9b43");

	          var PROTOTYPE = 'prototype';

	          var $export = function (type, name, source) {
	            var IS_FORCED = type & $export.F;
	            var IS_GLOBAL = type & $export.G;
	            var IS_STATIC = type & $export.S;
	            var IS_PROTO = type & $export.P;
	            var IS_BIND = type & $export.B;
	            var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
	            var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
	            var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	            var key, own, out, exp;
	            if (IS_GLOBAL) source = name;

	            for (key in source) {
	              // contains in native
	              own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

	              out = (own ? target : source)[key]; // bind timers to global for call from export context

	              exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

	              if (target) redefine(target, key, out, type & $export.U); // export

	              if (exports[key] != out) hide(exports, key, exp);
	              if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	            }
	          };

	          global.core = core; // type bitmap

	          $export.F = 1; // forced

	          $export.G = 2; // global

	          $export.S = 4; // static

	          $export.P = 8; // proto

	          $export.B = 16; // bind

	          $export.W = 32; // wrap

	          $export.U = 64; // safe

	          $export.R = 128; // real proto method for `library`

	          module.exports = $export;
	          /***/
	        },

	        /***/
	        "5eda":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // most Object methods by ES6 should accept primitives
	          var $export = __webpack_require__("5ca1");

	          var core = __webpack_require__("8378");

	          var fails = __webpack_require__("79e5");

	          module.exports = function (KEY, exec) {
	            var fn = (core.Object || {})[KEY] || Object[KEY];
	            var exp = {};
	            exp[KEY] = exec(fn);
	            $export($export.S + $export.F * fails(function () {
	              fn(1);
	            }), 'Object', exp);
	          };
	          /***/

	        },

	        /***/
	        "5f1b":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var classof = __webpack_require__("23c6");

	          var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
	          // https://tc39.github.io/ecma262/#sec-regexpexec

	          module.exports = function (R, S) {
	            var exec = R.exec;

	            if (typeof exec === 'function') {
	              var result = exec.call(R, S);

	              if (typeof result !== 'object') {
	                throw new TypeError('RegExp exec method returned something other than an Object or null');
	              }

	              return result;
	            }

	            if (classof(R) !== 'RegExp') {
	              throw new TypeError('RegExp#exec called on incompatible receiver');
	            }

	            return builtinExec.call(R, S);
	          };
	          /***/

	        },

	        /***/
	        "613b":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var shared = __webpack_require__("5537")('keys');

	          var uid = __webpack_require__("ca5a");

	          module.exports = function (key) {
	            return shared[key] || (shared[key] = uid(key));
	          };
	          /***/

	        },

	        /***/
	        "626a":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // fallback for non-array-like ES3 and non-enumerable old V8 strings
	          var cof = __webpack_require__("2d95"); // eslint-disable-next-line no-prototype-builtins


	          module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	            return cof(it) == 'String' ? it.split('') : Object(it);
	          };
	          /***/
	        },

	        /***/
	        "6762":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var $export = __webpack_require__("5ca1");

	          var $includes = __webpack_require__("c366")(true);

	          $export($export.P, 'Array', {
	            includes: function includes(el
	            /* , fromIndex = 0 */
	            ) {
	              return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	            }
	          });

	          __webpack_require__("9c6c")('includes');
	          /***/

	        },

	        /***/
	        "6821":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // to indexed object, toObject with fallback for non-array-like ES3 strings
	          var IObject = __webpack_require__("626a");

	          var defined = __webpack_require__("be13");

	          module.exports = function (it) {
	            return IObject(defined(it));
	          };
	          /***/

	        },

	        /***/
	        "69a8":
	        /***/
	        function (module, exports) {
	          var hasOwnProperty = {}.hasOwnProperty;

	          module.exports = function (it, key) {
	            return hasOwnProperty.call(it, key);
	          };
	          /***/

	        },

	        /***/
	        "6a99":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // 7.1.1 ToPrimitive(input [, PreferredType])
	          var isObject = __webpack_require__("d3f4"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
	          // and the second argument - flag - preferred type is a string


	          module.exports = function (it, S) {
	            if (!isObject(it)) return it;
	            var fn, val;
	            if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	            if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	            if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	            throw TypeError("Can't convert object to primitive value");
	          };
	          /***/

	        },

	        /***/
	        "7333":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var getKeys = __webpack_require__("0d58");

	          var gOPS = __webpack_require__("2621");

	          var pIE = __webpack_require__("52a7");

	          var toObject = __webpack_require__("4bf8");

	          var IObject = __webpack_require__("626a");

	          var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

	          module.exports = !$assign || __webpack_require__("79e5")(function () {
	            var A = {};
	            var B = {}; // eslint-disable-next-line no-undef

	            var S = Symbol();
	            var K = 'abcdefghijklmnopqrst';
	            A[S] = 7;
	            K.split('').forEach(function (k) {
	              B[k] = k;
	            });
	            return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	          }) ? function assign(target, source) {
	            // eslint-disable-line no-unused-vars
	            var T = toObject(target);
	            var aLen = arguments.length;
	            var index = 1;
	            var getSymbols = gOPS.f;
	            var isEnum = pIE.f;

	            while (aLen > index) {
	              var S = IObject(arguments[index++]);
	              var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	              var length = keys.length;
	              var j = 0;
	              var key;

	              while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	            }

	            return T;
	          } : $assign;
	          /***/
	        },

	        /***/
	        "7726":
	        /***/
	        function (module, exports) {
	          // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	          var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
	          : Function('return this')();
	          if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

	          /***/
	        },

	        /***/
	        "77f1":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var toInteger = __webpack_require__("4588");

	          var max = Math.max;
	          var min = Math.min;

	          module.exports = function (index, length) {
	            index = toInteger(index);
	            return index < 0 ? max(index + length, 0) : min(index, length);
	          };
	          /***/

	        },

	        /***/
	        "79e5":
	        /***/
	        function (module, exports) {
	          module.exports = function (exec) {
	            try {
	              return !!exec();
	            } catch (e) {
	              return true;
	            }
	          };
	          /***/

	        },

	        /***/
	        "7f20":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var def = __webpack_require__("86cc").f;

	          var has = __webpack_require__("69a8");

	          var TAG = __webpack_require__("2b4c")('toStringTag');

	          module.exports = function (it, tag, stat) {
	            if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
	              configurable: true,
	              value: tag
	            });
	          };
	          /***/

	        },

	        /***/
	        "8378":
	        /***/
	        function (module, exports) {
	          var core = module.exports = {
	            version: '2.6.5'
	          };
	          if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

	          /***/
	        },

	        /***/
	        "84f2":
	        /***/
	        function (module, exports) {
	          module.exports = {};
	          /***/
	        },

	        /***/
	        "86cc":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var anObject = __webpack_require__("cb7c");

	          var IE8_DOM_DEFINE = __webpack_require__("c69a");

	          var toPrimitive = __webpack_require__("6a99");

	          var dP = Object.defineProperty;
	          exports.f = __webpack_require__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	            anObject(O);
	            P = toPrimitive(P, true);
	            anObject(Attributes);
	            if (IE8_DOM_DEFINE) try {
	              return dP(O, P, Attributes);
	            } catch (e) {
	              /* empty */
	            }
	            if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	            if ('value' in Attributes) O[P] = Attributes.value;
	            return O;
	          };
	          /***/
	        },

	        /***/
	        "9b43":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // optional / simple context binding
	          var aFunction = __webpack_require__("d8e8");

	          module.exports = function (fn, that, length) {
	            aFunction(fn);
	            if (that === undefined) return fn;

	            switch (length) {
	              case 1:
	                return function (a) {
	                  return fn.call(that, a);
	                };

	              case 2:
	                return function (a, b) {
	                  return fn.call(that, a, b);
	                };

	              case 3:
	                return function (a, b, c) {
	                  return fn.call(that, a, b, c);
	                };
	            }

	            return function ()
	            /* ...args */
	            {
	              return fn.apply(that, arguments);
	            };
	          };
	          /***/

	        },

	        /***/
	        "9c6c":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // 22.1.3.31 Array.prototype[@@unscopables]
	          var UNSCOPABLES = __webpack_require__("2b4c")('unscopables');

	          var ArrayProto = Array.prototype;
	          if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("32e9")(ArrayProto, UNSCOPABLES, {});

	          module.exports = function (key) {
	            ArrayProto[UNSCOPABLES][key] = true;
	          };
	          /***/

	        },

	        /***/
	        "9def":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // 7.1.15 ToLength
	          var toInteger = __webpack_require__("4588");

	          var min = Math.min;

	          module.exports = function (it) {
	            return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	          };
	          /***/

	        },

	        /***/
	        "9e1e":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // Thank's IE8 for his funny defineProperty
	          module.exports = !__webpack_require__("79e5")(function () {
	            return Object.defineProperty({}, 'a', {
	              get: function () {
	                return 7;
	              }
	            }).a != 7;
	          });
	          /***/
	        },

	        /***/
	        "a352":
	        /***/
	        function (module, exports) {
	          module.exports = __WEBPACK_EXTERNAL_MODULE_a352__;
	          /***/
	        },

	        /***/
	        "a481":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var anObject = __webpack_require__("cb7c");

	          var toObject = __webpack_require__("4bf8");

	          var toLength = __webpack_require__("9def");

	          var toInteger = __webpack_require__("4588");

	          var advanceStringIndex = __webpack_require__("0390");

	          var regExpExec = __webpack_require__("5f1b");

	          var max = Math.max;
	          var min = Math.min;
	          var floor = Math.floor;
	          var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
	          var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

	          var maybeToString = function (it) {
	            return it === undefined ? it : String(it);
	          }; // @@replace logic


	          __webpack_require__("214f")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
	            return [// `String.prototype.replace` method
	            // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	            function replace(searchValue, replaceValue) {
	              var O = defined(this);
	              var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	              return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
	            }, // `RegExp.prototype[@@replace]` method
	            // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	            function (regexp, replaceValue) {
	              var res = maybeCallNative($replace, regexp, this, replaceValue);
	              if (res.done) return res.value;
	              var rx = anObject(regexp);
	              var S = String(this);
	              var functionalReplace = typeof replaceValue === 'function';
	              if (!functionalReplace) replaceValue = String(replaceValue);
	              var global = rx.global;

	              if (global) {
	                var fullUnicode = rx.unicode;
	                rx.lastIndex = 0;
	              }

	              var results = [];

	              while (true) {
	                var result = regExpExec(rx, S);
	                if (result === null) break;
	                results.push(result);
	                if (!global) break;
	                var matchStr = String(result[0]);
	                if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	              }

	              var accumulatedResult = '';
	              var nextSourcePosition = 0;

	              for (var i = 0; i < results.length; i++) {
	                result = results[i];
	                var matched = String(result[0]);
	                var position = max(min(toInteger(result.index), S.length), 0);
	                var captures = []; // NOTE: This is equivalent to
	                //   captures = result.slice(1).map(maybeToString)
	                // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	                // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	                // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

	                for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

	                var namedCaptures = result.groups;

	                if (functionalReplace) {
	                  var replacerArgs = [matched].concat(captures, position, S);
	                  if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
	                  var replacement = String(replaceValue.apply(undefined, replacerArgs));
	                } else {
	                  replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	                }

	                if (position >= nextSourcePosition) {
	                  accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	                  nextSourcePosition = position + matched.length;
	                }
	              }

	              return accumulatedResult + S.slice(nextSourcePosition);
	            }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

	            function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	              var tailPos = position + matched.length;
	              var m = captures.length;
	              var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

	              if (namedCaptures !== undefined) {
	                namedCaptures = toObject(namedCaptures);
	                symbols = SUBSTITUTION_SYMBOLS;
	              }

	              return $replace.call(replacement, symbols, function (match, ch) {
	                var capture;

	                switch (ch.charAt(0)) {
	                  case '$':
	                    return '$';

	                  case '&':
	                    return matched;

	                  case '`':
	                    return str.slice(0, position);

	                  case "'":
	                    return str.slice(tailPos);

	                  case '<':
	                    capture = namedCaptures[ch.slice(1, -1)];
	                    break;

	                  default:
	                    // \d\d?
	                    var n = +ch;
	                    if (n === 0) return match;

	                    if (n > m) {
	                      var f = floor(n / 10);
	                      if (f === 0) return match;
	                      if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
	                      return match;
	                    }

	                    capture = captures[n - 1];
	                }

	                return capture === undefined ? '' : capture;
	              });
	            }
	          });
	          /***/

	        },

	        /***/
	        "aae3":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // 7.2.8 IsRegExp(argument)
	          var isObject = __webpack_require__("d3f4");

	          var cof = __webpack_require__("2d95");

	          var MATCH = __webpack_require__("2b4c")('match');

	          module.exports = function (it) {
	            var isRegExp;
	            return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	          };
	          /***/

	        },

	        /***/
	        "ac6a":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var $iterators = __webpack_require__("cadf");

	          var getKeys = __webpack_require__("0d58");

	          var redefine = __webpack_require__("2aba");

	          var global = __webpack_require__("7726");

	          var hide = __webpack_require__("32e9");

	          var Iterators = __webpack_require__("84f2");

	          var wks = __webpack_require__("2b4c");

	          var ITERATOR = wks('iterator');
	          var TO_STRING_TAG = wks('toStringTag');
	          var ArrayValues = Iterators.Array;
	          var DOMIterables = {
	            CSSRuleList: true,
	            // TODO: Not spec compliant, should be false.
	            CSSStyleDeclaration: false,
	            CSSValueList: false,
	            ClientRectList: false,
	            DOMRectList: false,
	            DOMStringList: false,
	            DOMTokenList: true,
	            DataTransferItemList: false,
	            FileList: false,
	            HTMLAllCollection: false,
	            HTMLCollection: false,
	            HTMLFormElement: false,
	            HTMLSelectElement: false,
	            MediaList: true,
	            // TODO: Not spec compliant, should be false.
	            MimeTypeArray: false,
	            NamedNodeMap: false,
	            NodeList: true,
	            PaintRequestList: false,
	            Plugin: false,
	            PluginArray: false,
	            SVGLengthList: false,
	            SVGNumberList: false,
	            SVGPathSegList: false,
	            SVGPointList: false,
	            SVGStringList: false,
	            SVGTransformList: false,
	            SourceBufferList: false,
	            StyleSheetList: true,
	            // TODO: Not spec compliant, should be false.
	            TextTrackCueList: false,
	            TextTrackList: false,
	            TouchList: false
	          };

	          for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
	            var NAME = collections[i];
	            var explicit = DOMIterables[NAME];
	            var Collection = global[NAME];
	            var proto = Collection && Collection.prototype;
	            var key;

	            if (proto) {
	              if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
	              if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	              Iterators[NAME] = ArrayValues;
	              if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
	            }
	          }
	          /***/

	        },

	        /***/
	        "b0c5":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var regexpExec = __webpack_require__("520a");

	          __webpack_require__("5ca1")({
	            target: 'RegExp',
	            proto: true,
	            forced: regexpExec !== /./.exec
	          }, {
	            exec: regexpExec
	          });
	          /***/

	        },

	        /***/
	        "be13":
	        /***/
	        function (module, exports) {
	          // 7.2.1 RequireObjectCoercible(argument)
	          module.exports = function (it) {
	            if (it == undefined) throw TypeError("Can't call method on  " + it);
	            return it;
	          };
	          /***/

	        },

	        /***/
	        "c366":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // false -> Array#indexOf
	          // true  -> Array#includes
	          var toIObject = __webpack_require__("6821");

	          var toLength = __webpack_require__("9def");

	          var toAbsoluteIndex = __webpack_require__("77f1");

	          module.exports = function (IS_INCLUDES) {
	            return function ($this, el, fromIndex) {
	              var O = toIObject($this);
	              var length = toLength(O.length);
	              var index = toAbsoluteIndex(fromIndex, length);
	              var value; // Array#includes uses SameValueZero equality algorithm
	              // eslint-disable-next-line no-self-compare

	              if (IS_INCLUDES && el != el) while (length > index) {
	                value = O[index++]; // eslint-disable-next-line no-self-compare

	                if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
	              } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
	                if (O[index] === el) return IS_INCLUDES || index || 0;
	              }
	              return !IS_INCLUDES && -1;
	            };
	          };
	          /***/

	        },

	        /***/
	        "c649":
	        /***/
	        function (module, __webpack_exports__, __webpack_require__) {
	          /* WEBPACK VAR INJECTION */

	          (function (global) {
	            /* harmony export (binding) */
	            __webpack_require__.d(__webpack_exports__, "c", function () {
	              return insertNodeAt;
	            });
	            /* harmony export (binding) */


	            __webpack_require__.d(__webpack_exports__, "a", function () {
	              return camelize;
	            });
	            /* harmony export (binding) */


	            __webpack_require__.d(__webpack_exports__, "b", function () {
	              return console;
	            });
	            /* harmony export (binding) */


	            __webpack_require__.d(__webpack_exports__, "d", function () {
	              return removeNode;
	            });
	            /* harmony import */


	            var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a481");

	            function getConsole() {
	              if (typeof window !== "undefined") {
	                return window.console;
	              }

	              return global.console;
	            }

	            var console = getConsole();

	            function cached(fn) {
	              var cache = Object.create(null);
	              return function cachedFn(str) {
	                var hit = cache[str];
	                return hit || (cache[str] = fn(str));
	              };
	            }

	            var regex = /-(\w)/g;
	            var camelize = cached(function (str) {
	              return str.replace(regex, function (_, c) {
	                return c ? c.toUpperCase() : "";
	              });
	            });

	            function removeNode(node) {
	              if (node.parentElement !== null) {
	                node.parentElement.removeChild(node);
	              }
	            }

	            function insertNodeAt(fatherNode, node, position) {
	              var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
	              fatherNode.insertBefore(node, refNode);
	            }
	            /* WEBPACK VAR INJECTION */

	          }).call(this, __webpack_require__("c8ba"));
	          /***/
	        },

	        /***/
	        "c69a":
	        /***/
	        function (module, exports, __webpack_require__) {
	          module.exports = !__webpack_require__("9e1e") && !__webpack_require__("79e5")(function () {
	            return Object.defineProperty(__webpack_require__("230e")('div'), 'a', {
	              get: function () {
	                return 7;
	              }
	            }).a != 7;
	          });
	          /***/
	        },

	        /***/
	        "c8ba":
	        /***/
	        function (module, exports) {
	          var g; // This works in non-strict mode

	          g = function () {
	            return this;
	          }();

	          try {
	            // This works if eval is allowed (see CSP)
	            g = g || new Function("return this")();
	          } catch (e) {
	            // This works if the window reference is available
	            if (typeof window === "object") g = window;
	          } // g can still be undefined, but nothing to do about it...
	          // We return undefined, instead of nothing here, so it's
	          // easier to handle this case. if(!global) { ...}


	          module.exports = g;
	          /***/
	        },

	        /***/
	        "ca5a":
	        /***/
	        function (module, exports) {
	          var id = 0;
	          var px = Math.random();

	          module.exports = function (key) {
	            return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	          };
	          /***/

	        },

	        /***/
	        "cadf":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var addToUnscopables = __webpack_require__("9c6c");

	          var step = __webpack_require__("d53b");

	          var Iterators = __webpack_require__("84f2");

	          var toIObject = __webpack_require__("6821"); // 22.1.3.4 Array.prototype.entries()
	          // 22.1.3.13 Array.prototype.keys()
	          // 22.1.3.29 Array.prototype.values()
	          // 22.1.3.30 Array.prototype[@@iterator]()


	          module.exports = __webpack_require__("01f9")(Array, 'Array', function (iterated, kind) {
	            this._t = toIObject(iterated); // target

	            this._i = 0; // next index

	            this._k = kind; // kind
	            // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	          }, function () {
	            var O = this._t;
	            var kind = this._k;
	            var index = this._i++;

	            if (!O || index >= O.length) {
	              this._t = undefined;
	              return step(1);
	            }

	            if (kind == 'keys') return step(0, index);
	            if (kind == 'values') return step(0, O[index]);
	            return step(0, [index, O[index]]);
	          }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

	          Iterators.Arguments = Iterators.Array;
	          addToUnscopables('keys');
	          addToUnscopables('values');
	          addToUnscopables('entries');
	          /***/
	        },

	        /***/
	        "cb7c":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var isObject = __webpack_require__("d3f4");

	          module.exports = function (it) {
	            if (!isObject(it)) throw TypeError(it + ' is not an object!');
	            return it;
	          };
	          /***/

	        },

	        /***/
	        "ce10":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var has = __webpack_require__("69a8");

	          var toIObject = __webpack_require__("6821");

	          var arrayIndexOf = __webpack_require__("c366")(false);

	          var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

	          module.exports = function (object, names) {
	            var O = toIObject(object);
	            var i = 0;
	            var result = [];
	            var key;

	            for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys


	            while (names.length > i) if (has(O, key = names[i++])) {
	              ~arrayIndexOf(result, key) || result.push(key);
	            }

	            return result;
	          };
	          /***/

	        },

	        /***/
	        "d2c8":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // helper for String#{startsWith, endsWith, includes}
	          var isRegExp = __webpack_require__("aae3");

	          var defined = __webpack_require__("be13");

	          module.exports = function (that, searchString, NAME) {
	            if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	            return String(defined(that));
	          };
	          /***/

	        },

	        /***/
	        "d3f4":
	        /***/
	        function (module, exports) {
	          module.exports = function (it) {
	            return typeof it === 'object' ? it !== null : typeof it === 'function';
	          };
	          /***/

	        },

	        /***/
	        "d53b":
	        /***/
	        function (module, exports) {
	          module.exports = function (done, value) {
	            return {
	              value: value,
	              done: !!done
	            };
	          };
	          /***/

	        },

	        /***/
	        "d8e8":
	        /***/
	        function (module, exports) {
	          module.exports = function (it) {
	            if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	            return it;
	          };
	          /***/

	        },

	        /***/
	        "e11e":
	        /***/
	        function (module, exports) {
	          // IE 8- don't enum bug keys
	          module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
	          /***/
	        },

	        /***/
	        "f559":
	        /***/
	        function (module, exports, __webpack_require__) {

	          var $export = __webpack_require__("5ca1");

	          var toLength = __webpack_require__("9def");

	          var context = __webpack_require__("d2c8");

	          var STARTS_WITH = 'startsWith';
	          var $startsWith = ''[STARTS_WITH];
	          $export($export.P + $export.F * __webpack_require__("5147")(STARTS_WITH), 'String', {
	            startsWith: function startsWith(searchString
	            /* , position = 0 */
	            ) {
	              var that = context(this, searchString, STARTS_WITH);
	              var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	              var search = String(searchString);
	              return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
	            }
	          });
	          /***/
	        },

	        /***/
	        "f6fd":
	        /***/
	        function (module, exports) {
	          // document.currentScript polyfill by Adam Miller
	          // MIT license
	          (function (document) {
	            var currentScript = "currentScript",
	                scripts = document.getElementsByTagName('script'); // Live NodeList collection
	            // If browser needs currentScript polyfill, add get currentScript() to the document object

	            if (!(currentScript in document)) {
	              Object.defineProperty(document, currentScript, {
	                get: function () {
	                  // IE 6-10 supports script readyState
	                  // IE 10+ support stack trace
	                  try {
	                    throw new Error();
	                  } catch (err) {
	                    // Find the second match for the "at" string to get file src url from stack.
	                    // Specifically works with the format of stack traces in IE.
	                    var i,
	                        res = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(err.stack) || [false])[1]; // For all scripts on the page, if src matches or if ready state is interactive, return the script tag

	                    for (i in scripts) {
	                      if (scripts[i].src == res || scripts[i].readyState == "interactive") {
	                        return scripts[i];
	                      }
	                    } // If no match, return null


	                    return null;
	                  }
	                }
	              });
	            }
	          })(document);
	          /***/

	        },

	        /***/
	        "f751":
	        /***/
	        function (module, exports, __webpack_require__) {
	          // 19.1.3.1 Object.assign(target, source)
	          var $export = __webpack_require__("5ca1");

	          $export($export.S + $export.F, 'Object', {
	            assign: __webpack_require__("7333")
	          });
	          /***/
	        },

	        /***/
	        "fa5b":
	        /***/
	        function (module, exports, __webpack_require__) {
	          module.exports = __webpack_require__("5537")('native-function-to-string', Function.toString);
	          /***/
	        },

	        /***/
	        "fab2":
	        /***/
	        function (module, exports, __webpack_require__) {
	          var document = __webpack_require__("7726").document;

	          module.exports = document && document.documentElement;
	          /***/
	        },

	        /***/
	        "fb15":
	        /***/
	        function (module, __webpack_exports__, __webpack_require__) {

	          __webpack_require__.r(__webpack_exports__); // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
	          // This file is imported into lib/wc client bundles.


	          if (typeof window !== 'undefined') {
	            {
	              __webpack_require__("f6fd");
	            }

	            var setPublicPath_i;

	            if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
	              __webpack_require__.p = setPublicPath_i[1]; // eslint-disable-line
	            }
	          } // Indicate to webpack that this file can be concatenated

	          var es6_object_assign = __webpack_require__("f751"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js


	          var es6_string_starts_with = __webpack_require__("f559"); // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js


	          var web_dom_iterable = __webpack_require__("ac6a"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js


	          var es6_array_iterator = __webpack_require__("cadf"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.keys.js


	          var es6_object_keys = __webpack_require__("456d"); // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js


	          function _arrayWithHoles(arr) {
	            if (Array.isArray(arr)) return arr;
	          } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js


	          function _iterableToArrayLimit(arr, i) {
	            if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	            var _arr = [];
	            var _n = true;
	            var _d = false;
	            var _e = undefined;

	            try {
	              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	                _arr.push(_s.value);

	                if (i && _arr.length === i) break;
	              }
	            } catch (err) {
	              _d = true;
	              _e = err;
	            } finally {
	              try {
	                if (!_n && _i["return"] != null) _i["return"]();
	              } finally {
	                if (_d) throw _e;
	              }
	            }

	            return _arr;
	          } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js


	          function _arrayLikeToArray(arr, len) {
	            if (len == null || len > arr.length) len = arr.length;

	            for (var i = 0, arr2 = new Array(len); i < len; i++) {
	              arr2[i] = arr[i];
	            }

	            return arr2;
	          } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js


	          function _unsupportedIterableToArray(o, minLen) {
	            if (!o) return;
	            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	            var n = Object.prototype.toString.call(o).slice(8, -1);
	            if (n === "Object" && o.constructor) n = o.constructor.name;
	            if (n === "Map" || n === "Set") return Array.from(o);
	            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	          } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js


	          function _nonIterableRest() {
	            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	          } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js


	          function _slicedToArray(arr, i) {
	            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	          } // EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js


	          var es7_array_includes = __webpack_require__("6762"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js


	          var es6_string_includes = __webpack_require__("2fdb"); // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js


	          function _arrayWithoutHoles(arr) {
	            if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	          } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js


	          function _iterableToArray(iter) {
	            if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	          } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js


	          function _nonIterableSpread() {
	            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	          } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js


	          function _toConsumableArray(arr) {
	            return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	          } // EXTERNAL MODULE: external {"commonjs":"sortablejs","commonjs2":"sortablejs","amd":"sortablejs","root":"Sortable"}


	          var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");

	          var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_); // EXTERNAL MODULE: ./src/util/helper.js


	          var helper = __webpack_require__("c649"); // CONCATENATED MODULE: ./src/vuedraggable.js


	          function buildAttribute(object, propName, value) {
	            if (value === undefined) {
	              return object;
	            }

	            object = object || {};
	            object[propName] = value;
	            return object;
	          }

	          function computeVmIndex(vnodes, element) {
	            return vnodes.map(function (elt) {
	              return elt.elm;
	            }).indexOf(element);
	          }

	          function _computeIndexes(slots, children, isTransition, footerOffset) {
	            if (!slots) {
	              return [];
	            }

	            var elmFromNodes = slots.map(function (elt) {
	              return elt.elm;
	            });
	            var footerIndex = children.length - footerOffset;

	            var rawIndexes = _toConsumableArray(children).map(function (elt, idx) {
	              return idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt);
	            });

	            return isTransition ? rawIndexes.filter(function (ind) {
	              return ind !== -1;
	            }) : rawIndexes;
	          }

	          function emit(evtName, evtData) {
	            var _this = this;

	            this.$nextTick(function () {
	              return _this.$emit(evtName.toLowerCase(), evtData);
	            });
	          }

	          function delegateAndEmit(evtName) {
	            var _this2 = this;

	            return function (evtData) {
	              if (_this2.realList !== null) {
	                _this2["onDrag" + evtName](evtData);
	              }

	              emit.call(_this2, evtName, evtData);
	            };
	          }

	          function isTransitionName(name) {
	            return ["transition-group", "TransitionGroup"].includes(name);
	          }

	          function vuedraggable_isTransition(slots) {
	            if (!slots || slots.length !== 1) {
	              return false;
	            }

	            var _slots = _slicedToArray(slots, 1),
	                componentOptions = _slots[0].componentOptions;

	            if (!componentOptions) {
	              return false;
	            }

	            return isTransitionName(componentOptions.tag);
	          }

	          function getSlot(slot, scopedSlot, key) {
	            return slot[key] || (scopedSlot[key] ? scopedSlot[key]() : undefined);
	          }

	          function computeChildrenAndOffsets(children, slot, scopedSlot) {
	            var headerOffset = 0;
	            var footerOffset = 0;
	            var header = getSlot(slot, scopedSlot, "header");

	            if (header) {
	              headerOffset = header.length;
	              children = children ? [].concat(_toConsumableArray(header), _toConsumableArray(children)) : _toConsumableArray(header);
	            }

	            var footer = getSlot(slot, scopedSlot, "footer");

	            if (footer) {
	              footerOffset = footer.length;
	              children = children ? [].concat(_toConsumableArray(children), _toConsumableArray(footer)) : _toConsumableArray(footer);
	            }

	            return {
	              children: children,
	              headerOffset: headerOffset,
	              footerOffset: footerOffset
	            };
	          }

	          function getComponentAttributes($attrs, componentData) {
	            var attributes = null;

	            var update = function update(name, value) {
	              attributes = buildAttribute(attributes, name, value);
	            };

	            var attrs = Object.keys($attrs).filter(function (key) {
	              return key === "id" || key.startsWith("data-");
	            }).reduce(function (res, key) {
	              res[key] = $attrs[key];
	              return res;
	            }, {});
	            update("attrs", attrs);

	            if (!componentData) {
	              return attributes;
	            }

	            var on = componentData.on,
	                props = componentData.props,
	                componentDataAttrs = componentData.attrs;
	            update("on", on);
	            update("props", props);
	            Object.assign(attributes.attrs, componentDataAttrs);
	            return attributes;
	          }

	          var eventsListened = ["Start", "Add", "Remove", "Update", "End"];
	          var eventsToEmit = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
	          var readonlyProperties = ["Move"].concat(eventsListened, eventsToEmit).map(function (evt) {
	            return "on" + evt;
	          });
	          var draggingElement = null;
	          var props = {
	            options: Object,
	            list: {
	              type: Array,
	              required: false,
	              default: null
	            },
	            value: {
	              type: Array,
	              required: false,
	              default: null
	            },
	            noTransitionOnDrag: {
	              type: Boolean,
	              default: false
	            },
	            clone: {
	              type: Function,
	              default: function _default(original) {
	                return original;
	              }
	            },
	            element: {
	              type: String,
	              default: "div"
	            },
	            tag: {
	              type: String,
	              default: null
	            },
	            move: {
	              type: Function,
	              default: null
	            },
	            componentData: {
	              type: Object,
	              required: false,
	              default: null
	            }
	          };
	          var draggableComponent = {
	            name: "draggable",
	            inheritAttrs: false,
	            props: props,
	            data: function data() {
	              return {
	                transitionMode: false,
	                noneFunctionalComponentMode: false
	              };
	            },
	            render: function render(h) {
	              var slots = this.$slots.default;
	              this.transitionMode = vuedraggable_isTransition(slots);

	              var _computeChildrenAndOf = computeChildrenAndOffsets(slots, this.$slots, this.$scopedSlots),
	                  children = _computeChildrenAndOf.children,
	                  headerOffset = _computeChildrenAndOf.headerOffset,
	                  footerOffset = _computeChildrenAndOf.footerOffset;

	              this.headerOffset = headerOffset;
	              this.footerOffset = footerOffset;
	              var attributes = getComponentAttributes(this.$attrs, this.componentData);
	              return h(this.getTag(), attributes, children);
	            },
	            created: function created() {
	              if (this.list !== null && this.value !== null) {
	                helper["b"
	                /* console */
	                ].error("Value and list props are mutually exclusive! Please set one or another.");
	              }

	              if (this.element !== "div") {
	                helper["b"
	                /* console */
	                ].warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props");
	              }

	              if (this.options !== undefined) {
	                helper["b"
	                /* console */
	                ].warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props");
	              }
	            },
	            mounted: function mounted() {
	              var _this3 = this;

	              this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase() && !this.getIsFunctional();

	              if (this.noneFunctionalComponentMode && this.transitionMode) {
	                throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: ".concat(this.getTag()));
	              }

	              var optionsAdded = {};
	              eventsListened.forEach(function (elt) {
	                optionsAdded["on" + elt] = delegateAndEmit.call(_this3, elt);
	              });
	              eventsToEmit.forEach(function (elt) {
	                optionsAdded["on" + elt] = emit.bind(_this3, elt);
	              });
	              var attributes = Object.keys(this.$attrs).reduce(function (res, key) {
	                res[Object(helper["a"
	                /* camelize */
	                ])(key)] = _this3.$attrs[key];
	                return res;
	              }, {});
	              var options = Object.assign({}, this.options, attributes, optionsAdded, {
	                onMove: function onMove(evt, originalEvent) {
	                  return _this3.onDragMove(evt, originalEvent);
	                }
	              });
	              !("draggable" in options) && (options.draggable = ">*");
	              this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(this.rootContainer, options);
	              this.computeIndexes();
	            },
	            beforeDestroy: function beforeDestroy() {
	              if (this._sortable !== undefined) this._sortable.destroy();
	            },
	            computed: {
	              rootContainer: function rootContainer() {
	                return this.transitionMode ? this.$el.children[0] : this.$el;
	              },
	              realList: function realList() {
	                return this.list ? this.list : this.value;
	              }
	            },
	            watch: {
	              options: {
	                handler: function handler(newOptionValue) {
	                  this.updateOptions(newOptionValue);
	                },
	                deep: true
	              },
	              $attrs: {
	                handler: function handler(newOptionValue) {
	                  this.updateOptions(newOptionValue);
	                },
	                deep: true
	              },
	              realList: function realList() {
	                this.computeIndexes();
	              }
	            },
	            methods: {
	              getIsFunctional: function getIsFunctional() {
	                var fnOptions = this._vnode.fnOptions;
	                return fnOptions && fnOptions.functional;
	              },
	              getTag: function getTag() {
	                return this.tag || this.element;
	              },
	              updateOptions: function updateOptions(newOptionValue) {
	                for (var property in newOptionValue) {
	                  var value = Object(helper["a"
	                  /* camelize */
	                  ])(property);

	                  if (readonlyProperties.indexOf(value) === -1) {
	                    this._sortable.option(value, newOptionValue[property]);
	                  }
	                }
	              },
	              getChildrenNodes: function getChildrenNodes() {
	                if (this.noneFunctionalComponentMode) {
	                  return this.$children[0].$slots.default;
	                }

	                var rawNodes = this.$slots.default;
	                return this.transitionMode ? rawNodes[0].child.$slots.default : rawNodes;
	              },
	              computeIndexes: function computeIndexes() {
	                var _this4 = this;

	                this.$nextTick(function () {
	                  _this4.visibleIndexes = _computeIndexes(_this4.getChildrenNodes(), _this4.rootContainer.children, _this4.transitionMode, _this4.footerOffset);
	                });
	              },
	              getUnderlyingVm: function getUnderlyingVm(htmlElt) {
	                var index = computeVmIndex(this.getChildrenNodes() || [], htmlElt);

	                if (index === -1) {
	                  //Edge case during move callback: related element might be
	                  //an element different from collection
	                  return null;
	                }

	                var element = this.realList[index];
	                return {
	                  index: index,
	                  element: element
	                };
	              },
	              getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(_ref) {
	                var vue = _ref.__vue__;

	                if (!vue || !vue.$options || !isTransitionName(vue.$options._componentTag)) {
	                  if (!("realList" in vue) && vue.$children.length === 1 && "realList" in vue.$children[0]) return vue.$children[0];
	                  return vue;
	                }

	                return vue.$parent;
	              },
	              emitChanges: function emitChanges(evt) {
	                var _this5 = this;

	                this.$nextTick(function () {
	                  _this5.$emit("change", evt);
	                });
	              },
	              alterList: function alterList(onList) {
	                if (this.list) {
	                  onList(this.list);
	                  return;
	                }

	                var newList = _toConsumableArray(this.value);

	                onList(newList);
	                this.$emit("input", newList);
	              },
	              spliceList: function spliceList() {
	                var _arguments = arguments;

	                var spliceList = function spliceList(list) {
	                  return list.splice.apply(list, _toConsumableArray(_arguments));
	                };

	                this.alterList(spliceList);
	              },
	              updatePosition: function updatePosition(oldIndex, newIndex) {
	                var updatePosition = function updatePosition(list) {
	                  return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
	                };

	                this.alterList(updatePosition);
	              },
	              getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref2) {
	                var to = _ref2.to,
	                    related = _ref2.related;
	                var component = this.getUnderlyingPotencialDraggableComponent(to);

	                if (!component) {
	                  return {
	                    component: component
	                  };
	                }

	                var list = component.realList;
	                var context = {
	                  list: list,
	                  component: component
	                };

	                if (to !== related && list && component.getUnderlyingVm) {
	                  var destination = component.getUnderlyingVm(related);

	                  if (destination) {
	                    return Object.assign(destination, context);
	                  }
	                }

	                return context;
	              },
	              getVmIndex: function getVmIndex(domIndex) {
	                var indexes = this.visibleIndexes;
	                var numberIndexes = indexes.length;
	                return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];
	              },
	              getComponent: function getComponent() {
	                return this.$slots.default[0].componentInstance;
	              },
	              resetTransitionData: function resetTransitionData(index) {
	                if (!this.noTransitionOnDrag || !this.transitionMode) {
	                  return;
	                }

	                var nodes = this.getChildrenNodes();
	                nodes[index].data = null;
	                var transitionContainer = this.getComponent();
	                transitionContainer.children = [];
	                transitionContainer.kept = undefined;
	              },
	              onDragStart: function onDragStart(evt) {
	                this.context = this.getUnderlyingVm(evt.item);
	                evt.item._underlying_vm_ = this.clone(this.context.element);
	                draggingElement = evt.item;
	              },
	              onDragAdd: function onDragAdd(evt) {
	                var element = evt.item._underlying_vm_;

	                if (element === undefined) {
	                  return;
	                }

	                Object(helper["d"
	                /* removeNode */
	                ])(evt.item);
	                var newIndex = this.getVmIndex(evt.newIndex);
	                this.spliceList(newIndex, 0, element);
	                this.computeIndexes();
	                var added = {
	                  element: element,
	                  newIndex: newIndex
	                };
	                this.emitChanges({
	                  added: added
	                });
	              },
	              onDragRemove: function onDragRemove(evt) {
	                Object(helper["c"
	                /* insertNodeAt */
	                ])(this.rootContainer, evt.item, evt.oldIndex);

	                if (evt.pullMode === "clone") {
	                  Object(helper["d"
	                  /* removeNode */
	                  ])(evt.clone);
	                  return;
	                }

	                var oldIndex = this.context.index;
	                this.spliceList(oldIndex, 1);
	                var removed = {
	                  element: this.context.element,
	                  oldIndex: oldIndex
	                };
	                this.resetTransitionData(oldIndex);
	                this.emitChanges({
	                  removed: removed
	                });
	              },
	              onDragUpdate: function onDragUpdate(evt) {
	                Object(helper["d"
	                /* removeNode */
	                ])(evt.item);
	                Object(helper["c"
	                /* insertNodeAt */
	                ])(evt.from, evt.item, evt.oldIndex);
	                var oldIndex = this.context.index;
	                var newIndex = this.getVmIndex(evt.newIndex);
	                this.updatePosition(oldIndex, newIndex);
	                var moved = {
	                  element: this.context.element,
	                  oldIndex: oldIndex,
	                  newIndex: newIndex
	                };
	                this.emitChanges({
	                  moved: moved
	                });
	              },
	              updateProperty: function updateProperty(evt, propertyName) {
	                evt.hasOwnProperty(propertyName) && (evt[propertyName] += this.headerOffset);
	              },
	              computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
	                if (!relatedContext.element) {
	                  return 0;
	                }

	                var domChildren = _toConsumableArray(evt.to.children).filter(function (el) {
	                  return el.style["display"] !== "none";
	                });

	                var currentDOMIndex = domChildren.indexOf(evt.related);
	                var currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
	                var draggedInList = domChildren.indexOf(draggingElement) !== -1;
	                return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
	              },
	              onDragMove: function onDragMove(evt, originalEvent) {
	                var onMove = this.move;

	                if (!onMove || !this.realList) {
	                  return true;
	                }

	                var relatedContext = this.getRelatedContextFromMoveEvent(evt);
	                var draggedContext = this.context;
	                var futureIndex = this.computeFutureIndex(relatedContext, evt);
	                Object.assign(draggedContext, {
	                  futureIndex: futureIndex
	                });
	                var sendEvt = Object.assign({}, evt, {
	                  relatedContext: relatedContext,
	                  draggedContext: draggedContext
	                });
	                return onMove(sendEvt, originalEvent);
	              },
	              onDragEnd: function onDragEnd() {
	                this.computeIndexes();
	                draggingElement = null;
	              }
	            }
	          };

	          if (typeof window !== "undefined" && "Vue" in window) {
	            window.Vue.component("draggable", draggableComponent);
	          }
	          /* harmony default export */


	          var vuedraggable = draggableComponent; // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js

	          /* harmony default export */

	          var entry_lib = __webpack_exports__["default"] = vuedraggable;
	          /***/
	        }
	        /******/

	      })["default"]
	    );
	  });
	});
	var Draggable = unwrapExports(vuedraggable_umd);

	var ShadowList = /*#__PURE__*/function () {
	  function ShadowList(items) {
	    if (items === void 0) {
	      items = [];
	    }

	    this.items = items;
	  }

	  var _proto = ShadowList.prototype;

	  _proto.add = function add(item) {
	    if (item === void 0) {
	      item = new Shadow();
	    }

	    return this.items.push(item) - 1;
	  };

	  _proto.move = function move(oldIndex, newIndex) {
	    this.items.splice(newIndex, 0, this.items.splice(oldIndex, 1)[0]);
	    return newIndex;
	  };

	  _proto.remove = function remove(index) {
	    this.items.splice(index, 1);
	    return this.items.length - 1;
	  };

	  _proto.toString = function toString() {
	    return this.isNone ? 'none' : this.items.filter(function (v) {
	      return !v.isNone;
	    }).join(', ');
	  };

	  _createClass(ShadowList, [{
	    key: "isNone",
	    get: function get() {
	      return !this.items.some(function (v) {
	        return !v.isNone;
	      });
	    }
	  }, {
	    key: "length",
	    get: function get() {
	      return this.items.length;
	    }
	  }, {
	    key: "preview",
	    get: function get() {
	      var colors = this.items.filter(function (v) {
	        return !v.isNone;
	      }).map(function (s) {
	        return s.color;
	      });
	      return colors.length > 1 ? "linear-gradient(" + colors.join(', ') + ")" : colors.length == 1 ? colors[0] : '';
	    }
	  }]);

	  return ShadowList;
	}();
	var Shadow = /*#__PURE__*/function () {
	  function Shadow(props) {
	    var _this = this;

	    if (props === void 0) {
	      props = {};
	    }

	    var defprop = function defprop(name, defaultValue) {
	      return _this[name] = name in props ? props[name] : defaultValue;
	    };

	    defprop('inset', '');
	    defprop('offsetX', '0');
	    defprop('offsetY', '0');
	    defprop('blurRadius', '');
	    defprop('spreadRadius', '');
	    defprop('color', '');
	  }

	  var _proto2 = Shadow.prototype;

	  _proto2.toString = function toString() {
	    return [this.inset, this.offsetX || '0', this.offsetY || '0', this.blurRadius || this.spreadRadius && '0', this.spreadRadius, this.color].filter(function (v) {
	      return v;
	    }).map(toPx).join(' ');
	  };

	  _createClass(Shadow, [{
	    key: "isNone",
	    get: function get() {
	      return ![this.offsetX, this.offsetY, this.blurRadius, this.spreadRadius].filter(function (v) {
	        return v && !/^0/.test(v);
	      }).length;
	    }
	  }, {
	    key: "preview",
	    get: function get() {
	      return !this.isNone ? this.color : '';
	    }
	  }]);

	  return Shadow;
	}();
	var VALUES_REG = /,(?![^\(]*\))/;
	var PARTS_REG = /\s(?![^(]*\))/;
	var LENGTH_REG = /^[0-9]+[a-zA-Z%]+?$/;

	var parseValue = function parseValue(str) {
	  var parts = str.split(PARTS_REG);
	  var none = parts.includes('none') && !!parts.shift();
	  var inset = parts.includes('inset') ? 'inset' : '';
	  var last = parts.slice(-1)[0];
	  var color = last && !isLength(last) ? last : '';
	  var nums = parts // .filter(n => n !== 'none')
	  .filter(function (n) {
	    return n !== 'inset';
	  }).filter(function (n) {
	    return n !== color;
	  }).map(toNum);
	  var _nums$ = nums[0],
	      offsetX = _nums$ === void 0 ? '0' : _nums$,
	      _nums$2 = nums[1],
	      offsetY = _nums$2 === void 0 ? '0' : _nums$2,
	      _nums$3 = nums[2],
	      blurRadius = _nums$3 === void 0 ? '' : _nums$3,
	      _nums$4 = nums[3],
	      spreadRadius = _nums$4 === void 0 ? '' : _nums$4;
	  return {
	    inset: inset,
	    offsetX: offsetX,
	    offsetY: offsetY,
	    blurRadius: blurRadius,
	    spreadRadius: spreadRadius,
	    color: color
	  };
	}; // Helper for .map()


	var trim = function trim(str) {
	  return str.trim();
	};

	var isLength = function isLength(v) {
	  return v === '0' || LENGTH_REG.test(v);
	};

	var toNum = function toNum(v) {
	  if (!/px$/.test(v) && v !== '0') return v;
	  var n = parseFloat(v);
	  return !isNaN(n) ? n : v;
	}; // const toPx = n => typeof n === 'number' && n !== 0 ? (n + 'px') : n


	var toPx = function toPx(n) {
	  return toNumber(n) && n !== '0' ? n + 'px' : n;
	};

	var parse$1 = function parse(str) {
	  var list = new ShadowList();

	  if (str == null) {
	    return list;
	  }

	  str.split(VALUES_REG).map(trim).map(function (s) {
	    return list.add(new Shadow(parseValue(s)));
	  });
	  return list;
	};

	var script$j = {
	  components: {
	    Draggable: Draggable,
	    Picker: __vue_component__$3,
	    ColorControls: __vue_component__$b,
	    Colorsymbol: __vue_component__$5,
	    Checkboard: __vue_component__$4
	  },
	  props: {
	    value: String,
	    disableSpreadRadius: {
	      type: Boolean,
	      "default": false
	    },
	    disableInset: {
	      type: Boolean,
	      "default": false
	    }
	  },
	  data: function data() {
	    return {
	      index: 0,
	      list: parse$1(this.value) // return ShadowList

	    };
	  },
	  computed: _extends({}, vuex.mapState('styles', ['variables']), {
	    presetColors: function presetColors() {
	      var _this = this;

	      // const str = Object.keys(this.variables).filter(n => matchName(n, this.$parent.vars)).map(n => this.variables[n].value).join(', ')
	      // const shadowList = parse(str)
	      // const colors = shadowList.items.map(i => i.color).filter(Boolean)
	      // const list = parseColor(colors).sortByLuma()
	      // const arr = list.toArray()
	      // arr.unshift('')
	      // return Array.from(new Set(arr))
	      var colors = Object.keys(this.variables).filter(function (n) {
	        return matchName(n, '@global*-box-shadow');
	      }).map(function (n) {
	        return {
	          name: _this.variables[n].name,
	          value: parse$1(_this.variables[n].value).items[0].color
	        };
	      }).filter(function (v) {
	        return v.value;
	      }); // add color reset

	      colors.unshift({
	        name: 'none',
	        value: ''
	      });
	      return colors;
	    },
	    shadow: function shadow() {
	      var list = parse$1(this.value);
	      return {
	        isNone: list.isNone,
	        preview: list.preview
	      };
	    }
	  }),
	  watch: {
	    value: function value(newVal) {
	      this.index = 0;
	      this.list = parse$1(newVal); // return ShadowList
	    }
	  },
	  methods: {
	    hidden: function hidden() {
	      this.list = parse$1(this.value);
	    }
	  }
	};

	/* script */
	var __vue_script__$j = script$j;
	/* template */

	var __vue_render__$j = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("picker", {
	    attrs: {
	      value: _vm.shadow.preview
	    },
	    on: {
	      change: function change($event) {
	        _vm.$emit("input", _vm.list.toString());
	      },
	      hidden: _vm.hidden
	    },
	    scopedSlots: _vm._u([{
	      key: "preview",
	      fn: function fn() {
	        return [_vm.shadow.isNone ? _c("colorsymbol", {
	          attrs: {
	            size: "10"
	          }
	        }) : _c("checkboard")];
	      },
	      proxy: true
	    }])
	  }, [_vm._v(" "), _c("div", {
	    staticClass: "vc-styles-field styles-picker-field-header"
	  }, [_c("div", {
	    staticClass: "vc-styles-field--single"
	  }, [_c("div", {
	    staticClass: "vc-editable-input"
	  }, [_c("span", {
	    staticClass: "vc-input__label"
	  }, [_vm._v("\n                    Layers\n                    "), _c("a", {
	    staticClass: "uk-link-muted",
	    attrs: {
	      "uk-icon": "plus-circle",
	      ratio: ".7"
	    },
	    on: {
	      click: function click($event) {
	        $event.preventDefault();
	        _vm.index = _vm.list.add();
	      }
	    }
	  }), _vm._v(" "), _vm.list.length > 1 ? _c("a", {
	    staticClass: "uk-link-muted",
	    attrs: {
	      "uk-icon": "minus-circle",
	      ratio: ".7"
	    },
	    on: {
	      click: function click($event) {
	        $event.preventDefault();
	        _vm.index = _vm.list.remove(_vm.index);
	      }
	    }
	  }) : _vm._e()])])])]), _vm._v(" "), _c("draggable", {
	    staticClass: "vc-styles-presets styles-picker-presets",
	    on: {
	      end: function end($event) {
	        _vm.index = $event.newIndex;
	      }
	    },
	    model: {
	      value: _vm.list.items,
	      callback: function callback($$v) {
	        _vm.$set(_vm.list, "items", $$v);
	      },
	      expression: "list.items"
	    }
	  }, _vm._l(_vm.list.items, function (item, i) {
	    return _c("div", {
	      key: item.id,
	      "class": {
	        "vc-styles-presets-color": true,
	        "styles-picker-presets-color-active": _vm.index === i
	      },
	      on: {
	        click: function click($event) {
	          $event.preventDefault();
	          _vm.index = i;
	        }
	      }
	    }, [_c("div", {
	      staticClass: "vc-styles-active-color",
	      style: {
	        background: item.preview
	      }
	    }), _vm._v(" "), item.isNone ? _c("colorsymbol") : _c("checkboard")], 1);
	  }), 0), _vm._v(" "), _c("div", {
	    staticClass: "vc-styles-field styles-picker-field"
	  }, [_c("div", {
	    staticClass: "vc-styles-field--single"
	  }, [_c("div", {
	    staticClass: "vc-editable-input"
	  }, [_c("span", {
	    staticClass: "vc-input__label"
	  }, [_vm._v("X")]), _vm._v(" "), _c("input", {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.list.items[_vm.index].offsetX,
	      expression: "list.items[index].offsetX"
	    }],
	    staticClass: "vc-input__input",
	    domProps: {
	      value: _vm.list.items[_vm.index].offsetX
	    },
	    on: {
	      input: function input($event) {
	        if ($event.target.composing) {
	          return;
	        }

	        _vm.$set(_vm.list.items[_vm.index], "offsetX", $event.target.value);
	      }
	    }
	  })])]), _vm._v(" "), _c("div", {
	    staticClass: "vc-styles-field--single"
	  }, [_c("div", {
	    staticClass: "vc-editable-input"
	  }, [_c("span", {
	    staticClass: "vc-input__label"
	  }, [_vm._v("Y")]), _vm._v(" "), _c("input", {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.list.items[_vm.index].offsetY,
	      expression: "list.items[index].offsetY"
	    }],
	    staticClass: "vc-input__input",
	    domProps: {
	      value: _vm.list.items[_vm.index].offsetY
	    },
	    on: {
	      input: function input($event) {
	        if ($event.target.composing) {
	          return;
	        }

	        _vm.$set(_vm.list.items[_vm.index], "offsetY", $event.target.value);
	      }
	    }
	  })])]), _vm._v(" "), _c("div", {
	    staticClass: "vc-styles-field--single"
	  }, [_c("div", {
	    staticClass: "vc-editable-input"
	  }, [_c("span", {
	    staticClass: "vc-input__label"
	  }, [_vm._v("Blur")]), _vm._v(" "), _c("input", {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.list.items[_vm.index].blurRadius,
	      expression: "list.items[index].blurRadius"
	    }],
	    staticClass: "vc-input__input",
	    domProps: {
	      value: _vm.list.items[_vm.index].blurRadius
	    },
	    on: {
	      input: function input($event) {
	        if ($event.target.composing) {
	          return;
	        }

	        _vm.$set(_vm.list.items[_vm.index], "blurRadius", $event.target.value);
	      }
	    }
	  })])]), _vm._v(" "), !_vm.disableSpreadRadius ? _c("div", {
	    staticClass: "vc-styles-field--single"
	  }, [_c("div", {
	    staticClass: "vc-editable-input"
	  }, [_c("span", {
	    staticClass: "vc-input__label"
	  }, [_vm._v("Spread")]), _vm._v(" "), _c("input", {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.list.items[_vm.index].spreadRadius,
	      expression: "list.items[index].spreadRadius"
	    }],
	    staticClass: "vc-input__input",
	    domProps: {
	      value: _vm.list.items[_vm.index].spreadRadius
	    },
	    on: {
	      input: function input($event) {
	        if ($event.target.composing) {
	          return;
	        }

	        _vm.$set(_vm.list.items[_vm.index], "spreadRadius", $event.target.value);
	      }
	    }
	  })])]) : _vm._e(), _vm._v(" "), !_vm.disableInset ? _c("div", {
	    staticClass: "vc-styles-field--single"
	  }, [_c("div", {
	    staticClass: "vc-editable-input uk-text-center"
	  }, [_c("span", {
	    staticClass: "vc-input__label"
	  }, [_vm._v("Inset")]), _vm._v(" "), _c("input", {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.list.items[_vm.index].inset,
	      expression: "list.items[index].inset"
	    }],
	    staticClass: "styles-checkbox uk-checkbox uk-margin-remove uk-text-top",
	    attrs: {
	      "true-value": "inset",
	      "false-value": "",
	      type: "checkbox"
	    },
	    domProps: {
	      checked: Array.isArray(_vm.list.items[_vm.index].inset) ? _vm._i(_vm.list.items[_vm.index].inset, null) > -1 : _vm._q(_vm.list.items[_vm.index].inset, "inset")
	    },
	    on: {
	      change: function change($event) {
	        var $$a = _vm.list.items[_vm.index].inset,
	            $$el = $event.target,
	            $$c = $$el.checked ? "inset" : "";

	        if (Array.isArray($$a)) {
	          var $$v = null,
	              $$i = _vm._i($$a, $$v);

	          if ($$el.checked) {
	            $$i < 0 && _vm.$set(_vm.list.items[_vm.index], "inset", $$a.concat([$$v]));
	          } else {
	            $$i > -1 && _vm.$set(_vm.list.items[_vm.index], "inset", $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
	          }
	        } else {
	          _vm.$set(_vm.list.items[_vm.index], "inset", $$c);
	        }
	      }
	    }
	  })])]) : _vm._e()]), _vm._v(" "), _c("color-controls", {
	    ref: "colorcontrols",
	    attrs: {
	      "preset-colors-used": _vm.presetColors
	    },
	    model: {
	      value: _vm.list.items[_vm.index].color,
	      callback: function callback($$v) {
	        _vm.$set(_vm.list.items[_vm.index], "color", $$v);
	      },
	      expression: "list.items[index].color"
	    }
	  })], 1);
	};

	var __vue_staticRenderFns__$j = [];
	__vue_render__$j._withStripped = true;
	/* style */

	var __vue_inject_styles__$j = undefined;
	/* scoped */

	var __vue_scope_id__$j = undefined;
	/* module identifier */

	var __vue_module_identifier__$j = undefined;
	/* functional template */

	var __vue_is_functional_template__$j = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$j = normalizeComponent({
	  render: __vue_render__$j,
	  staticRenderFns: __vue_staticRenderFns__$j
	}, __vue_inject_styles__$j, __vue_script__$j, __vue_scope_id__$j, __vue_is_functional_template__$j, __vue_module_identifier__$j, false, undefined, undefined, undefined);

	//
	var script$k = {
	  components: {
	    ShadowPicker: __vue_component__$j
	  },
	  "extends": Vue$1.component('field')
	};

	/* script */
	var __vue_script__$k = script$k;
	/* template */

	var __vue_render__$k = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("shadow-picker", _vm._b({
	    model: {
	      value: _vm.value,
	      callback: function callback($$v) {
	        _vm.value = $$v;
	      },
	      expression: "value"
	    }
	  }, "shadow-picker", _vm.attributes, false));
	};

	var __vue_staticRenderFns__$k = [];
	__vue_render__$k._withStripped = true;
	/* style */

	var __vue_inject_styles__$k = undefined;
	/* scoped */

	var __vue_scope_id__$k = undefined;
	/* module identifier */

	var __vue_module_identifier__$k = undefined;
	/* functional template */

	var __vue_is_functional_template__$k = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$k = normalizeComponent({
	  render: __vue_render__$k,
	  staticRenderFns: __vue_staticRenderFns__$k
	}, __vue_inject_styles__$k, __vue_script__$k, __vue_scope_id__$k, __vue_is_functional_template__$k, __vue_module_identifier__$k, false, undefined, undefined, undefined);

	//
	var script$l = {
	  "extends": Vue$1.component('field')
	};

	/* script */
	var __vue_script__$l = script$l;
	/* template */

	var __vue_render__$l = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("input", _vm._b({
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.value,
	      expression: "value"
	    }],
	    staticClass: "styles-checkbox uk-checkbox",
	    attrs: {
	      "true-value": "true",
	      "false-value": "false",
	      type: "checkbox"
	    },
	    domProps: {
	      checked: Array.isArray(_vm.value) ? _vm._i(_vm.value, null) > -1 : _vm._q(_vm.value, "true")
	    },
	    on: {
	      change: function change($event) {
	        var $$a = _vm.value,
	            $$el = $event.target,
	            $$c = $$el.checked ? "true" : "false";

	        if (Array.isArray($$a)) {
	          var $$v = null,
	              $$i = _vm._i($$a, $$v);

	          if ($$el.checked) {
	            $$i < 0 && (_vm.value = $$a.concat([$$v]));
	          } else {
	            $$i > -1 && (_vm.value = $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
	          }
	        } else {
	          _vm.value = $$c;
	        }
	      }
	    }
	  }, "input", _vm.attributes, false));
	};

	var __vue_staticRenderFns__$l = [];
	__vue_render__$l._withStripped = true;
	/* style */

	var __vue_inject_styles__$l = undefined;
	/* scoped */

	var __vue_scope_id__$l = undefined;
	/* module identifier */

	var __vue_module_identifier__$l = undefined;
	/* functional template */

	var __vue_is_functional_template__$l = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$l = normalizeComponent({
	  render: __vue_render__$l,
	  staticRenderFns: __vue_staticRenderFns__$l
	}, __vue_inject_styles__$l, __vue_script__$l, __vue_scope_id__$l, __vue_is_functional_template__$l, __vue_module_identifier__$l, false, undefined, undefined, undefined);

	//
	var script$m = {
	  components: {
	    ColorPicker: __vue_component__$h
	  },
	  "extends": Vue$1.component('field')
	};

	/* script */
	var __vue_script__$m = script$m;
	/* template */

	var __vue_render__$m = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("color-picker", _vm._b({
	    model: {
	      value: _vm.value,
	      callback: function callback($$v) {
	        _vm.value = $$v;
	      },
	      expression: "value"
	    }
	  }, "color-picker", _vm.attributes, false));
	};

	var __vue_staticRenderFns__$m = [];
	__vue_render__$m._withStripped = true;
	/* style */

	var __vue_inject_styles__$m = undefined;
	/* scoped */

	var __vue_scope_id__$m = undefined;
	/* module identifier */

	var __vue_module_identifier__$m = undefined;
	/* functional template */

	var __vue_is_functional_template__$m = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$m = normalizeComponent({
	  render: __vue_render__$m,
	  staticRenderFns: __vue_staticRenderFns__$m
	}, __vue_inject_styles__$m, __vue_script__$m, __vue_scope_id__$m, __vue_is_functional_template__$m, __vue_module_identifier__$m, false, undefined, undefined, undefined);

	var debounce$2 = {
	  bind: directive,
	  update: function update(el, binding) {
	    if (binding.value !== binding.oldValue) {
	      directive(el, binding);
	    }
	  }
	};

	function directive(el, binding) {
	  el.oninput = debounce(function (e) {
	    el.dispatchEvent(new Event('change'));
	  }, parseInt(binding.value) || 500);
	}

	//
	var _fonts = [];
	var script$n = {
	  props: {
	    title: {
	      type: String,
	      "default": function _default() {
	        return this.$t('Select Font');
	      }
	    },
	    fonts: {
	      type: Object
	    },
	    value: {
	      type: String
	    },
	    internal: {
	      type: Array
	    }
	  },
	  data: function data() {
	    return {
	      font: {}
	      /*{
	      name: "Inherit",
	      value: "inherit",
	      variants: []
	      }*/
	      ,
	      search: '',
	      language: '',
	      categories: this.fonts.reduce(function (arr, group) {
	        if (group.categories) {
	          group.categories.forEach(function (category) {
	            if (!arr.filter(function (c) {
	              return c.id === category.id;
	            }).length) {
	              category.selected = true;
	              arr.push(category);
	            }
	          });
	        }

	        return arr;
	      }, []),
	      languages: this.fonts.reduce(function (arr, group) {
	        if (group.languages) {
	          group.languages.forEach(function (language) {
	            if (!arr.filter(function (l) {
	              return l.id === language.id;
	            }).length) {
	              arr.push(language);
	            }
	          });
	        }

	        return arr;
	      }, []),
	      groups: this.fonts.map(function (group) {
	        return {
	          name: group.name,
	          fonts: group.fonts
	        };
	      })
	    };
	  },
	  methods: {
	    change: function change(font) {
	      var internal = this.internal.filter(function (f) {
	        return f.name === font.name;
	      })[0];

	      if (internal) {
	        font.variants.forEach(function (variant) {
	          if (internal.variants.includes(variant.vale)) {
	            variant.selc = true;
	          }
	        });
	      }

	      this.font = font;
	    },
	    choose: function choose() {
	      this.$emit('input', this.font);
	      this.$emit('resolve', this.font);
	    },
	    filter: function filter() {
	      var re = new RegExp(this.search, 'i');
	      var categories = this.categories.filter(function (category) {
	        return category.selected;
	      }).map(function (category) {
	        return category.id;
	      });
	      var language = this.language;
	      return this.fonts.map(function (group) {
	        return {
	          name: group.name,
	          fonts: group.fonts.filter(function (font) {
	            return re.test(font.name) && (font.category === undefined || categories.includes(font.category)) && ('' === language || font.subsets === undefined || font.subsets.includes(language));
	          })
	        };
	      }).filter(function (group) {
	        return group.fonts.length;
	      });
	    },
	    getFilteredGroups: function getFilteredGroups() {
	      this.groups = this.filter();
	      this.check();
	    },
	    check: function check() {
	      var fonts = [];
	      var e = this.$refs.overflow.getBoundingClientRect();
	      var top = e.top;
	      var bottom = e.bottom;
	      var left = e.left;
	      var right = e.right;
	      var height = e.height;
	      var box = {
	        top: top - height,
	        bottom: bottom + height,
	        left: left,
	        right: right
	      };
	      $$('.google-font', this.$refs.overflow).forEach(function (el) {
	        if (intersectRect(el.getBoundingClientRect(), box) && !_fonts.includes(data(el, 'font-name'))) {
	          _fonts.push(data(el, 'font-name'));

	          fonts.push(data(el, 'font-name'));
	        }
	      });

	      if (fonts.length) {
	        document.head.appendChild($("<link href=\"//fonts.googleapis.com/css?family=" + fonts.map(encodeURIComponent).join('|') + "\" rel=\"stylesheet\">"));
	      }
	    }
	  },
	  watch: {
	    search: 'getFilteredGroups',
	    language: 'getFilteredGroups'
	  },
	  directives: {
	    debounce: debounce$2
	  },
	  mixins: [i18n]
	};

	/* script */
	var __vue_script__$n = script$n;
	/* template */

	var __vue_render__$n = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", [_c("button", {
	    staticClass: "uk-modal-close-default",
	    attrs: {
	      type: "button",
	      "data-uk-close": ""
	    }
	  }), _vm._v(" "), _c("div", {
	    staticClass: "uk-modal-header"
	  }, [_c("h2", {
	    staticClass: "uk-modal-title"
	  }, [_vm._v(_vm._s(_vm.title))]), _vm._v(" "), _c("div", {
	    staticClass: "uk-grid uk-grid-small"
	  }, [_c("div", {
	    staticClass: "uk-width-1-3@s"
	  }, [_c("div", {
	    staticClass: "uk-search uk-search-default uk-width-1-1"
	  }, [_c("span", {
	    staticClass: "uk-search-icon-flip",
	    attrs: {
	      "uk-search-icon": ""
	    }
	  }), _vm._v(" "), _c("input", {
	    directives: [{
	      name: "debounce",
	      rawName: "v-debounce"
	    }, {
	      name: "model",
	      rawName: "v-model.lazy",
	      value: _vm.search,
	      expression: "search",
	      modifiers: {
	        lazy: true
	      }
	    }],
	    staticClass: "uk-search-input",
	    attrs: {
	      type: "text",
	      placeholder: _vm.$t("Search...")
	    },
	    domProps: {
	      value: _vm.search
	    },
	    on: {
	      change: function change($event) {
	        _vm.search = $event.target.value;
	      }
	    }
	  })])]), _vm._v(" "), _c("div", {
	    staticClass: "uk-width-1-2 uk-width-1-3@s"
	  }, [_c("a", {
	    staticClass: "uk-link-reset uk-select"
	  }, [_vm._v(_vm._s(_vm.$t("Categories")))]), _vm._v(" "), _c("div", {
	    attrs: {
	      "uk-dropdown": "mode: click"
	    }
	  }, [_c("ul", {
	    staticClass: "uk-nav uk-dropdown-nav"
	  }, _vm._l(_vm.categories, function (category) {
	    return _c("li", [_c("label", [_c("input", {
	      directives: [{
	        name: "model",
	        rawName: "v-model",
	        value: category.selected,
	        expression: "category.selected"
	      }],
	      staticClass: "styles-checkbox uk-checkbox",
	      attrs: {
	        type: "checkbox"
	      },
	      domProps: {
	        checked: Array.isArray(category.selected) ? _vm._i(category.selected, null) > -1 : category.selected
	      },
	      on: {
	        change: [function ($event) {
	          var $$a = category.selected,
	              $$el = $event.target,
	              $$c = $$el.checked ? true : false;

	          if (Array.isArray($$a)) {
	            var $$v = null,
	                $$i = _vm._i($$a, $$v);

	            if ($$el.checked) {
	              $$i < 0 && _vm.$set(category, "selected", $$a.concat([$$v]));
	            } else {
	              $$i > -1 && _vm.$set(category, "selected", $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
	            }
	          } else {
	            _vm.$set(category, "selected", $$c);
	          }
	        }, _vm.getFilteredGroups]
	      }
	    }), _vm._v("\n                                " + _vm._s(category.name) + "\n                            ")])]);
	  }), 0)])]), _vm._v(" "), _c("div", {
	    staticClass: "uk-width-1-2 uk-width-1-3@s"
	  }, [_c("select", {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.language,
	      expression: "language"
	    }],
	    staticClass: "uk-select",
	    on: {
	      change: function change($event) {
	        var $$selectedVal = Array.prototype.filter.call($event.target.options, function (o) {
	          return o.selected;
	        }).map(function (o) {
	          var val = "_value" in o ? o._value : o.value;
	          return val;
	        });
	        _vm.language = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
	      }
	    }
	  }, [_c("option", {
	    attrs: {
	      value: ""
	    }
	  }, [_vm._v(_vm._s("" === _vm.language ? _vm.$t("Language") : _vm.$t("All languages")))]), _vm._v(" "), _vm._l(_vm.languages, function (option) {
	    return _c("option", {
	      domProps: {
	        value: option.id
	      }
	    }, [_vm._v(_vm._s(option.name))]);
	  })], 2)])])]), _vm._v(" "), _c("div", {
	    ref: "overflow",
	    staticClass: "uk-modal-body",
	    attrs: {
	      "uk-overflow-auto": ""
	    },
	    on: {
	      scroll: _vm.check
	    }
	  }, [_vm._l(_vm.groups, function (group) {
	    return [_c("h3", [_vm._v(_vm._s(group.name))]), _vm._v(" "), _c("div", {
	      staticClass: "uk-grid uk-grid-collapse uk-grid-divider uk-child-width-1-1"
	    }, _vm._l(group.fonts, function (f) {
	      return _c("div", {
	        "class": {
	          "google-font": /Google/.test(group.name)
	        },
	        attrs: {
	          "data-font-name": f.name
	        }
	      }, [_c("div", {
	        "class": {
	          "uk-padding-small uk-card uk-card-primary": f.name === _vm.font.name
	        },
	        on: {
	          click: function click($event) {
	            return _vm.change(f);
	          }
	        }
	      }, [_c("span", {
	        staticClass: "uk-text-large",
	        style: {
	          "font-family": f.value
	        }
	      }, [_vm._v(_vm._s(f.name))]), _vm._v(" "), f.variants && f.variants.length && f.name === _vm.font.name ? _c("div", {
	        staticClass: "uk-grid uk-child-width-1-2@s uk-margin-small-top"
	      }, _vm._l(f.variants, function (variant) {
	        return _c("div", [_c("label", {
	          "class": {
	            "uk-text-muted": variant.disb
	          },
	          on: {
	            click: function click($event) {
	              $event.stopPropagation();
	            }
	          }
	        }, [_c("input", {
	          directives: [{
	            name: "model",
	            rawName: "v-model",
	            value: variant.selc,
	            expression: "variant.selc"
	          }],
	          staticClass: "styles-checkbox uk-checkbox",
	          attrs: {
	            type: "checkbox",
	            disabled: variant.disb
	          },
	          domProps: {
	            checked: Array.isArray(variant.selc) ? _vm._i(variant.selc, null) > -1 : variant.selc
	          },
	          on: {
	            change: function change($event) {
	              var $$a = variant.selc,
	                  $$el = $event.target,
	                  $$c = $$el.checked ? true : false;

	              if (Array.isArray($$a)) {
	                var $$v = null,
	                    $$i = _vm._i($$a, $$v);

	                if ($$el.checked) {
	                  $$i < 0 && _vm.$set(variant, "selc", $$a.concat([$$v]));
	                } else {
	                  $$i > -1 && _vm.$set(variant, "selc", $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
	                }
	              } else {
	                _vm.$set(variant, "selc", $$c);
	              }
	            }
	          }
	        }), _vm._v(" " + _vm._s(variant.name) + "\n                                ")])]);
	      }), 0) : _vm._e()])]);
	    }), 0)];
	  })], 2), _vm._v(" "), _c("div", {
	    staticClass: "uk-modal-footer uk-text-right"
	  }, [_c("button", {
	    staticClass: "uk-button uk-button-default uk-modal-close",
	    attrs: {
	      type: "button"
	    }
	  }, [_vm._v(_vm._s(_vm.$t("Cancel")))]), _vm._v(" "), _c("button", {
	    staticClass: "uk-button uk-button-primary",
	    attrs: {
	      type: "button"
	    },
	    on: {
	      click: _vm.choose
	    }
	  }, [_vm._v(_vm._s(_vm.$t("Apply")))])])]);
	};

	var __vue_staticRenderFns__$n = [];
	__vue_render__$n._withStripped = true;
	/* style */

	var __vue_inject_styles__$n = undefined;
	/* scoped */

	var __vue_scope_id__$n = undefined;
	/* module identifier */

	var __vue_module_identifier__$n = undefined;
	/* functional template */

	var __vue_is_functional_template__$n = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$n = normalizeComponent({
	  render: __vue_render__$n,
	  staticRenderFns: __vue_staticRenderFns__$n
	}, __vue_inject_styles__$n, __vue_script__$n, __vue_scope_id__$n, __vue_is_functional_template__$n, __vue_module_identifier__$n, false, undefined, undefined, undefined);

	var script$o = {
	  computed: _extends({}, vuex.mapState('styles', ['fonts', 'variables']), {
	    font: function font() {
	      var _this = this;

	      var font = this.fonts.map(function (group) {
	        return group.fonts.filter(function (font) {
	          return font.value === _this.value;
	        })[0] || {};
	      }).filter(function (font) {
	        return font.name;
	      })[0];
	      return font && font.name ? font.name : this.$t('Choose Font');
	    },
	    internal: function internal() {
	      // return (this.vars['@internal-fonts'] || this.variables['@internal-fonts'].value)
	      return this.variables['@internal-fonts'].value.replace(/~'([^']*)'/, '$1').split('|').map(function (s) {
	        s = s.split(':');
	        return {
	          name: s[0].replace(/\+/g, ' '),
	          variants: s[1] ? s[1].split(',') : []
	        };
	      });
	    }
	  }),
	  methods: {
	    select: function select() {
	      var _this2 = this;

	      this.$modal(__vue_component__$n, {
	        fonts: this.fonts,
	        internal: this.internal,
	        value: this.value
	      }).show().then(function (value) {
	        if (!uikitUtil.isUndefined(value)) {
	          var vars = Object.keys(_this2.variables).filter(function (n) {
	            return /-font-family$/.test(n);
	          }).filter(function (n) {
	            return !_this2.variables[n].computed;
	          });
	          var fonts = [];
	          vars.forEach(function (n) {
	            var v = n === _this2.name ? value.value : _this2.values[n] || _this2.variables[n].value;

	            var font = _this2.fonts[1].fonts.filter(function (font) {
	              return font.value === v;
	            })[0];

	            if (font && !fonts.filter(function (f) {
	              return f.value === font.value;
	            }).length) {
	              fonts.push(font);
	            }
	          });
	          fonts.forEach(function (f) {
	            if (f.name === _this2.name) {
	              f.variants = value.variants;
	            } else {
	              var internal = _this2.internal.filter(function (ft) {
	                return ft.name === f.name;
	              })[0];

	              if (internal) {
	                f.variants.forEach(function (variant) {
	                  if (internal.variants.includes(variant.vale)) {
	                    variant.selc = true;
	                  }
	                });
	              }
	            }
	          });

	          _this2.$store.commit('styles/setState', {
	            name: 'vars.@internal-fonts',
	            value: "~'" + fonts.map(function (f) {
	              return f.name.replace(/\s/g, '+') + ':' + f.variants.filter(function (v) {
	                return v.selc;
	              }).map(function (v) {
	                return v.vale;
	              }).sort().join(',');
	            }).join('|') + "'"
	          });

	          _this2.value = value.value;
	        }
	      });
	    }
	  },
	  mixins: [i18n],
	  "extends": Vue$1.component('field')
	};

	/* script */
	var __vue_script__$o = script$o;
	/* template */

	var __vue_render__$o = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("a", {
	    staticClass: "uk-link-reset uk-select uk-text-truncate styles-form",
	    on: {
	      click: function click($event) {
	        $event.preventDefault();
	        return _vm.select($event);
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.font))]);
	};

	var __vue_staticRenderFns__$o = [];
	__vue_render__$o._withStripped = true;
	/* style */

	var __vue_inject_styles__$o = undefined;
	/* scoped */

	var __vue_scope_id__$o = undefined;
	/* module identifier */

	var __vue_module_identifier__$o = undefined;
	/* functional template */

	var __vue_is_functional_template__$o = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$o = normalizeComponent({
	  render: __vue_render__$o,
	  staticRenderFns: __vue_staticRenderFns__$o
	}, __vue_inject_styles__$o, __vue_script__$o, __vue_scope_id__$o, __vue_is_functional_template__$o, __vue_module_identifier__$o, false, undefined, undefined, undefined);

	//
	var script$p = {
	  "extends": Vue$1.component('field')
	};

	/* script */
	var __vue_script__$p = script$p;
	/* template */

	var __vue_render__$p = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("select", _vm._b({
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.value,
	      expression: "value"
	    }],
	    staticClass: "uk-select styles-form",
	    attrs: {
	      "data-dir": "rtl"
	    },
	    on: {
	      change: function change($event) {
	        var $$selectedVal = Array.prototype.filter.call($event.target.options, function (o) {
	          return o.selected;
	        }).map(function (o) {
	          var val = "_value" in o ? o._value : o.value;
	          return val;
	        });
	        _vm.value = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
	      }
	    }
	  }, "select", _vm.attributes, false), [_vm._l(_vm.filterOptions(_vm.options), function (option) {
	    return [option.label ? _c("optgroup", {
	      attrs: {
	        label: option.label
	      }
	    }, _vm._l(option.options, function (opt) {
	      return _c("option", {
	        domProps: {
	          value: opt.value
	        }
	      }, [_vm._v(_vm._s(opt.text))]);
	    }), 0) : _c("option", {
	      domProps: {
	        value: option.value
	      }
	    }, [_vm._v(_vm._s(option.text))])];
	  })], 2);
	};

	var __vue_staticRenderFns__$p = [];
	__vue_render__$p._withStripped = true;
	/* style */

	var __vue_inject_styles__$p = undefined;
	/* scoped */

	var __vue_scope_id__$p = undefined;
	/* module identifier */

	var __vue_module_identifier__$p = undefined;
	/* functional template */

	var __vue_is_functional_template__$p = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$p = normalizeComponent({
	  render: __vue_render__$p,
	  staticRenderFns: __vue_staticRenderFns__$p
	}, __vue_inject_styles__$p, __vue_script__$p, __vue_scope_id__$p, __vue_is_functional_template__$p, __vue_module_identifier__$p, false, undefined, undefined, undefined);

	//
	var script$q = {
	  directives: {
	    debounce: debounce$2
	  },
	  "extends": Vue$1.component('field')
	};

	/* script */
	var __vue_script__$q = script$q;
	/* template */

	var __vue_render__$q = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("input", _vm._b({
	    directives: [{
	      name: "debounce",
	      rawName: "v-debounce"
	    }, {
	      name: "model",
	      rawName: "v-model.lazy",
	      value: _vm.value,
	      expression: "value",
	      modifiers: {
	        lazy: true
	      }
	    }],
	    staticClass: "uk-input styles-form",
	    attrs: {
	      type: "text"
	    },
	    domProps: {
	      value: _vm.value
	    },
	    on: {
	      change: function change($event) {
	        _vm.value = $event.target.value;
	      }
	    }
	  }, "input", _vm.attributes, false));
	};

	var __vue_staticRenderFns__$q = [];
	__vue_render__$q._withStripped = true;
	/* style */

	var __vue_inject_styles__$q = undefined;
	/* scoped */

	var __vue_scope_id__$q = undefined;
	/* module identifier */

	var __vue_module_identifier__$q = undefined;
	/* functional template */

	var __vue_is_functional_template__$q = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$q = normalizeComponent({
	  render: __vue_render__$q,
	  staticRenderFns: __vue_staticRenderFns__$q
	}, __vue_inject_styles__$q, __vue_script__$q, __vue_scope_id__$q, __vue_is_functional_template__$q, __vue_module_identifier__$q, false, undefined, undefined, undefined);

	var script$r = {
	  mixins: [i18n],
	  "extends": Vue$1.component('field'),
	  computed: vuex.mapGetters('styles', ['vars']),
	  components: {
	    FieldBackground: __vue_component__$i,
	    FieldBorder: __vue_component__$m,
	    FieldBoxshadow: __vue_component__$k,
	    FieldCheckbox: __vue_component__$l,
	    FieldColor: __vue_component__$m,
	    FieldFont: __vue_component__$o,
	    FieldSelectCustom: __vue_component__$p,
	    FieldText: __vue_component__$q,
	    FieldTextshadow: __vue_component__$k
	  },
	  methods: _extends({}, vuex.mapActions('styles', ['reset']), {
	    hasChanged: function hasChanged(name) {
	      if (/.*-background$/.test(name)) {
	        var internalName = name.replace(/^@/, '@internal-').replace(/-background$/, '-gradient');
	        return name in this.vars || internalName in this.vars;
	      }

	      return name in this.vars;
	    }
	  })
	};

	/* script */
	var __vue_script__$r = script$r;
	/* template */

	var __vue_render__$r = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "styles-group"
	  }, _vm._l(_vm.$parent.prepare(_vm.field.items), function (field) {
	    return _c("div", {
	      staticClass: "styles-group-field uk-flex uk-flex-middle uk-margin-small-top uk-position-relative uk-visible-toggle"
	    }, [_vm.hasChanged(field.name) ? _c("div", {
	      staticClass: "styles-field-style-reset",
	      on: {
	        click: function click($event) {
	          $event.preventDefault();
	          return _vm.reset(field.name);
	        }
	      }
	    }) : _vm._e(), _vm._v(" "), _c("div", {
	      staticClass: "uk-width-expand uk-text-truncate uk-text-capitalize"
	    }, [_c("span", {
	      attrs: {
	        title: field.name,
	        "uk-tooltip": "delay: 1000; pos: top-left"
	      }
	    }, [_vm._v(_vm._s(field.label))]), _vm._v(" "), field.computed ? _c("span", {
	      staticClass: "styles-field-style-label uk-invisible-hover",
	      attrs: {
	        title: _vm.$t("Auto-calculated"),
	        "uk-tooltip": "delay: 1000"
	      }
	    }, [_vm._v("A")]) : _vm._e()]), _vm._v(" "), _c("div", {
	      staticClass: "uk-width-auto"
	    }, [_c(field.component, {
	      tag: "component",
	      attrs: {
	        field: field,
	        values: _vm.values
	      },
	      on: {
	        change: _vm.$parent.change
	      }
	    })], 1)]);
	  }), 0);
	};

	var __vue_staticRenderFns__$r = [];
	__vue_render__$r._withStripped = true;
	/* style */

	var __vue_inject_styles__$r = undefined;
	/* scoped */

	var __vue_scope_id__$r = undefined;
	/* module identifier */

	var __vue_module_identifier__$r = undefined;
	/* functional template */

	var __vue_is_functional_template__$r = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$r = normalizeComponent({
	  render: __vue_render__$r,
	  staticRenderFns: __vue_staticRenderFns__$r
	}, __vue_inject_styles__$r, __vue_script__$r, __vue_scope_id__$r, __vue_is_functional_template__$r, __vue_module_identifier__$r, false, undefined, undefined, undefined);

	var script$s = {
	  computed: vuex.mapGetters('styles', ['panels', 'vars']),
	  methods: _extends({}, vuex.mapActions('styles', ['reset', 'openPanel']), {
	    isChanged: function isChanged(panel) {
	      var panels = this.panels,
	          vars = this.vars;
	      return panels[panel] && Object.keys(panels[panel].fields).reduce(function (names, n) {
	        return names.concat(panels[panel].fields[n].items ? Object.keys(panels[panel].fields[n].items) : [n]);
	      }, []).some(function (name) {
	        if (/.*-background$/.test(name)) {
	          var internalName = name.replace(/^@/, '@internal-').replace(/-background$/, '-gradient');
	          return name in vars || internalName in vars;
	        }

	        return name in vars;
	      });
	    }
	  }),
	  mixins: [i18n],
	  "extends": Vue$1.component('field')
	};

	/* script */
	var __vue_script__$s = script$s;
	/* template */

	var __vue_render__$s = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("ul", {
	    staticClass: "uk-nav uk-nav-default customizer-field-menu styles-field-menu"
	  }, _vm._l(_vm.items, function (item, index) {
	    return _c("li", [_c("h2", {
	      staticClass: "customizer-field-menu-title styles-field-menu-title",
	      attrs: {
	        tabindex: "0"
	      },
	      on: {
	        click: function click($event) {
	          $event.preventDefault();
	          return _vm.openPanel(index);
	        }
	      }
	    }, [_vm.isChanged(index) ? _c("div", {
	      staticClass: "styles-field-style-reset",
	      on: {
	        click: function click($event) {
	          $event.stopPropagation();
	          $event.preventDefault();
	          return _vm.reset(index);
	        }
	      }
	    }) : _vm._e(), _vm._v("\n            " + _vm._s(item.label) + "\n            "), item.tooltip ? _c("span", {
	      staticClass: "customizer-field-tooltip styles-field-tooltip",
	      attrs: {
	        title: item.tooltip,
	        "data-uk-tooltip": "delay: 500"
	      }
	    }, [_vm._v("?")]) : _vm._e(), _vm._v(" "), item.info ? _c("a", {
	      staticClass: "customizer-field-info styles-field-info",
	      attrs: {
	        href: item.info,
	        title: _vm.$t("go to instructions"),
	        target: "_blank"
	      },
	      on: {
	        click: function click($event) {
	          $event.stopPropagation();
	        }
	      }
	    }, [_vm._v("i")]) : _vm._e(), _vm._v(" "), _c("span", {
	      staticClass: "uk-position-center-right uk-position-small",
	      attrs: {
	        "data-uk-icon": "chevron-right"
	      }
	    })])]);
	  }), 0);
	};

	var __vue_staticRenderFns__$s = [];
	__vue_render__$s._withStripped = true;
	/* style */

	var __vue_inject_styles__$s = undefined;
	/* scoped */

	var __vue_scope_id__$s = undefined;
	/* module identifier */

	var __vue_module_identifier__$s = undefined;
	/* functional template */

	var __vue_is_functional_template__$s = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$s = normalizeComponent({
	  render: __vue_render__$s,
	  staticRenderFns: __vue_staticRenderFns__$s
	}, __vue_inject_styles__$s, __vue_script__$s, __vue_scope_id__$s, __vue_is_functional_template__$s, __vue_module_identifier__$s, false, undefined, undefined, undefined);

	var script$t = {
	  data: function data() {
	    return {
	      previewComponent: false
	    };
	  },
	  props: ['field', 'values'],
	  computed: _extends({}, vuex.mapGetters('styles', ['groups', 'currentPanelName']), {
	    currentComponent: function currentComponent() {
	      return this.currentPanelName in this.groups ? this.currentPanelName : 'global';
	    },
	    active: {
	      get: function get() {
	        return this.previewComponent;
	      },
	      set: function set(val) {
	        this.previewComponent = uikitUtil.toBoolean(val);
	        this.$store.dispatch('styles/updatePreview', {});
	      }
	    }
	  }),
	  watch: {
	    currentComponent: function currentComponent(val, oldVal) {
	      val !== oldVal && this.active && this.$store.dispatch('styles/updatePreview', {});
	    }
	  },
	  methods: {
	    previewLoad: function previewLoad(payload) {
	      var src = this.$store.getters.route.preview;

	      if (this.active) {
	        src = ~src.indexOf('?') ? src + "&component=" + this.currentComponent : src + "?component=" + this.currentComponent;
	      }

	      payload.src = src;
	    },
	    previewReady: function previewReady(payload) {
	      var $config = payload.window.$config;

	      if (~$config.route.preview.indexOf('?')) {
	        var preview = $config.route.preview.split('?');
	        preview[1] = preview[1] && preview[1].split('&').filter(function (param) {
	          return !~param.indexOf('component');
	        }).join('&');
	        $config.route.preview = preview[1] ? preview.join('?') : preview[0];
	      }
	    }
	  },
	  mixins: [i18n],
	  created: function created() {
	    var _this = this;

	    this.unsubscribePreviewLoad = this.$store.subscribeAction(function (_ref, state) {
	      var type = _ref.type,
	          payload = _ref.payload;
	      return 'styles/updatePreview' === type && _this.previewLoad(payload);
	    }, {
	      prepend: true
	    });
	    this.unsubscribePreviewReady = this.$store.subscribeAction(function (_ref2, state) {
	      var type = _ref2.type,
	          payload = _ref2.payload;
	      return 'preview/ready' === type && _this.previewReady(payload);
	    });
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.active && (this.active = false);
	    uikitUtil.isFunction(this.unsubscribePreviewLoad) && this.unsubscribePreviewLoad();
	    uikitUtil.isFunction(this.unsubscribePreviewReady) && this.unsubscribePreviewReady();
	  }
	};

	/* script */
	var __vue_script__$t = script$t;
	/* template */

	var __vue_render__$t = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "uk-margin-small-top"
	  }, [_c("label", [_c("input", {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.active,
	      expression: "active"
	    }],
	    staticClass: "styles-checkbox uk-checkbox",
	    attrs: {
	      "true-value": "true",
	      "false-value": "false",
	      type: "checkbox"
	    },
	    domProps: {
	      checked: Array.isArray(_vm.active) ? _vm._i(_vm.active, null) > -1 : _vm._q(_vm.active, "true")
	    },
	    on: {
	      change: function change($event) {
	        var $$a = _vm.active,
	            $$el = $event.target,
	            $$c = $$el.checked ? "true" : "false";

	        if (Array.isArray($$a)) {
	          var $$v = null,
	              $$i = _vm._i($$a, $$v);

	          if ($$el.checked) {
	            $$i < 0 && (_vm.active = $$a.concat([$$v]));
	          } else {
	            $$i > -1 && (_vm.active = $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
	          }
	        } else {
	          _vm.active = $$c;
	        }
	      }
	    }
	  }), _vm._v("\n        " + _vm._s(_vm.$t("Preview all UI components")) + "\n    ")])]);
	};

	var __vue_staticRenderFns__$t = [];
	__vue_render__$t._withStripped = true;
	/* style */

	var __vue_inject_styles__$t = undefined;
	/* scoped */

	var __vue_scope_id__$t = undefined;
	/* module identifier */

	var __vue_module_identifier__$t = undefined;
	/* functional template */

	var __vue_is_functional_template__$t = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$t = normalizeComponent({
	  render: __vue_render__$t,
	  staticRenderFns: __vue_staticRenderFns__$t
	}, __vue_inject_styles__$t, __vue_script__$t, __vue_scope_id__$t, __vue_is_functional_template__$t, __vue_module_identifier__$t, false, undefined, undefined, undefined);

	//
	var script$u = {
	  props: {
	    title: {
	      type: String,
	      "default": function _default() {
	        return this.$t('Select Style');
	      }
	    },
	    themes: {
	      type: Object,
	      "default": function _default() {
	        return {};
	      }
	    },
	    route: {
	      type: String,
	      "default": function _default() {
	        return '';
	      }
	    }
	  },
	  data: function data() {
	    return {
	      filterStr: ''
	    };
	  },
	  computed: {
	    styles: function styles() {
	      var _this = this;

	      return Object.keys(this.themes).reduce(function (styles, style) {
	        styles.push({
	          name: _this.themes[style].name,
	          style: style,
	          color: _this.themes[style].color[0],
	          background: _this.themes[style].background[0],
	          substyle: '',
	          preview: _this.themes[style].preview
	        });
	        _this.themes[style].styles && Object.keys(_this.themes[style].styles).forEach(function (substyle) {
	          styles.push({
	            name: _this.themes[style].name + " - " + _this.themes[style].styles[substyle].name,
	            style: style,
	            color: _this.themes[style].styles[substyle].color[0],
	            background: _this.themes[style].styles[substyle].background[0],
	            substyle: substyle,
	            preview: _this.themes[style].styles[substyle].preview
	          });
	        });
	        return styles;
	      }, []);
	    },
	    filters: function filters() {
	      var _this2 = this;

	      var style = Object.keys(this.themes).reduce(function (obj, style) {
	        if (!Object.keys(obj).length) {
	          obj['all'] = _this2.$t('All styles');
	        }

	        obj[style] = _this2.themes[style].name;
	        return obj;
	      }, {});
	      var color = {
	        all: this.$t('All colors')
	      };
	      var background = {
	        all: this.$t('All backgrounds')
	      };
	      this.styles.forEach(function (style) {
	        color[style.color.toLowerCase()] = style.color;
	        background[style.background.toLowerCase()] = style.background;
	      });
	      return {
	        style: style,
	        color: color,
	        background: background
	      };
	    }
	  },
	  methods: {
	    getImageUrl: function getImageUrl(style) {
	      return style.preview ? "" + this.route + style.preview : this.route + "img/" + style.style + "/" + (style.substyle || 'default') + ".png";
	    },
	    updateFilterStr: function updateFilterStr() {
	      this.filterStr = this.$tc('styles found', Array.prototype.slice.call(this.$refs.styles.children).filter(function (el) {
	        return el.style.display !== 'none';
	      }).length);
	    }
	  },
	  mounted: function mounted() {
	    on(this.$refs.filter, 'afterFilter', this.updateFilterStr);
	  },
	  mixins: [i18n]
	};

	/* script */
	var __vue_script__$u = script$u;
	/* template */

	var __vue_render__$u = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", [_c("button", {
	    staticClass: "uk-modal-close-default",
	    attrs: {
	      type: "button",
	      "data-uk-close": ""
	    }
	  }), _vm._v(" "), _c("div", {
	    staticClass: "uk-modal-header"
	  }, [_c("h2", {
	    staticClass: "uk-modal-title"
	  }, [_vm._v(_vm._s(_vm.title))])]), _vm._v(" "), _c("div", {
	    ref: "filter",
	    staticClass: "uk-modal-body",
	    attrs: {
	      "data-uk-filter": "target: .js-styles-filter"
	    }
	  }, [_c("div", {
	    staticClass: "uk-grid uk-grid-small uk-flex-middle"
	  }, [_c("div", [_c("div", {
	    staticClass: "uk-label"
	  }, [_vm._v(_vm._s(_vm.filterStr))])]), _vm._v(" "), _c("div", {
	    staticClass: "uk-width-expand"
	  }), _vm._v(" "), _c("div", [_c("select", {
	    staticClass: "uk-select",
	    on: {
	      change: function change($event) {
	        _vm.$refs.filterStyle.setAttribute("data-uk-filter-control", $event.target.value);

	        _vm.$refs.filterStyle.click();
	      }
	    }
	  }, _vm._l(_vm.filters.style, function (name, key) {
	    return _c("option", {
	      domProps: {
	        value: "filter: [data-style" + (key === "all" ? "" : "='" + key + "'") + "]; group: data-style"
	      }
	    }, [_vm._v(_vm._s(name))]);
	  }), 0), _vm._v(" "), _c("div", {
	    ref: "filterStyle",
	    attrs: {
	      "data-uk-filter-control": "filter: [data-style]; group: data-style"
	    }
	  })]), _vm._v(" "), _c("div", [_c("select", {
	    staticClass: "uk-select",
	    on: {
	      change: function change($event) {
	        _vm.$refs.filterColor.setAttribute("data-uk-filter-control", $event.target.value);

	        _vm.$refs.filterColor.click();
	      }
	    }
	  }, _vm._l(_vm.filters.color, function (name, key) {
	    return _c("option", {
	      domProps: {
	        value: "filter: [data-color" + (key === "all" ? "" : "='" + key + "'") + "]; group: data-color"
	      }
	    }, [_vm._v(_vm._s(name))]);
	  }), 0), _vm._v(" "), _c("div", {
	    ref: "filterColor",
	    attrs: {
	      "data-uk-filter-control": "filter: [data-color]; group: data-color"
	    }
	  })]), _vm._v(" "), _c("div", [_c("select", {
	    staticClass: "uk-select",
	    on: {
	      change: function change($event) {
	        _vm.$refs.filterBackground.setAttribute("data-uk-filter-control", $event.target.value);

	        _vm.$refs.filterBackground.click();
	      }
	    }
	  }, _vm._l(_vm.filters.background, function (name, key) {
	    return _c("option", {
	      domProps: {
	        value: "filter: [data-background" + (key === "all" ? "" : "='" + key + "'") + "]; group: data-background"
	      }
	    }, [_vm._v(_vm._s(name))]);
	  }), 0), _vm._v(" "), _c("div", {
	    ref: "filterBackground",
	    attrs: {
	      "data-uk-filter-control": "filter: [data-background]; group: data-background"
	    }
	  })])]), _vm._v(" "), _c("ul", {
	    ref: "styles",
	    staticClass: "js-styles-filter uk-grid uk-grid-medium uk-child-width-auto uk-flex-around",
	    attrs: {
	      "data-uk-grid": ""
	    }
	  }, _vm._l(_vm.styles, function (style) {
	    return _c("li", {
	      attrs: {
	        "data-style": style.style,
	        "data-color": style.color.toLowerCase(),
	        "data-background": style.background.toLowerCase()
	      }
	    }, [_c("div", {
	      staticClass: "uk-panel uk-box-shadow-medium uk-box-shadow-hover-large uk-transition-toggle",
	      attrs: {
	        tabindex: "0"
	      }
	    }, [_c("div", {
	      staticClass: "uk-background-cover uk-background-top-center uk-position-cover",
	      attrs: {
	        "data-uk-img": "",
	        "data-src": _vm.getImageUrl(style)
	      }
	    }), _vm._v(" "), _c("canvas", {
	      attrs: {
	        width: "360",
	        height: "254"
	      }
	    }), _vm._v(" "), _c("div", {
	      staticClass: "uk-label uk-position-top-right uk-position-small uk-transition-fade"
	    }, [_vm._v(_vm._s(style.name))]), _vm._v(" "), _c("a", {
	      staticClass: "uk-position-cover",
	      on: {
	        click: function click($event) {
	          $event.preventDefault();
	          return _vm.$emit("resolve", style);
	        }
	      }
	    })])]);
	  }), 0)])]);
	};

	var __vue_staticRenderFns__$u = [];
	__vue_render__$u._withStripped = true;
	/* style */

	var __vue_inject_styles__$u = undefined;
	/* scoped */

	var __vue_scope_id__$u = undefined;
	/* module identifier */

	var __vue_module_identifier__$u = undefined;
	/* functional template */

	var __vue_is_functional_template__$u = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$u = normalizeComponent({
	  render: __vue_render__$u,
	  staticRenderFns: __vue_staticRenderFns__$u
	}, __vue_inject_styles__$u, __vue_script__$u, __vue_scope_id__$u, __vue_is_functional_template__$u, __vue_module_identifier__$u, false, undefined, undefined, undefined);

	var script$v = {
	  props: ['field', 'values'],
	  computed: _extends({}, vuex.mapGetters('styles', ['style', 'substyle', 'themes']), {
	    name: function name() {
	      return this.substyle && this.themes[this.style].styles && this.themes[this.style].styles[this.substyle] ? this.themes[this.style].name + " - " + this.themes[this.style].styles[this.substyle].name : this.themes[this.style].name;
	    },
	    route: function route() {
	      return this.$store.getters.route.ajax.replace('customizer/', 'wa-apps/customizer/plugins/styles/');
	    }
	  }),
	  methods: {
	    select: function select() {
	      var _this = this;

	      this.$modal(__vue_component__$u, {
	        route: this.route,
	        themes: this.themes
	      }).show({
	        width: '2-3@l'
	      }).then(function (style) {
	        if (!style) {
	          return;
	        }

	        _this.$store.commit('styles/setState', {
	          name: 'panels',
	          value: {}
	        });

	        _this.$store.commit('styles/setState', {
	          name: 'vars.@internal-style',
	          value: style.substyle || void 0
	        });

	        if (style.style === _this.style) {
	          _this.$store.dispatch('styles/set');
	        } else {
	          _this.$store.dispatch('styles/get', {
	            style: style.style,
	            substyle: style.substyle
	          });
	        }
	      });
	    }
	  }
	};

	/* script */
	var __vue_script__$v = script$v;
	/* template */

	var __vue_render__$v = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("a", {
	    staticClass: "uk-select uk-link-reset",
	    on: {
	      click: function click($event) {
	        $event.preventDefault();
	        return _vm.select($event);
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.name))]);
	};

	var __vue_staticRenderFns__$v = [];
	__vue_render__$v._withStripped = true;
	/* style */

	var __vue_inject_styles__$v = undefined;
	/* scoped */

	var __vue_scope_id__$v = undefined;
	/* module identifier */

	var __vue_module_identifier__$v = undefined;
	/* functional template */

	var __vue_is_functional_template__$v = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$v = normalizeComponent({
	  render: __vue_render__$v,
	  staticRenderFns: __vue_staticRenderFns__$v
	}, __vue_inject_styles__$v, __vue_script__$v, __vue_scope_id__$v, __vue_is_functional_template__$v, __vue_module_identifier__$v, false, undefined, undefined, undefined);

	//
	var script$w = {
	  components: {
	    FieldEditor: __vue_component__$1,
	    FieldErrorCompatible: __vue_component__$2,
	    FieldGroup: __vue_component__$r,
	    FieldMenu: __vue_component__$s,
	    FieldPreviewComponent: __vue_component__$t,
	    FieldStylesSelect: __vue_component__$v
	  },
	  computed: {
	    fields: function fields() {
	      return this.prepare(this.config.fields || {});
	    }
	  },
	  created: function created() {
	    this.$store.commit('styles/setState', {
	      name: 'tracking',
	      value: false
	    });
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.$nextTick(function () {
	      return _this.$store.commit('styles/setState', {
	        name: 'tracking',
	        value: true
	      });
	    });
	  },
	  mixins: [i18n],
	  "extends": Vue$1.component('fields')
	};

	/* script */
	var __vue_script__$w = script$w;
	/* template */

	var __vue_render__$w = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    staticClass: "customizer-fields styles-fields"
	  }, [_vm._l(_vm.fields, function (field) {
	    return _c("div", {
	      directives: [{
	        name: "show",
	        rawName: "v-show",
	        value: _vm.evaluate(field.show),
	        expression: "evaluate(field.show)"
	      }],
	      key: field.name,
	      staticClass: "customizer-field styles-field"
	    }, [field.label && !~["group-divider"].indexOf(field.type) ? _c("h3", {
	      staticClass: "customizer-field-heading styles-field-heading"
	    }, [_vm._v("\n            " + _vm._s(field.label) + "\n            "), field.badge ? _c("span", {
	      staticClass: "uk-badge customizer-field-badge styles-field-badge"
	    }, [_vm._v(_vm._s(field.badge))]) : _vm._e(), _vm._v(" "), field.tooltip ? _c("span", {
	      staticClass: "customizer-field-tooltip styles-field-tooltip",
	      attrs: {
	        title: field.tooltip,
	        "data-uk-tooltip": "delay: 500"
	      }
	    }, [_vm._v("?")]) : _vm._e(), _vm._v(" "), field.info ? _c("a", {
	      staticClass: "customizer-field-info styles-field-info",
	      attrs: {
	        href: field.info,
	        title: _vm.$t("go to instructions"),
	        target: "_blank"
	      }
	    }, [_vm._v("i")]) : _vm._e()]) : _vm._e(), _vm._v(" "), _c(field.component, {
	      tag: "component",
	      attrs: {
	        field: field,
	        values: _vm.values
	      },
	      on: {
	        change: _vm.change
	      }
	    })], 1);
	  }), _vm._v(" "), _c("transition", {
	    attrs: {
	      "enter-active-class": "uk-transition-fade",
	      "leave-active-class": "uk-transition-fade"
	    }
	  }, [!Object.keys(_vm.fields).length ? _c("div", {
	    staticClass: "uk-position-top uk-position-z-index uk-background-default",
	    staticStyle: {
	      top: "81px"
	    }
	  }, [_c("div", {
	    staticClass: "button-progress-top uk-button uk-button-default uk-button-loading uk-overlay-default uk-width-1-1"
	  }, [_vm._v(" ")])]) : _vm._e()])], 2);
	};

	var __vue_staticRenderFns__$w = [];
	__vue_render__$w._withStripped = true;
	/* style */

	var __vue_inject_styles__$w = undefined;
	/* scoped */

	var __vue_scope_id__$w = undefined;
	/* module identifier */

	var __vue_module_identifier__$w = undefined;
	/* functional template */

	var __vue_is_functional_template__$w = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$w = normalizeComponent({
	  render: __vue_render__$w,
	  staticRenderFns: __vue_staticRenderFns__$w
	}, __vue_inject_styles__$w, __vue_script__$w, __vue_scope_id__$w, __vue_is_functional_template__$w, __vue_module_identifier__$w, false, undefined, undefined, undefined);

	//
	var script$x = {
	  computed: vuex.mapState('styles', ['status', 'changed']),
	  methods: {
	    apply: function apply() {
	      if (this.status === 2) {
	        return;
	      }

	      this.$store.dispatch('styles/set');
	    }
	  },
	  destroyed: function destroyed() {
	    uikitUtil.remove(this.$el);
	  },
	  mixins: [i18n]
	};

	/* script */
	var __vue_script__$x = script$x;
	/* template */

	var __vue_render__$x = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.changed,
	      expression: "changed"
	    }],
	    staticClass: "uk-position-bottom-center uk-position-z-index uk-margin-small uk-box-shadow-large"
	  }, [_c("button", {
	    staticClass: "uk-button uk-button-danger uk-button-small",
	    "class": {
	      "uk-button-sending": _vm.status === 2
	    },
	    attrs: {
	      type: "button"
	    },
	    on: {
	      click: _vm.apply
	    }
	  }, [_vm._v(_vm._s(_vm.$t("Apply")))])]);
	};

	var __vue_staticRenderFns__$x = [];
	__vue_render__$x._withStripped = true;
	/* style */

	var __vue_inject_styles__$x = undefined;
	/* scoped */

	var __vue_scope_id__$x = undefined;
	/* module identifier */

	var __vue_module_identifier__$x = undefined;
	/* functional template */

	var __vue_is_functional_template__$x = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$x = normalizeComponent({
	  render: __vue_render__$x,
	  staticRenderFns: __vue_staticRenderFns__$x
	}, __vue_inject_styles__$x, __vue_script__$x, __vue_scope_id__$x, __vue_is_functional_template__$x, __vue_module_identifier__$x, false, undefined, undefined, undefined);

	//
	var script$y = {
	  mixins: [i18n]
	};

	/* script */
	var __vue_script__$y = script$y;
	/* template */

	var __vue_render__$y = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("div", [_c("div", {
	    staticClass: "uk-modal-header"
	  }, [_c("h2", {
	    staticClass: "uk-modal-title"
	  }, [_vm._v(_vm._s(_vm.$t("Styles changed")))])]), _vm._v(" "), _c("div", {
	    staticClass: "uk-modal-body"
	  }, [_vm._v("\n        " + _vm._s(_vm.$t("Styles have been changed but no changes have been accepted")) + "\n    ")]), _vm._v(" "), _c("div", {
	    staticClass: "uk-modal-footer uk-text-right"
	  }, [_c("button", {
	    staticClass: "uk-button uk-button-default uk-modal-close",
	    attrs: {
	      type: "button"
	    },
	    on: {
	      click: function click($event) {
	        return _vm.$emit("resolve");
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.$t("Close")))]), _vm._v(" "), _c("button", {
	    staticClass: "uk-button uk-button-primary",
	    attrs: {
	      autofocus: ""
	    },
	    on: {
	      click: function click($event) {
	        _vm.$emit("resolve");

	        _vm.$store.dispatch("styles/set", true);
	      }
	    }
	  }, [_vm._v(_vm._s(_vm.$t("Apply")))])])]);
	};

	var __vue_staticRenderFns__$y = [];
	__vue_render__$y._withStripped = true;
	/* style */

	var __vue_inject_styles__$y = undefined;
	/* scoped */

	var __vue_scope_id__$y = undefined;
	/* module identifier */

	var __vue_module_identifier__$y = undefined;
	/* functional template */

	var __vue_is_functional_template__$y = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$y = normalizeComponent({
	  render: __vue_render__$y,
	  staticRenderFns: __vue_staticRenderFns__$y
	}, __vue_inject_styles__$y, __vue_script__$y, __vue_scope_id__$y, __vue_is_functional_template__$y, __vue_module_identifier__$y, false, undefined, undefined, undefined);

	var CUSTOM_CODE$1 = '@custom-code';
	var fields = function fields(state) {
	  return get(state, 'panels.styles.fields', {});
	};
	var panels = function panels(state) {
	  return preparePanels(state.panels);
	};
	var values = function values(state) {
	  return state.values;
	};
	var changed = function changed(state) {
	  return state.changed;
	};
	var tracking = function tracking(state) {
	  return state.tracking;
	};
	var autoApply = function autoApply(state, getters, rootState) {
	  return get(rootState, 'sections.styles.autoApply', false);
	}; // && rootState.status === 4,

	var compatible = function compatible(state, getters, rootState) {
	  return get(rootState, 'sections.styles.compatible', true);
	};
	var messages = function messages(state, getters, rootState) {
	  return get(rootState, 'sections.styles.messages', {});
	};
	var general = function general(state, getters, rootState) {
	  return get(rootState, 'sections.styles.general', {});
	};
	var ignore = function ignore(state, getters, rootState) {
	  return get(rootState, 'sections.styles.ignore', {});
	};
	var groups = function groups(state, getters, rootState) {
	  return get(rootState, 'sections.styles.groups', {});
	};
	var types = function types(state, getters, rootState) {
	  return get(rootState, 'sections.styles.types', {});
	};
	var themes = function themes(state, getters, rootState) {
	  return get(rootState, 'sections.styles.themes', {});
	};
	var vars = function vars(state) {
	  return state.vars;
	};
	var styles$1 = function styles(state) {
	  return state.styles;
	};
	var imports = function imports(state) {
	  return state.imports;
	};
	var style = function style(state) {
	  return state.vars['@internal-theme'];
	};
	var substyle = function substyle(state) {
	  return state.vars['@internal-style'];
	};
	var filename = function filename(state, getters) {
	  return getters.style && state.styles[getters.style] && state.styles[getters.style].filename;
	};
	var diff = function diff(state) {
	  return Object.keys(state.values).filter(function (n) {
	    return n !== CUSTOM_CODE$1;
	  }).reduce(function (diff, name) {
	    // if (name === CUSTOM_CODE || state.variables[name]['value'] !== state.values[name]) {
	    if (state.variables[name]['value'] !== state.values[name]) {
	      diff[name] = state.values[name];
	    } // state.variables[name]['value'] !== state.values[name] && (diff[name] = state.values[name])


	    return diff;
	  }, {});
	};
	var less = function less(state, getters) {
	  var less = '';

	  if (getters.style && getters.styles[getters.style]) {
	    // style code
	    less += getters.styles[getters.style].contents || ''; // add new vars after style code

	    less += Object.keys(getters.vars).filter(function (n) {
	      return n !== CUSTOM_CODE$1;
	    }).reduce(function (less, name) {
	      less += getters.vars[name] ? name + ": " + getters.vars[name] + ";\n" : '';
	      return less;
	    }, ''); // add custom code at end

	    less += getters.vars[CUSTOM_CODE$1] ? getters.vars[CUSTOM_CODE$1] + "\n" : '';
	  }

	  return less;
	};
	var currentPanelName = function currentPanelName(state, getters, rootState, rootGetters) {
	  return rootGetters['sidebar/panel'] && rootGetters['sidebar/panel'].name || void 0;
	}; // export const currentComponent = (state, getters) => getters.currentPanelName in getters.groups ? getters.currentPanelName : 'global'

	var getters = /*#__PURE__*/Object.freeze({
		__proto__: null,
		fields: fields,
		panels: panels,
		values: values,
		changed: changed,
		tracking: tracking,
		autoApply: autoApply,
		compatible: compatible,
		messages: messages,
		general: general,
		ignore: ignore,
		groups: groups,
		types: types,
		themes: themes,
		vars: vars,
		styles: styles$1,
		imports: imports,
		style: style,
		substyle: substyle,
		filename: filename,
		diff: diff,
		less: less,
		currentPanelName: currentPanelName
	});

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//
	function createItem(data) {
	  return {
	    prev: null,
	    next: null,
	    data: data
	  };
	}

	function allocateCursor(node, prev, next) {
	  var cursor;

	  if (cursors !== null) {
	    cursor = cursors;
	    cursors = cursors.cursor;
	    cursor.prev = prev;
	    cursor.next = next;
	    cursor.cursor = node.cursor;
	  } else {
	    cursor = {
	      prev: prev,
	      next: next,
	      cursor: node.cursor
	    };
	  }

	  node.cursor = cursor;
	  return cursor;
	}

	function releaseCursor(node) {
	  var cursor = node.cursor;
	  node.cursor = cursor.cursor;
	  cursor.prev = null;
	  cursor.next = null;
	  cursor.cursor = cursors;
	  cursors = cursor;
	}

	var cursors = null;

	var List = function () {
	  this.cursor = null;
	  this.head = null;
	  this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function (prevOld, prevNew, nextOld, nextNew) {
	  var cursor = this.cursor;

	  while (cursor !== null) {
	    if (cursor.prev === prevOld) {
	      cursor.prev = prevNew;
	    }

	    if (cursor.next === nextOld) {
	      cursor.next = nextNew;
	    }

	    cursor = cursor.cursor;
	  }
	};

	List.prototype.getSize = function () {
	  var size = 0;
	  var cursor = this.head;

	  while (cursor) {
	    size++;
	    cursor = cursor.next;
	  }

	  return size;
	};

	List.prototype.fromArray = function (array) {
	  var cursor = null;
	  this.head = null;

	  for (var i = 0; i < array.length; i++) {
	    var item = createItem(array[i]);

	    if (cursor !== null) {
	      cursor.next = item;
	    } else {
	      this.head = item;
	    }

	    item.prev = cursor;
	    cursor = item;
	  }

	  this.tail = cursor;
	  return this;
	};

	List.prototype.toArray = function () {
	  var cursor = this.head;
	  var result = [];

	  while (cursor) {
	    result.push(cursor.data);
	    cursor = cursor.next;
	  }

	  return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function () {
	  return this.head === null;
	};

	List.prototype.first = function () {
	  return this.head && this.head.data;
	};

	List.prototype.last = function () {
	  return this.tail && this.tail.data;
	};

	List.prototype.each = function (fn, context) {
	  var item;

	  if (context === undefined) {
	    context = this;
	  } // push cursor


	  var cursor = allocateCursor(this, null, this.head);

	  while (cursor.next !== null) {
	    item = cursor.next;
	    cursor.next = item.next;
	    fn.call(context, item.data, item, this);
	  } // pop cursor


	  releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function (fn, context) {
	  var item;

	  if (context === undefined) {
	    context = this;
	  } // push cursor


	  var cursor = allocateCursor(this, this.tail, null);

	  while (cursor.prev !== null) {
	    item = cursor.prev;
	    cursor.prev = item.prev;
	    fn.call(context, item.data, item, this);
	  } // pop cursor


	  releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function (start, fn, context) {
	  if (start === null) {
	    return;
	  }

	  var item;

	  if (context === undefined) {
	    context = this;
	  } // push cursor


	  var cursor = allocateCursor(this, null, start);

	  while (cursor.next !== null) {
	    item = cursor.next;
	    cursor.next = item.next;

	    if (fn.call(context, item.data, item, this)) {
	      break;
	    }
	  } // pop cursor


	  releaseCursor(this);
	};

	List.prototype.prevUntil = function (start, fn, context) {
	  if (start === null) {
	    return;
	  }

	  var item;

	  if (context === undefined) {
	    context = this;
	  } // push cursor


	  var cursor = allocateCursor(this, start, null);

	  while (cursor.prev !== null) {
	    item = cursor.prev;
	    cursor.prev = item.prev;

	    if (fn.call(context, item.data, item, this)) {
	      break;
	    }
	  } // pop cursor


	  releaseCursor(this);
	};

	List.prototype.some = function (fn, context) {
	  var cursor = this.head;

	  if (context === undefined) {
	    context = this;
	  }

	  while (cursor !== null) {
	    if (fn.call(context, cursor.data, cursor, this)) {
	      return true;
	    }

	    cursor = cursor.next;
	  }

	  return false;
	};

	List.prototype.map = function (fn, context) {
	  var result = new List();
	  var cursor = this.head;

	  if (context === undefined) {
	    context = this;
	  }

	  while (cursor !== null) {
	    result.appendData(fn.call(context, cursor.data, cursor, this));
	    cursor = cursor.next;
	  }

	  return result;
	};

	List.prototype.filter = function (fn, context) {
	  var result = new List();
	  var cursor = this.head;

	  if (context === undefined) {
	    context = this;
	  }

	  while (cursor !== null) {
	    if (fn.call(context, cursor.data, cursor, this)) {
	      result.appendData(cursor.data);
	    }

	    cursor = cursor.next;
	  }

	  return result;
	};

	List.prototype.clear = function () {
	  this.head = null;
	  this.tail = null;
	};

	List.prototype.copy = function () {
	  var result = new List();
	  var cursor = this.head;

	  while (cursor !== null) {
	    result.insert(createItem(cursor.data));
	    cursor = cursor.next;
	  }

	  return result;
	};

	List.prototype.prepend = function (item) {
	  //      head
	  //    ^
	  // item
	  this.updateCursors(null, item, this.head, item); // insert to the beginning of the list

	  if (this.head !== null) {
	    // new item <- first item
	    this.head.prev = item; // new item -> first item

	    item.next = this.head;
	  } else {
	    // if list has no head, then it also has no tail
	    // in this case tail points to the new item
	    this.tail = item;
	  } // head always points to new item


	  this.head = item;
	  return this;
	};

	List.prototype.prependData = function (data) {
	  return this.prepend(createItem(data));
	};

	List.prototype.append = function (item) {
	  return this.insert(item);
	};

	List.prototype.appendData = function (data) {
	  return this.insert(createItem(data));
	};

	List.prototype.insert = function (item, before) {
	  if (before !== undefined && before !== null) {
	    // prev   before
	    //      ^
	    //     item
	    this.updateCursors(before.prev, item, before, item);

	    if (before.prev === null) {
	      // insert to the beginning of list
	      if (this.head !== before) {
	        throw new Error('before doesn\'t belong to list');
	      } // since head points to before therefore list doesn't empty
	      // no need to check tail


	      this.head = item;
	      before.prev = item;
	      item.next = before;
	      this.updateCursors(null, item);
	    } else {
	      // insert between two items
	      before.prev.next = item;
	      item.prev = before.prev;
	      before.prev = item;
	      item.next = before;
	    }
	  } else {
	    // tail
	    //      ^
	    //      item
	    this.updateCursors(this.tail, item, null, item); // insert to the ending of the list

	    if (this.tail !== null) {
	      // last item -> new item
	      this.tail.next = item; // last item <- new item

	      item.prev = this.tail;
	    } else {
	      // if list has no tail, then it also has no head
	      // in this case head points to new item
	      this.head = item;
	    } // tail always points to new item


	    this.tail = item;
	  }

	  return this;
	};

	List.prototype.insertData = function (data, before) {
	  return this.insert(createItem(data), before);
	};

	List.prototype.remove = function (item) {
	  //      item
	  //       ^
	  // prev     next
	  this.updateCursors(item, item.prev, item, item.next);

	  if (item.prev !== null) {
	    item.prev.next = item.next;
	  } else {
	    if (this.head !== item) {
	      throw new Error('item doesn\'t belong to list');
	    }

	    this.head = item.next;
	  }

	  if (item.next !== null) {
	    item.next.prev = item.prev;
	  } else {
	    if (this.tail !== item) {
	      throw new Error('item doesn\'t belong to list');
	    }

	    this.tail = item.prev;
	  }

	  item.prev = null;
	  item.next = null;
	  return item;
	};

	List.prototype.push = function (data) {
	  this.insert(createItem(data));
	};

	List.prototype.pop = function () {
	  if (this.tail !== null) {
	    return this.remove(this.tail);
	  }
	};

	List.prototype.unshift = function (data) {
	  this.prepend(createItem(data));
	};

	List.prototype.shift = function () {
	  if (this.head !== null) {
	    return this.remove(this.head);
	  }
	};

	List.prototype.prependList = function (list) {
	  return this.insertList(list, this.head);
	};

	List.prototype.appendList = function (list) {
	  return this.insertList(list);
	};

	List.prototype.insertList = function (list, before) {
	  // ignore empty lists
	  if (list.head === null) {
	    return this;
	  }

	  if (before !== undefined && before !== null) {
	    this.updateCursors(before.prev, list.tail, before, list.head); // insert in the middle of dist list

	    if (before.prev !== null) {
	      // before.prev <-> list.head
	      before.prev.next = list.head;
	      list.head.prev = before.prev;
	    } else {
	      this.head = list.head;
	    }

	    before.prev = list.tail;
	    list.tail.next = before;
	  } else {
	    this.updateCursors(this.tail, list.tail, null, list.head); // insert to end of the list

	    if (this.tail !== null) {
	      // if destination list has a tail, then it also has a head,
	      // but head doesn't change
	      // dest tail -> source head
	      this.tail.next = list.head; // dest tail <- source head

	      list.head.prev = this.tail;
	    } else {
	      // if list has no a tail, then it also has no a head
	      // in this case points head to new item
	      this.head = list.head;
	    } // tail always start point to new item


	    this.tail = list.tail;
	  }

	  list.head = null;
	  list.tail = null;
	  return this;
	};

	List.prototype.replace = function (oldItem, newItemOrList) {
	  if ('head' in newItemOrList) {
	    this.insertList(newItemOrList, oldItem);
	  } else {
	    this.insert(newItemOrList, oldItem);
	  }

	  this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	  // use Object.create(), because some VMs prevent setting line/column otherwise
	  // (iOS Safari 10 even throws an exception)
	  var error = Object.create(SyntaxError.prototype);
	  var errorStack = new Error();
	  error.name = name;
	  error.message = message;
	  Object.defineProperty(error, 'stack', {
	    get: function () {
	      return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	    }
	  });
	  return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	  function processLines(start, end) {
	    return lines.slice(start, end).map(function (line, idx) {
	      var num = String(start + idx + 1);

	      while (num.length < maxNumLength) {
	        num = ' ' + num;
	      }

	      return num + ' |' + line;
	    }).join('\n');
	  }

	  var lines = error.source.split(/\r\n?|\n|\f/);
	  var line = error.line;
	  var column = error.column;
	  var startLine = Math.max(1, line - extraLines) - 1;
	  var endLine = Math.min(line + extraLines, lines.length + 1);
	  var maxNumLength = Math.max(4, String(endLine).length) + 1;
	  var cutLeft = 0; // column correction according to replaced tab before column

	  column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	  if (column > MAX_LINE_LENGTH) {
	    cutLeft = column - OFFSET_CORRECTION + 3;
	    column = OFFSET_CORRECTION - 2;
	  }

	  for (var i = startLine; i <= endLine; i++) {
	    if (i >= 0 && i < lines.length) {
	      lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	      lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	    }
	  }

	  return [processLines(startLine, line), new Array(column + maxNumLength + 2).join('-') + '^', processLines(line, endLine)].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function (message, source, offset, line, column) {
	  var error = createCustomError('SyntaxError', message);
	  error.source = source;
	  error.offset = offset;
	  error.line = line;
	  error.column = column;

	  error.sourceFragment = function (extraLines) {
	    return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	  };

	  Object.defineProperty(error, 'formattedMessage', {
	    get: function () {
	      return 'Parse error: ' + error.message + '\n' + sourceFragment(error, 2);
	    }
	  }); // for backward capability

	  error.parseError = {
	    offset: offset,
	    line: line,
	    column: column
	  };
	  return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	  EOF: 0,
	  // <EOF-token>
	  Ident: 1,
	  // <ident-token>
	  Function: 2,
	  // <function-token>
	  AtKeyword: 3,
	  // <at-keyword-token>
	  Hash: 4,
	  // <hash-token>
	  String: 5,
	  // <string-token>
	  BadString: 6,
	  // <bad-string-token>
	  Url: 7,
	  // <url-token>
	  BadUrl: 8,
	  // <bad-url-token>
	  Delim: 9,
	  // <delim-token>
	  Number: 10,
	  // <number-token>
	  Percentage: 11,
	  // <percentage-token>
	  Dimension: 12,
	  // <dimension-token>
	  WhiteSpace: 13,
	  // <whitespace-token>
	  CDO: 14,
	  // <CDO-token>
	  CDC: 15,
	  // <CDC-token>
	  Colon: 16,
	  // <colon-token>     :
	  Semicolon: 17,
	  // <semicolon-token> ;
	  Comma: 18,
	  // <comma-token>     ,
	  LeftSquareBracket: 19,
	  // <[-token>
	  RightSquareBracket: 20,
	  // <]-token>
	  LeftParenthesis: 21,
	  // <(-token>
	  RightParenthesis: 22,
	  // <)-token>
	  LeftCurlyBracket: 23,
	  // <{-token>
	  RightCurlyBracket: 24,
	  // <}-token>
	  Comment: 25
	};
	var NAME = Object.keys(TYPE).reduce(function (result, key) {
	  result[TYPE[key]] = key;
	  return result;
	}, {});
	var _const = {
	  TYPE: TYPE,
	  NAME: NAME
	};

	var EOF = 0; // https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions
	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).

	function isDigit(code) {
	  return code >= 0x0030 && code <= 0x0039;
	} // hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).


	function isHexDigit(code) {
	  return isDigit(code) || // 0 .. 9
	  code >= 0x0041 && code <= 0x0046 || // A .. F
	  code >= 0x0061 && code <= 0x0066 // a .. f
	  ;
	} // uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).


	function isUppercaseLetter(code) {
	  return code >= 0x0041 && code <= 0x005A;
	} // lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).


	function isLowercaseLetter(code) {
	  return code >= 0x0061 && code <= 0x007A;
	} // letter
	// An uppercase letter or a lowercase letter.


	function isLetter(code) {
	  return isUppercaseLetter(code) || isLowercaseLetter(code);
	} // non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.


	function isNonAscii(code) {
	  return code >= 0x0080;
	} // name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).


	function isNameStart(code) {
	  return isLetter(code) || isNonAscii(code) || code === 0x005F;
	} // name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).


	function isName(code) {
	  return isNameStart(code) || isDigit(code) || code === 0x002D;
	} // non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.


	function isNonPrintable(code) {
	  return code >= 0x0000 && code <= 0x0008 || code === 0x000B || code >= 0x000E && code <= 0x001F || code === 0x007F;
	} // newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED


	function isNewline(code) {
	  return code === 0x000A || code === 0x000D || code === 0x000C;
	} // whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.


	function isWhiteSpace(code) {
	  return isNewline(code) || code === 0x0020 || code === 0x0009;
	} // § 4.3.8. Check if two code points are a valid escape


	function isValidEscape(first, second) {
	  // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	  if (first !== 0x005C) {
	    return false;
	  } // Otherwise, if the second code point is a newline or EOF, return false.


	  if (isNewline(second) || second === EOF) {
	    return false;
	  } // Otherwise, return true.


	  return true;
	} // § 4.3.9. Check if three code points would start an identifier


	function isIdentifierStart(first, second, third) {
	  // Look at the first code point:
	  // U+002D HYPHEN-MINUS
	  if (first === 0x002D) {
	    // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	    // or the second and third code points are a valid escape, return true. Otherwise, return false.
	    return isNameStart(second) || second === 0x002D || isValidEscape(second, third);
	  } // name-start code point


	  if (isNameStart(first)) {
	    // Return true.
	    return true;
	  } // U+005C REVERSE SOLIDUS (\)


	  if (first === 0x005C) {
	    // If the first and second code points are a valid escape, return true. Otherwise, return false.
	    return isValidEscape(first, second);
	  } // anything else
	  // Return false.


	  return false;
	} // § 4.3.10. Check if three code points would start a number


	function isNumberStart(first, second, third) {
	  // Look at the first code point:
	  // U+002B PLUS SIGN (+)
	  // U+002D HYPHEN-MINUS (-)
	  if (first === 0x002B || first === 0x002D) {
	    // If the second code point is a digit, return true.
	    if (isDigit(second)) {
	      return 2;
	    } // Otherwise, if the second code point is a U+002E FULL STOP (.)
	    // and the third code point is a digit, return true.
	    // Otherwise, return false.


	    return second === 0x002E && isDigit(third) ? 3 : 0;
	  } // U+002E FULL STOP (.)


	  if (first === 0x002E) {
	    // If the second code point is a digit, return true. Otherwise, return false.
	    return isDigit(second) ? 2 : 0;
	  } // digit


	  if (isDigit(first)) {
	    // Return true.
	    return 1;
	  } // anything else
	  // Return false.


	  return 0;
	} //
	// Misc
	//
	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)


	function isBOM(code) {
	  // UTF-16BE
	  if (code === 0xFEFF) {
	    return 1;
	  } // UTF-16LE


	  if (code === 0xFFFE) {
	    return 1;
	  }

	  return 0;
	} // Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only


	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	  switch (true) {
	    case isWhiteSpace(i):
	      CATEGORY[i] = charCodeCategory.WhiteSpace;
	      break;

	    case isDigit(i):
	      CATEGORY[i] = charCodeCategory.Digit;
	      break;

	    case isNameStart(i):
	      CATEGORY[i] = charCodeCategory.NameStart;
	      break;

	    case isNonPrintable(i):
	      CATEGORY[i] = charCodeCategory.NonPrintable;
	      break;

	    default:
	      CATEGORY[i] = i || charCodeCategory.Eof;
	  }
	}

	function charCodeCategory(code) {
	  return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	  isDigit: isDigit,
	  isHexDigit: isHexDigit,
	  isUppercaseLetter: isUppercaseLetter,
	  isLowercaseLetter: isLowercaseLetter,
	  isLetter: isLetter,
	  isNonAscii: isNonAscii,
	  isNameStart: isNameStart,
	  isName: isName,
	  isNonPrintable: isNonPrintable,
	  isNewline: isNewline,
	  isWhiteSpace: isWhiteSpace,
	  isValidEscape: isValidEscape,
	  isIdentifierStart: isIdentifierStart,
	  isNumberStart: isNumberStart,
	  isBOM: isBOM,
	  charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	  return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	  if (code === 13
	  /* \r */
	  && getCharCode(source, offset + 1) === 10
	  /* \n */
	  ) {
	      return 2;
	    }

	  return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	  var code = testStr.charCodeAt(offset); // code.toLowerCase() for A..Z

	  if (isUppercaseLetter$1(code)) {
	    code = code | 32;
	  }

	  return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	  if (end - start !== referenceStr.length) {
	    return false;
	  }

	  if (start < 0 || end > testStr.length) {
	    return false;
	  }

	  for (var i = start; i < end; i++) {
	    var testCode = testStr.charCodeAt(i);
	    var referenceCode = referenceStr.charCodeAt(i - start); // testCode.toLowerCase() for A..Z

	    if (isUppercaseLetter$1(testCode)) {
	      testCode = testCode | 32;
	    }

	    if (testCode !== referenceCode) {
	      return false;
	    }
	  }

	  return true;
	}

	function findWhiteSpaceStart(source, offset) {
	  for (; offset >= 0; offset--) {
	    if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	      break;
	    }
	  }

	  return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	  for (; offset < source.length; offset++) {
	    if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	      break;
	    }
	  }

	  return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	  for (; offset < source.length; offset++) {
	    if (!isDigit$1(source.charCodeAt(offset))) {
	      break;
	    }
	  }

	  return offset;
	} // § 4.3.7. Consume an escaped code point


	function consumeEscaped(source, offset) {
	  // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	  // that the next input code point has already been verified to be part of a valid escape.
	  offset += 2; // hex digit

	  if (isHexDigit$1(getCharCode(source, offset - 1))) {
	    // Consume as many hex digits as possible, but no more than 5.
	    // Note that this means 1-6 hex digits have been consumed in total.
	    for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	      if (!isHexDigit$1(getCharCode(source, offset))) {
	        break;
	      }
	    } // If the next input code point is whitespace, consume it as well.


	    var code = getCharCode(source, offset);

	    if (isWhiteSpace$1(code)) {
	      offset += getNewlineLength(source, offset, code);
	    }
	  }

	  return offset;
	} // §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.


	function consumeName(source, offset) {
	  // Let result initially be an empty string.
	  // Repeatedly consume the next input code point from the stream:
	  for (; offset < source.length; offset++) {
	    var code = source.charCodeAt(offset); // name code point

	    if (isName$1(code)) {
	      // Append the code point to result.
	      continue;
	    } // the stream starts with a valid escape


	    if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	      // Consume an escaped code point. Append the returned code point to result.
	      offset = consumeEscaped(source, offset) - 1;
	      continue;
	    } // anything else
	    // Reconsume the current input code point. Return result.


	    break;
	  }

	  return offset;
	} // §4.3.12. Consume a number


	function consumeNumber(source, offset) {
	  var code = source.charCodeAt(offset); // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	  // consume it and append it to repr.

	  if (code === 0x002B || code === 0x002D) {
	    code = source.charCodeAt(offset += 1);
	  } // 3. While the next input code point is a digit, consume it and append it to repr.


	  if (isDigit$1(code)) {
	    offset = findDecimalNumberEnd(source, offset + 1);
	    code = source.charCodeAt(offset);
	  } // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:


	  if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	    // 4.1 Consume them.
	    // 4.2 Append them to repr.
	    code = source.charCodeAt(offset += 2); // 4.3 Set type to "number".
	    // TODO
	    // 4.4 While the next input code point is a digit, consume it and append it to repr.

	    offset = findDecimalNumberEnd(source, offset);
	  } // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	  // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:


	  if (cmpChar(source, offset, 101
	  /* e */
	  )) {
	    var sign = 0;
	    code = source.charCodeAt(offset + 1); // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...

	    if (code === 0x002D || code === 0x002B) {
	      sign = 1;
	      code = source.charCodeAt(offset + 2);
	    } // ... followed by a digit


	    if (isDigit$1(code)) {
	      // 5.1 Consume them.
	      // 5.2 Append them to repr.
	      // 5.3 Set type to "number".
	      // TODO
	      // 5.4 While the next input code point is a digit, consume it and append it to repr.
	      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	    }
	  }

	  return offset;
	} // § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.


	function consumeBadUrlRemnants(source, offset) {
	  // Repeatedly consume the next input code point from the stream:
	  for (; offset < source.length; offset++) {
	    var code = source.charCodeAt(offset); // U+0029 RIGHT PARENTHESIS ())
	    // EOF

	    if (code === 0x0029) {
	      // Return.
	      offset++;
	      break;
	    }

	    if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	      // Consume an escaped code point.
	      // Note: This allows an escaped right parenthesis ("\)") to be encountered
	      // without ending the <bad-url-token>. This is otherwise identical to
	      // the "anything else" clause.
	      offset = consumeEscaped(source, offset);
	    }
	  }

	  return offset;
	}

	var utils = {
	  consumeEscaped: consumeEscaped,
	  consumeName: consumeName,
	  consumeNumber: consumeNumber,
	  consumeBadUrlRemnants: consumeBadUrlRemnants,
	  cmpChar: cmpChar,
	  cmpStr: cmpStr,
	  getNewlineLength: getNewlineLength,
	  findWhiteSpaceStart: findWhiteSpaceStart,
	  findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;
	var cmpStr$1 = utils.cmpStr;
	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;
	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function () {
	  this.offsetAndType = null;
	  this.balance = null;
	  this.reset();
	};

	TokenStream.prototype = {
	  reset: function () {
	    this.eof = false;
	    this.tokenIndex = -1;
	    this.tokenType = 0;
	    this.tokenStart = this.firstCharOffset;
	    this.tokenEnd = this.firstCharOffset;
	  },
	  lookupType: function (offset) {
	    offset += this.tokenIndex;

	    if (offset < this.tokenCount) {
	      return this.offsetAndType[offset] >> TYPE_SHIFT;
	    }

	    return EOF$1;
	  },
	  lookupOffset: function (offset) {
	    offset += this.tokenIndex;

	    if (offset < this.tokenCount) {
	      return this.offsetAndType[offset - 1] & OFFSET_MASK;
	    }

	    return this.source.length;
	  },
	  lookupValue: function (offset, referenceStr) {
	    offset += this.tokenIndex;

	    if (offset < this.tokenCount) {
	      return cmpStr$1(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
	    }

	    return false;
	  },
	  getTokenStart: function (tokenIndex) {
	    if (tokenIndex === this.tokenIndex) {
	      return this.tokenStart;
	    }

	    if (tokenIndex > 0) {
	      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	    }

	    return this.firstCharOffset;
	  },
	  // TODO: -> skipUntilBalanced
	  getRawLength: function (startToken, mode) {
	    var cursor = startToken;
	    var balanceEnd;
	    var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	    var type;

	    loop: for (; cursor < this.tokenCount; cursor++) {
	      balanceEnd = this.balance[cursor]; // stop scanning on balance edge that points to offset before start token

	      if (balanceEnd < startToken) {
	        break loop;
	      }

	      type = this.offsetAndType[cursor] >> TYPE_SHIFT; // check token is stop type

	      switch (mode(type, this.source, offset)) {
	        case 1:
	          break loop;

	        case 2:
	          cursor++;
	          break loop;

	        default:
	          offset = this.offsetAndType[cursor] & OFFSET_MASK; // fast forward to the end of balanced block

	          if (this.balance[balanceEnd] === cursor) {
	            cursor = balanceEnd;
	          }

	      }
	    }

	    return cursor - this.tokenIndex;
	  },
	  isBalanceEdge: function (pos) {
	    return this.balance[this.tokenIndex] < pos;
	  },
	  isDelim: function (code, offset) {
	    if (offset) {
	      return this.lookupType(offset) === TYPE$1.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
	    }

	    return this.tokenType === TYPE$1.Delim && this.source.charCodeAt(this.tokenStart) === code;
	  },
	  getTokenValue: function () {
	    return this.source.substring(this.tokenStart, this.tokenEnd);
	  },
	  getTokenLength: function () {
	    return this.tokenEnd - this.tokenStart;
	  },
	  substrToCursor: function (start) {
	    return this.source.substring(start, this.tokenStart);
	  },
	  skipWS: function () {
	    for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	      if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {
	        break;
	      }
	    }

	    if (skipTokenCount > 0) {
	      this.skip(skipTokenCount);
	    }
	  },
	  skipSC: function () {
	    while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	      this.next();
	    }
	  },
	  skip: function (tokenCount) {
	    var next = this.tokenIndex + tokenCount;

	    if (next < this.tokenCount) {
	      this.tokenIndex = next;
	      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	      next = this.offsetAndType[next];
	      this.tokenType = next >> TYPE_SHIFT;
	      this.tokenEnd = next & OFFSET_MASK;
	    } else {
	      this.tokenIndex = this.tokenCount;
	      this.next();
	    }
	  },
	  next: function () {
	    var next = this.tokenIndex + 1;

	    if (next < this.tokenCount) {
	      this.tokenIndex = next;
	      this.tokenStart = this.tokenEnd;
	      next = this.offsetAndType[next];
	      this.tokenType = next >> TYPE_SHIFT;
	      this.tokenEnd = next & OFFSET_MASK;
	    } else {
	      this.tokenIndex = this.tokenCount;
	      this.eof = true;
	      this.tokenType = EOF$1;
	      this.tokenStart = this.tokenEnd = this.source.length;
	    }
	  },
	  dump: function () {
	    var offset = this.firstCharOffset;
	    return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function (item, idx) {
	      var start = offset;
	      var end = item & OFFSET_MASK;
	      offset = end;
	      return {
	        idx: idx,
	        type: NAME$1[item >> TYPE_SHIFT],
	        chunk: this.source.substring(start, end),
	        balance: this.balance[idx]
	      };
	    }, this);
	  }
	};
	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	  return value;
	}

	function generateMultiplier(multiplier) {
	  if (multiplier.min === 0 && multiplier.max === 0) {
	    return '*';
	  }

	  if (multiplier.min === 0 && multiplier.max === 1) {
	    return '?';
	  }

	  if (multiplier.min === 1 && multiplier.max === 0) {
	    return multiplier.comma ? '#' : '+';
	  }

	  if (multiplier.min === 1 && multiplier.max === 1) {
	    return '';
	  }

	  return (multiplier.comma ? '#' : '') + (multiplier.min === multiplier.max ? '{' + multiplier.min + '}' : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}');
	}

	function generateTypeOpts(node) {
	  switch (node.type) {
	    case 'Range':
	      return ' [' + (node.min === null ? '-∞' : node.min) + ',' + (node.max === null ? '∞' : node.max) + ']';

	    default:
	      throw new Error('Unknown node type `' + node.type + '`');
	  }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	  var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	  var result = node.terms.map(function (term) {
	    return generate(term, decorate, forceBraces, compact);
	  }).join(combinator);

	  if (node.explicit || forceBraces) {
	    result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	  }

	  return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	  var result;

	  switch (node.type) {
	    case 'Group':
	      result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? '!' : '');
	      break;

	    case 'Multiplier':
	      // return since node is a composition
	      return generate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);

	    case 'Type':
	      result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	      break;

	    case 'Property':
	      result = '<\'' + node.name + '\'>';
	      break;

	    case 'Keyword':
	      result = node.name;
	      break;

	    case 'AtKeyword':
	      result = '@' + node.name;
	      break;

	    case 'Function':
	      result = node.name + '(';
	      break;

	    case 'String':
	    case 'Token':
	      result = node.value;
	      break;

	    case 'Comma':
	      result = ',';
	      break;

	    default:
	      throw new Error('Unknown node type `' + node.type + '`');
	  }

	  return decorate(result, node);
	}

	var generate_1 = function (node, options) {
	  var decorate = noop$1;
	  var forceBraces = false;
	  var compact = false;

	  if (typeof options === 'function') {
	    decorate = options;
	  } else if (options) {
	    forceBraces = Boolean(options.forceBraces);
	    compact = Boolean(options.compact);

	    if (typeof options.decorate === 'function') {
	      decorate = options.decorate;
	    }
	  }

	  return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	  var tokens = matchResult.tokens;
	  var longestMatch = matchResult.longestMatch;
	  var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	  var mismatchOffset = -1;
	  var entries = 0;
	  var css = '';

	  for (var i = 0; i < tokens.length; i++) {
	    if (i === longestMatch) {
	      mismatchOffset = css.length;
	    }

	    if (node !== null && tokens[i].node === node) {
	      if (i <= longestMatch) {
	        entries++;
	      } else {
	        entries = 0;
	      }
	    }

	    css += tokens[i].value;
	  }

	  return {
	    node: node,
	    css: css,
	    mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	    last: node === null || entries > 1
	  };
	}

	function getLocation(node, point) {
	  var loc = node && node.loc && node.loc[point];

	  if (loc) {
	    return {
	      offset: loc.offset,
	      line: loc.line,
	      column: loc.column
	    };
	  }

	  return null;
	}

	var SyntaxReferenceError = function (type, referenceName) {
	  var error = createCustomError('SyntaxReferenceError', type + (referenceName ? ' `' + referenceName + '`' : ''));
	  error.reference = referenceName;
	  return error;
	};

	var MatchError = function (message, syntax, node, matchResult) {
	  var error = createCustomError('SyntaxMatchError', message);
	  var details = fromMatchResult(matchResult);
	  var mismatchOffset = details.mismatchOffset || 0;
	  var badNode = details.node || node;
	  var end = getLocation(badNode, 'end');
	  var start = details.last ? end : getLocation(badNode, 'start');
	  var css = details.css;
	  error.rawMessage = message;
	  error.syntax = syntax ? generate_1(syntax) : '<generic>';
	  error.css = css;
	  error.mismatchOffset = mismatchOffset;
	  error.loc = {
	    source: badNode && badNode.loc && badNode.loc.source || '<unknown>',
	    start: start,
	    end: end
	  };
	  error.line = start ? start.line : undefined;
	  error.column = start ? start.column : undefined;
	  error.offset = start ? start.offset : undefined;
	  error.message = message + '\n' + '  syntax: ' + error.syntax + '\n' + '   value: ' + (error.css || '<empty string>') + '\n' + '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';
	  return error;
	};

	var error$1 = {
	  SyntaxReferenceError: SyntaxReferenceError,
	  MatchError: MatchError
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	  offset = offset || 0;
	  return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	  offset = offset || 0; // verdor prefix should be at least 3 chars length

	  if (str.length - offset >= 3) {
	    // vendor prefix starts with hyper minus following non-hyper minus
	    if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	      // vendor prefix should contain a hyper minus at the ending
	      var secondDashIndex = str.indexOf('-', offset + 2);

	      if (secondDashIndex !== -1) {
	        return str.substring(offset, secondDashIndex + 1);
	      }
	    }
	  }

	  return '';
	}

	function getKeywordDescriptor(keyword) {
	  if (hasOwnProperty$1.call(keywords, keyword)) {
	    return keywords[keyword];
	  }

	  var name = keyword.toLowerCase();

	  if (hasOwnProperty$1.call(keywords, name)) {
	    return keywords[keyword] = keywords[name];
	  }

	  var custom = isCustomProperty(name, 0);
	  var vendor = !custom ? getVendorPrefix(name, 0) : '';
	  return keywords[keyword] = Object.freeze({
	    basename: name.substr(vendor.length),
	    name: name,
	    vendor: vendor,
	    prefix: vendor,
	    custom: custom
	  });
	}

	function getPropertyDescriptor(property) {
	  if (hasOwnProperty$1.call(properties, property)) {
	    return properties[property];
	  }

	  var name = property;
	  var hack = property[0];

	  if (hack === '/') {
	    hack = property[1] === '/' ? '//' : '/';
	  } else if (hack !== '_' && hack !== '*' && hack !== '$' && hack !== '#' && hack !== '+' && hack !== '&') {
	    hack = '';
	  }

	  var custom = isCustomProperty(name, hack.length); // re-use result when possible (the same as for lower case)

	  if (!custom) {
	    name = name.toLowerCase();

	    if (hasOwnProperty$1.call(properties, name)) {
	      return properties[property] = properties[name];
	    }
	  }

	  var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	  var prefix = name.substr(0, hack.length + vendor.length);
	  return properties[property] = Object.freeze({
	    basename: name.substr(prefix.length),
	    name: name.substr(hack.length),
	    hack: hack,
	    vendor: vendor,
	    prefix: prefix,
	    custom: custom
	  });
	}

	var names = {
	  keyword: getKeywordDescriptor,
	  property: getPropertyDescriptor,
	  isCustomProperty: isCustomProperty,
	  vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	  if (buffer === null || buffer.length < size) {
	    return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	  }

	  return buffer;
	};

	var TYPE$2 = _const.TYPE;
	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;
	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;
	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	  function getCharCode(offset) {
	    return offset < sourceLength ? source.charCodeAt(offset) : 0;
	  } // § 4.3.3. Consume a numeric token


	  function consumeNumericToken() {
	    // Consume a number and let number be the result.
	    offset = consumeNumber$1(source, offset); // If the next 3 input code points would start an identifier, then:

	    if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	      // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	      // Consume a name. Set the <dimension-token>’s unit to the returned value.
	      // Return the <dimension-token>.
	      type = TYPE$2.Dimension;
	      offset = consumeName$1(source, offset);
	      return;
	    } // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.


	    if (getCharCode(offset) === 0x0025) {
	      // Create a <percentage-token> with the same value as number, and return it.
	      type = TYPE$2.Percentage;
	      offset++;
	      return;
	    } // Otherwise, create a <number-token> with the same value and type flag as number, and return it.


	    type = TYPE$2.Number;
	  } // § 4.3.4. Consume an ident-like token


	  function consumeIdentLikeToken() {
	    const nameStartOffset = offset; // Consume a name, and let string be the result.

	    offset = consumeName$1(source, offset); // If string’s value is an ASCII case-insensitive match for "url",
	    // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.

	    if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	      // While the next two input code points are whitespace, consume the next input code point.
	      offset = findWhiteSpaceEnd$1(source, offset + 1); // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	      // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	      // then create a <function-token> with its value set to string and return it.

	      if (getCharCode(offset) === 0x0022 || getCharCode(offset) === 0x0027) {
	        type = TYPE$2.Function;
	        offset = nameStartOffset + 4;
	        return;
	      } // Otherwise, consume a url token, and return it.


	      consumeUrlToken();
	      return;
	    } // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	    // Create a <function-token> with its value set to string and return it.


	    if (getCharCode(offset) === 0x0028) {
	      type = TYPE$2.Function;
	      offset++;
	      return;
	    } // Otherwise, create an <ident-token> with its value set to string and return it.


	    type = TYPE$2.Ident;
	  } // § 4.3.5. Consume a string token


	  function consumeStringToken(endingCodePoint) {
	    // This algorithm may be called with an ending code point, which denotes the code point
	    // that ends the string. If an ending code point is not specified,
	    // the current input code point is used.
	    if (!endingCodePoint) {
	      endingCodePoint = getCharCode(offset++);
	    } // Initially create a <string-token> with its value set to the empty string.


	    type = TYPE$2.String; // Repeatedly consume the next input code point from the stream:

	    for (; offset < source.length; offset++) {
	      var code = source.charCodeAt(offset);

	      switch (charCodeCategory$1(code)) {
	        // ending code point
	        case endingCodePoint:
	          // Return the <string-token>.
	          offset++;
	          return;
	        // EOF

	        case charCodeCategory$1.Eof:
	          // This is a parse error. Return the <string-token>.
	          return;
	        // newline

	        case charCodeCategory$1.WhiteSpace:
	          if (isNewline$1(code)) {
	            // This is a parse error. Reconsume the current input code point,
	            // create a <bad-string-token>, and return it.
	            offset += getNewlineLength$1(source, offset, code);
	            type = TYPE$2.BadString;
	            return;
	          }

	          break;
	        // U+005C REVERSE SOLIDUS (\)

	        case 0x005C:
	          // If the next input code point is EOF, do nothing.
	          if (offset === source.length - 1) {
	            break;
	          }

	          var nextCode = getCharCode(offset + 1); // Otherwise, if the next input code point is a newline, consume it.

	          if (isNewline$1(nextCode)) {
	            offset += getNewlineLength$1(source, offset + 1, nextCode);
	          } else if (isValidEscape$2(code, nextCode)) {
	            // Otherwise, (the stream starts with a valid escape) consume
	            // an escaped code point and append the returned code point to
	            // the <string-token>’s value.
	            offset = consumeEscaped$1(source, offset) - 1;
	          }

	          break;
	        // anything else
	        // Append the current input code point to the <string-token>’s value.
	      }
	    }
	  } // § 4.3.6. Consume a url token
	  // Note: This algorithm assumes that the initial "url(" has already been consumed.
	  // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	  // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	  // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.


	  function consumeUrlToken() {
	    // Initially create a <url-token> with its value set to the empty string.
	    type = TYPE$2.Url; // Consume as much whitespace as possible.

	    offset = findWhiteSpaceEnd$1(source, offset); // Repeatedly consume the next input code point from the stream:

	    for (; offset < source.length; offset++) {
	      var code = source.charCodeAt(offset);

	      switch (charCodeCategory$1(code)) {
	        // U+0029 RIGHT PARENTHESIS ())
	        case 0x0029:
	          // Return the <url-token>.
	          offset++;
	          return;
	        // EOF

	        case charCodeCategory$1.Eof:
	          // This is a parse error. Return the <url-token>.
	          return;
	        // whitespace

	        case charCodeCategory$1.WhiteSpace:
	          // Consume as much whitespace as possible.
	          offset = findWhiteSpaceEnd$1(source, offset); // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	          // consume it and return the <url-token>
	          // (if EOF was encountered, this is a parse error);

	          if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	            if (offset < source.length) {
	              offset++;
	            }

	            return;
	          } // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	          // and return it.


	          offset = consumeBadUrlRemnants$1(source, offset);
	          type = TYPE$2.BadUrl;
	          return;
	        // U+0022 QUOTATION MARK (")
	        // U+0027 APOSTROPHE (')
	        // U+0028 LEFT PARENTHESIS (()
	        // non-printable code point

	        case 0x0022:
	        case 0x0027:
	        case 0x0028:
	        case charCodeCategory$1.NonPrintable:
	          // This is a parse error. Consume the remnants of a bad url,
	          // create a <bad-url-token>, and return it.
	          offset = consumeBadUrlRemnants$1(source, offset);
	          type = TYPE$2.BadUrl;
	          return;
	        // U+005C REVERSE SOLIDUS (\)

	        case 0x005C:
	          // If the stream starts with a valid escape, consume an escaped code point and
	          // append the returned code point to the <url-token>’s value.
	          if (isValidEscape$2(code, getCharCode(offset + 1))) {
	            offset = consumeEscaped$1(source, offset) - 1;
	            break;
	          } // Otherwise, this is a parse error. Consume the remnants of a bad url,
	          // create a <bad-url-token>, and return it.


	          offset = consumeBadUrlRemnants$1(source, offset);
	          type = TYPE$2.BadUrl;
	          return;
	        // anything else
	        // Append the current input code point to the <url-token>’s value.
	      }
	    }
	  }

	  if (!stream) {
	    stream = new TokenStream_1();
	  } // ensure source is a string


	  source = String(source || '');
	  var sourceLength = source.length;
	  var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token

	  var balance = adoptBuffer(stream.balance, sourceLength + 1);
	  var tokenCount = 0;
	  var start = isBOM$1(getCharCode(0));
	  var offset = start;
	  var balanceCloseType = 0;
	  var balanceStart = 0;
	  var balancePrev = 0; // https://drafts.csswg.org/css-syntax-3/#consume-token
	  // § 4.3.1. Consume a token

	  while (offset < sourceLength) {
	    var code = source.charCodeAt(offset);
	    var type = 0;
	    balance[tokenCount] = sourceLength;

	    switch (charCodeCategory$1(code)) {
	      // whitespace
	      case charCodeCategory$1.WhiteSpace:
	        // Consume as much whitespace as possible. Return a <whitespace-token>.
	        type = TYPE$2.WhiteSpace;
	        offset = findWhiteSpaceEnd$1(source, offset + 1);
	        break;
	      // U+0022 QUOTATION MARK (")

	      case 0x0022:
	        // Consume a string token and return it.
	        consumeStringToken();
	        break;
	      // U+0023 NUMBER SIGN (#)

	      case 0x0023:
	        // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	        if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	          // Create a <hash-token>.
	          type = TYPE$2.Hash; // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	          // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	          //     // TODO: set id flag
	          // }
	          // Consume a name, and set the <hash-token>’s value to the returned string.

	          offset = consumeName$1(source, offset + 1); // Return the <hash-token>.
	        } else {
	          // Otherwise, return a <delim-token> with its value set to the current input code point.
	          type = TYPE$2.Delim;
	          offset++;
	        }

	        break;
	      // U+0027 APOSTROPHE (')

	      case 0x0027:
	        // Consume a string token and return it.
	        consumeStringToken();
	        break;
	      // U+0028 LEFT PARENTHESIS (()

	      case 0x0028:
	        // Return a <(-token>.
	        type = TYPE$2.LeftParenthesis;
	        offset++;
	        break;
	      // U+0029 RIGHT PARENTHESIS ())

	      case 0x0029:
	        // Return a <)-token>.
	        type = TYPE$2.RightParenthesis;
	        offset++;
	        break;
	      // U+002B PLUS SIGN (+)

	      case 0x002B:
	        // If the input stream starts with a number, ...
	        if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	          // ... reconsume the current input code point, consume a numeric token, and return it.
	          consumeNumericToken();
	        } else {
	          // Otherwise, return a <delim-token> with its value set to the current input code point.
	          type = TYPE$2.Delim;
	          offset++;
	        }

	        break;
	      // U+002C COMMA (,)

	      case 0x002C:
	        // Return a <comma-token>.
	        type = TYPE$2.Comma;
	        offset++;
	        break;
	      // U+002D HYPHEN-MINUS (-)

	      case 0x002D:
	        // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	        if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	          consumeNumericToken();
	        } else {
	          // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	          if (getCharCode(offset + 1) === 0x002D && getCharCode(offset + 2) === 0x003E) {
	            type = TYPE$2.CDC;
	            offset = offset + 3;
	          } else {
	            // Otherwise, if the input stream starts with an identifier, ...
	            if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	              // ... reconsume the current input code point, consume an ident-like token, and return it.
	              consumeIdentLikeToken();
	            } else {
	              // Otherwise, return a <delim-token> with its value set to the current input code point.
	              type = TYPE$2.Delim;
	              offset++;
	            }
	          }
	        }

	        break;
	      // U+002E FULL STOP (.)

	      case 0x002E:
	        // If the input stream starts with a number, ...
	        if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	          // ... reconsume the current input code point, consume a numeric token, and return it.
	          consumeNumericToken();
	        } else {
	          // Otherwise, return a <delim-token> with its value set to the current input code point.
	          type = TYPE$2.Delim;
	          offset++;
	        }

	        break;
	      // U+002F SOLIDUS (/)

	      case 0x002F:
	        // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	        if (getCharCode(offset + 1) === 0x002A) {
	          // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	          // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	          type = TYPE$2.Comment;
	          offset = source.indexOf('*/', offset + 2) + 2;

	          if (offset === 1) {
	            offset = source.length;
	          }
	        } else {
	          type = TYPE$2.Delim;
	          offset++;
	        }

	        break;
	      // U+003A COLON (:)

	      case 0x003A:
	        // Return a <colon-token>.
	        type = TYPE$2.Colon;
	        offset++;
	        break;
	      // U+003B SEMICOLON (;)

	      case 0x003B:
	        // Return a <semicolon-token>.
	        type = TYPE$2.Semicolon;
	        offset++;
	        break;
	      // U+003C LESS-THAN SIGN (<)

	      case 0x003C:
	        // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	        if (getCharCode(offset + 1) === 0x0021 && getCharCode(offset + 2) === 0x002D && getCharCode(offset + 3) === 0x002D) {
	          // ... consume them and return a <CDO-token>.
	          type = TYPE$2.CDO;
	          offset = offset + 4;
	        } else {
	          // Otherwise, return a <delim-token> with its value set to the current input code point.
	          type = TYPE$2.Delim;
	          offset++;
	        }

	        break;
	      // U+0040 COMMERCIAL AT (@)

	      case 0x0040:
	        // If the next 3 input code points would start an identifier, ...
	        if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	          // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	          type = TYPE$2.AtKeyword;
	          offset = consumeName$1(source, offset + 1);
	        } else {
	          // Otherwise, return a <delim-token> with its value set to the current input code point.
	          type = TYPE$2.Delim;
	          offset++;
	        }

	        break;
	      // U+005B LEFT SQUARE BRACKET ([)

	      case 0x005B:
	        // Return a <[-token>.
	        type = TYPE$2.LeftSquareBracket;
	        offset++;
	        break;
	      // U+005C REVERSE SOLIDUS (\)

	      case 0x005C:
	        // If the input stream starts with a valid escape, ...
	        if (isValidEscape$2(code, getCharCode(offset + 1))) {
	          // ... reconsume the current input code point, consume an ident-like token, and return it.
	          consumeIdentLikeToken();
	        } else {
	          // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	          type = TYPE$2.Delim;
	          offset++;
	        }

	        break;
	      // U+005D RIGHT SQUARE BRACKET (])

	      case 0x005D:
	        // Return a <]-token>.
	        type = TYPE$2.RightSquareBracket;
	        offset++;
	        break;
	      // U+007B LEFT CURLY BRACKET ({)

	      case 0x007B:
	        // Return a <{-token>.
	        type = TYPE$2.LeftCurlyBracket;
	        offset++;
	        break;
	      // U+007D RIGHT CURLY BRACKET (})

	      case 0x007D:
	        // Return a <}-token>.
	        type = TYPE$2.RightCurlyBracket;
	        offset++;
	        break;
	      // digit

	      case charCodeCategory$1.Digit:
	        // Reconsume the current input code point, consume a numeric token, and return it.
	        consumeNumericToken();
	        break;
	      // name-start code point

	      case charCodeCategory$1.NameStart:
	        // Reconsume the current input code point, consume an ident-like token, and return it.
	        consumeIdentLikeToken();
	        break;
	      // EOF

	      case charCodeCategory$1.Eof:
	        // Return an <EOF-token>.
	        break;
	      // anything else

	      default:
	        // Return a <delim-token> with its value set to the current input code point.
	        type = TYPE$2.Delim;
	        offset++;
	    }

	    switch (type) {
	      case balanceCloseType:
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	        balance[tokenCount] = balancePrev;
	        balance[balancePrev++] = tokenCount;

	        for (; balancePrev < tokenCount; balancePrev++) {
	          if (balance[balancePrev] === sourceLength) {
	            balance[balancePrev] = tokenCount;
	          }
	        }

	        break;

	      case TYPE$2.LeftParenthesis:
	      case TYPE$2.Function:
	        balance[tokenCount] = balanceStart;
	        balanceCloseType = TYPE$2.RightParenthesis;
	        balanceStart = balanceCloseType << TYPE_SHIFT$1 | tokenCount;
	        break;

	      case TYPE$2.LeftSquareBracket:
	        balance[tokenCount] = balanceStart;
	        balanceCloseType = TYPE$2.RightSquareBracket;
	        balanceStart = balanceCloseType << TYPE_SHIFT$1 | tokenCount;
	        break;

	      case TYPE$2.LeftCurlyBracket:
	        balance[tokenCount] = balanceStart;
	        balanceCloseType = TYPE$2.RightCurlyBracket;
	        balanceStart = balanceCloseType << TYPE_SHIFT$1 | tokenCount;
	        break;
	    }

	    offsetAndType[tokenCount++] = type << TYPE_SHIFT$1 | offset;
	  } // finalize buffers


	  offsetAndType[tokenCount] = TYPE$2.EOF << TYPE_SHIFT$1 | offset; // <EOF-token>

	  balance[tokenCount] = sourceLength;
	  balance[sourceLength] = sourceLength; // prevents false positive balance match with any token

	  while (balanceStart !== 0) {
	    balancePrev = balanceStart & OFFSET_MASK$1;
	    balanceStart = balance[balancePrev];
	    balance[balancePrev] = sourceLength;
	  } // update stream


	  stream.source = source;
	  stream.firstCharOffset = start;
	  stream.offsetAndType = offsetAndType;
	  stream.tokenCount = tokenCount;
	  stream.balance = balance;
	  stream.reset();
	  stream.next();
	  return stream;
	} // extend tokenizer with constants


	Object.keys(_const).forEach(function (key) {
	  tokenize[key] = _const[key];
	}); // extend tokenizer with static methods from utils

	Object.keys(charCodeDefinitions).forEach(function (key) {
	  tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function (key) {
	  tokenize[key] = utils[key];
	});
	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;
	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)

	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)

	var N = 0x006E; // U+006E LATIN SMALL LETTER N (n)

	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	  return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	  while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	    token = getNextToken(++offset);
	  }

	  return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	  if (!token) {
	    return 0;
	  }

	  var code = token.value.charCodeAt(valueOffset);

	  if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	    if (disallowSign) {
	      // Number sign is not allowed
	      return 0;
	    }

	    valueOffset++;
	  }

	  for (; valueOffset < token.value.length; valueOffset++) {
	    if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	      // Integer is expected
	      return 0;
	    }
	  }

	  return offset + 1;
	} // ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>


	function consumeB(token, offset_, getNextToken) {
	  var sign = false;
	  var offset = skipSC(token, offset_, getNextToken);
	  token = getNextToken(offset);

	  if (token === null) {
	    return offset_;
	  }

	  if (token.type !== NUMBER) {
	    if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	      sign = true;
	      offset = skipSC(getNextToken(++offset), offset, getNextToken);
	      token = getNextToken(offset);

	      if (token === null && token.type !== NUMBER) {
	        return 0;
	      }
	    } else {
	      return offset_;
	    }
	  }

	  if (!sign) {
	    var code = token.value.charCodeAt(0);

	    if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	      // Number sign is expected
	      return 0;
	    }
	  }

	  return checkInteger(token, sign ? 0 : 1, sign, offset);
	} // An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb


	var genericAnPlusB = function anPlusB(token, getNextToken) {
	  /* eslint-disable brace-style*/
	  var offset = 0;

	  if (!token) {
	    return 0;
	  } // <integer>


	  if (token.type === NUMBER) {
	    return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	  } // -n
	  // -n <signed-integer>
	  // -n ['+' | '-'] <signless-integer>
	  // -n- <signless-integer>
	  // <dashndashdigit-ident>
	  else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	      // expect 1st char is N
	      if (!cmpChar$1(token.value, 1, N)) {
	        return 0;
	      }

	      switch (token.value.length) {
	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        case 2:
	          return consumeB(getNextToken(++offset), offset, getNextToken);
	        // -n- <signless-integer>

	        case 3:
	          if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	            return 0;
	          }

	          offset = skipSC(getNextToken(++offset), offset, getNextToken);
	          token = getNextToken(offset);
	          return checkInteger(token, 0, DISALLOW_SIGN, offset);
	        // <dashndashdigit-ident>

	        default:
	          if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	            return 0;
	          }

	          return checkInteger(token, 3, DISALLOW_SIGN, offset);
	      }
	    } // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	          token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	          return 0;
	        }

	        switch (token.value.length) {
	          // '+'? n
	          // '+'? n <signed-integer>
	          // '+'? n ['+' | '-'] <signless-integer>
	          case 1:
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	          // '+'? n- <signless-integer>

	          case 2:
	            if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	              return 0;
	            }

	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);
	            return checkInteger(token, 0, DISALLOW_SIGN, offset);
	          // '+'? <ndashdigit-ident>

	          default:
	            if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	              return 0;
	            }

	            return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	      } // <ndashdigit-dimension>
	      // <ndash-dimension> <signless-integer>
	      // <n-dimension>
	      // <n-dimension> <signed-integer>
	      // <n-dimension> ['+' | '-'] <signless-integer>
	      else if (token.type === DIMENSION) {
	          var code = token.value.charCodeAt(0);
	          var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	          for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	              break;
	            }
	          }

	          if (i === sign) {
	            // Integer is expected
	            return 0;
	          }

	          if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	          } // <n-dimension>
	          // <n-dimension> <signed-integer>
	          // <n-dimension> ['+' | '-'] <signless-integer>


	          if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	          } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	              return 0;
	            } // <ndash-dimension> <signless-integer>


	            if (i + 2 === token.value.length) {
	              offset = skipSC(getNextToken(++offset), offset, getNextToken);
	              token = getNextToken(offset);
	              return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            } // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	              }
	          }
	        }

	  return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;
	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B; // U+002B PLUS SIGN (+)

	var HYPHENMINUS$2 = 0x002D; // U+002D HYPHEN-MINUS (-)

	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)

	var U = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	  return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith$1(token, code) {
	  return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	  for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	    var code = token.value.charCodeAt(pos);

	    if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	      if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	        return 6; // dissallow following question marks
	      }

	      return 0; // dash at the ending of a hex sequence is not allowed
	    }

	    if (!isHexDigit$2(code)) {
	      return 0; // not a hex digit
	    }

	    if (++hexlen > 6) {
	      return 0; // too many hex digits
	    }
	  }

	  return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	  if (!consumed) {
	    return 0; // nothing consumed
	  }

	  while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	    if (++consumed > 6) {
	      return 0; // too many question marks
	    }

	    length++;
	  }

	  return length;
	} // https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+


	var genericUrange = function urange(token, getNextToken) {
	  var length = 0; // should start with `u` or `U`

	  if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	    return 0;
	  }

	  token = getNextToken(++length);

	  if (token === null) {
	    return 0;
	  } // u '+' <ident-token> '?'*
	  // u '+' '?'+


	  if (isDelim$1(token, PLUSSIGN$1)) {
	    token = getNextToken(++length);

	    if (token === null) {
	      return 0;
	    }

	    if (token.type === IDENT$1) {
	      // u '+' <ident-token> '?'*
	      return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	    }

	    if (isDelim$1(token, QUESTIONMARK)) {
	      // u '+' '?'+
	      return withQuestionMarkSequence(1, ++length, getNextToken);
	    } // Hex digit or question mark is expected


	    return 0;
	  } // u <number-token> '?'*
	  // u <number-token> <dimension-token>
	  // u <number-token> <number-token>


	  if (token.type === NUMBER$1) {
	    if (!startsWith$1(token, PLUSSIGN$1)) {
	      return 0;
	    }

	    var consumedHexLength = hexSequence(token, 1, true);

	    if (consumedHexLength === 0) {
	      return 0;
	    }

	    token = getNextToken(++length);

	    if (token === null) {
	      // u <number-token> <eof>
	      return length;
	    }

	    if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	      // u <number-token> <dimension-token>
	      // u <number-token> <number-token>
	      if (!startsWith$1(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	        return 0;
	      }

	      return length + 1;
	    } // u <number-token> '?'*


	    return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	  } // u <dimension-token> '?'*


	  if (token.type === DIMENSION$1) {
	    if (!startsWith$1(token, PLUSSIGN$1)) {
	      return 0;
	    }

	    return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	  }

	  return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;
	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc(']; // https://www.w3.org/TR/css-values-3/#lengths

	var LENGTH = {
	  // absolute length units
	  'px': true,
	  'mm': true,
	  'cm': true,
	  'in': true,
	  'pt': true,
	  'pc': true,
	  'q': true,
	  // relative length units
	  'em': true,
	  'ex': true,
	  'ch': true,
	  'rem': true,
	  // viewport-percentage lengths
	  'vh': true,
	  'vw': true,
	  'vmin': true,
	  'vmax': true,
	  'vm': true
	};
	var ANGLE = {
	  'deg': true,
	  'grad': true,
	  'rad': true,
	  'turn': true
	};
	var TIME = {
	  's': true,
	  'ms': true
	};
	var FREQUENCY = {
	  'hz': true,
	  'khz': true
	}; // https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)

	var RESOLUTION = {
	  'dpi': true,
	  'dpcm': true,
	  'dppx': true,
	  'x': true // https://github.com/w3c/csswg-drafts/issues/461

	}; // https://drafts.csswg.org/css-grid/#fr-unit

	var FLEX = {
	  'fr': true
	}; // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume

	var DECIBEL = {
	  'db': true
	}; // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch

	var SEMITONES = {
	  'st': true
	}; // safe char code getter

	function charCode(str, index) {
	  return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	  return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	  for (var i = 0; i < expected.length; i++) {
	    if (eqStr(actual, expected[i])) {
	      return true;
	    }
	  }

	  return false;
	} // IE postfix hack, i.e. 123\0 or 123px\9


	function isPostfixIeHack(str, offset) {
	  if (offset !== str.length - 2) {
	    return false;
	  }

	  return str.charCodeAt(offset) === 0x005C && // U+005C REVERSE SOLIDUS (\)
	  isDigit$3(str.charCodeAt(offset + 1));
	}

	function outOfRange(opts, value, numEnd) {
	  if (opts && opts.type === 'Range') {
	    var num = Number(numEnd !== undefined && numEnd !== value.length ? value.substr(0, numEnd) : value);

	    if (isNaN(num)) {
	      return true;
	    }

	    if (opts.min !== null && num < opts.min) {
	      return true;
	    }

	    if (opts.max !== null && num > opts.max) {
	      return true;
	    }
	  }

	  return false;
	}

	function consumeFunction(token, getNextToken) {
	  var startIdx = token.index;
	  var length = 0; // balanced token consuming

	  do {
	    length++;

	    if (token.balance <= startIdx) {
	      break;
	    }
	  } while (token = getNextToken(length));

	  return length;
	} // TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation


	function calc(next) {
	  return function (token, getNextToken, opts) {
	    if (token === null) {
	      return 0;
	    }

	    if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	      return consumeFunction(token, getNextToken);
	    }

	    return next(token, getNextToken, opts);
	  };
	}

	function tokenType(expectedTokenType) {
	  return function (token) {
	    if (token === null || token.type !== expectedTokenType) {
	      return 0;
	    }

	    return 1;
	  };
	}

	function func(name) {
	  name = name + '(';
	  return function (token, getNextToken) {
	    if (token !== null && eqStr(token.value, name)) {
	      return consumeFunction(token, getNextToken);
	    }

	    return 0;
	  };
	} // =========================
	// Complex types
	//
	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident


	function customIdent(token) {
	  if (token === null || token.type !== TYPE$5.Ident) {
	    return 0;
	  }

	  var name = token.value.toLowerCase(); // The CSS-wide keywords are not valid <custom-ident>s

	  if (eqStrAny(name, cssWideKeywords)) {
	    return 0;
	  } // The default keyword is reserved and is also not a valid <custom-ident>


	  if (eqStr(name, 'default')) {
	    return 0;
	  } // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	  // Specifications using <custom-ident> must specify clearly what other keywords
	  // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	  // in that property’s value definition are excluded. Excluded keywords are excluded
	  // in all ASCII case permutations.


	  return 1;
	} // https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.


	function customPropertyName(token) {
	  // ... defined as any valid identifier
	  if (token === null || token.type !== TYPE$5.Ident) {
	    return 0;
	  } // ... that starts with two dashes (U+002D HYPHEN-MINUS)


	  if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	    return 0;
	  }

	  return 1;
	} // https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).


	function hexColor(token) {
	  if (token === null || token.type !== TYPE$5.Hash) {
	    return 0;
	  }

	  var length = token.value.length; // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)

	  if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	    return 0;
	  }

	  for (var i = 1; i < length; i++) {
	    if (!isHexDigit$3(token.value.charCodeAt(i))) {
	      return 0;
	    }
	  }

	  return 1;
	}

	function idSelector(token) {
	  if (token === null || token.type !== TYPE$5.Hash) {
	    return 0;
	  }

	  if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	    return 0;
	  }

	  return 1;
	} // https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.


	function declarationValue(token, getNextToken) {
	  if (!token) {
	    return 0;
	  }

	  var length = 0;
	  var level = 0;
	  var startIdx = token.index; // The <declaration-value> production matches any sequence of one or more tokens,
	  // so long as the sequence ...

	  scan: do {
	    switch (token.type) {
	      // ... does not contain <bad-string-token>, <bad-url-token>,
	      case TYPE$5.BadString:
	      case TYPE$5.BadUrl:
	        break scan;
	      // ... unmatched <)-token>, <]-token>, or <}-token>,

	      case TYPE$5.RightCurlyBracket:
	      case TYPE$5.RightParenthesis:
	      case TYPE$5.RightSquareBracket:
	        if (token.balance > token.index || token.balance < startIdx) {
	          break scan;
	        }

	        level--;
	        break;
	      // ... or top-level <semicolon-token> tokens

	      case TYPE$5.Semicolon:
	        if (level === 0) {
	          break scan;
	        }

	        break;
	      // ... or <delim-token> tokens with a value of "!"

	      case TYPE$5.Delim:
	        if (token.value === '!' && level === 0) {
	          break scan;
	        }

	        break;

	      case TYPE$5.Function:
	      case TYPE$5.LeftParenthesis:
	      case TYPE$5.LeftSquareBracket:
	      case TYPE$5.LeftCurlyBracket:
	        level++;
	        break;
	    }

	    length++; // until balance closing

	    if (token.balance <= startIdx) {
	      break;
	    }
	  } while (token = getNextToken(length));

	  return length;
	} // https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.


	function anyValue(token, getNextToken) {
	  if (!token) {
	    return 0;
	  }

	  var startIdx = token.index;
	  var length = 0; // The <any-value> production matches any sequence of one or more tokens,
	  // so long as the sequence ...

	  scan: do {
	    switch (token.type) {
	      // ... does not contain <bad-string-token>, <bad-url-token>,
	      case TYPE$5.BadString:
	      case TYPE$5.BadUrl:
	        break scan;
	      // ... unmatched <)-token>, <]-token>, or <}-token>,

	      case TYPE$5.RightCurlyBracket:
	      case TYPE$5.RightParenthesis:
	      case TYPE$5.RightSquareBracket:
	        if (token.balance > token.index || token.balance < startIdx) {
	          break scan;
	        }

	        break;
	    }

	    length++; // until balance closing

	    if (token.balance <= startIdx) {
	      break;
	    }
	  } while (token = getNextToken(length));

	  return length;
	} // =========================
	// Dimensions
	//


	function dimension(type) {
	  return function (token, getNextToken, opts) {
	    if (token === null || token.type !== TYPE$5.Dimension) {
	      return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0); // check unit

	    if (type !== null) {
	      // check for IE postfix hack, i.e. 123px\0 or 123px\9
	      var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	      var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);

	      if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	        return 0;
	      }
	    } // check range if specified


	    if (outOfRange(opts, token.value, numberEnd)) {
	      return 0;
	    }

	    return 1;
	  };
	} // =========================
	// Percentage
	//
	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages


	function percentage(token, getNextToken, opts) {
	  // ... corresponds to the <percentage-token> production
	  if (token === null || token.type !== TYPE$5.Percentage) {
	    return 0;
	  } // check range if specified


	  if (outOfRange(opts, token.value, token.value.length - 1)) {
	    return 0;
	  }

	  return 1;
	} // =========================
	// Numeric
	//
	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.


	function zero(next) {
	  if (typeof next !== 'function') {
	    next = function () {
	      return 0;
	    };
	  }

	  return function (token, getNextToken, opts) {
	    if (token !== null && token.type === TYPE$5.Number) {
	      if (Number(token.value) === 0) {
	        return 1;
	      }
	    }

	    return next(token, getNextToken, opts);
	  };
	} // § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production


	function number(token, getNextToken, opts) {
	  if (token === null) {
	    return 0;
	  }

	  var numberEnd = consumeNumber$2(token.value, 0);
	  var isNumber = numberEnd === token.value.length;

	  if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	    return 0;
	  } // check range if specified


	  if (outOfRange(opts, token.value, numberEnd)) {
	    return 0;
	  }

	  return 1;
	} // §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers


	function integer(token, getNextToken, opts) {
	  // ... corresponds to a subset of the <number-token> production
	  if (token === null || token.type !== TYPE$5.Number) {
	    return 0;
	  } // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.


	  var i = token.value.charCodeAt(0) === 0x002B || // U+002B PLUS SIGN (+)
	  token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)
	  // When written literally, an integer is one or more decimal digits 0 through 9 ...

	  for (; i < token.value.length; i++) {
	    if (!isDigit$3(token.value.charCodeAt(i))) {
	      return 0;
	    }
	  } // check range if specified


	  if (outOfRange(opts, token.value, i)) {
	    return 0;
	  }

	  return 1;
	}

	var generic = {
	  // token types
	  'ident-token': tokenType(TYPE$5.Ident),
	  'function-token': tokenType(TYPE$5.Function),
	  'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	  'hash-token': tokenType(TYPE$5.Hash),
	  'string-token': tokenType(TYPE$5.String),
	  'bad-string-token': tokenType(TYPE$5.BadString),
	  'url-token': tokenType(TYPE$5.Url),
	  'bad-url-token': tokenType(TYPE$5.BadUrl),
	  'delim-token': tokenType(TYPE$5.Delim),
	  'number-token': tokenType(TYPE$5.Number),
	  'percentage-token': tokenType(TYPE$5.Percentage),
	  'dimension-token': tokenType(TYPE$5.Dimension),
	  'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	  'CDO-token': tokenType(TYPE$5.CDO),
	  'CDC-token': tokenType(TYPE$5.CDC),
	  'colon-token': tokenType(TYPE$5.Colon),
	  'semicolon-token': tokenType(TYPE$5.Semicolon),
	  'comma-token': tokenType(TYPE$5.Comma),
	  '[-token': tokenType(TYPE$5.LeftSquareBracket),
	  ']-token': tokenType(TYPE$5.RightSquareBracket),
	  '(-token': tokenType(TYPE$5.LeftParenthesis),
	  ')-token': tokenType(TYPE$5.RightParenthesis),
	  '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	  '}-token': tokenType(TYPE$5.RightCurlyBracket),
	  // token type aliases
	  'string': tokenType(TYPE$5.String),
	  'ident': tokenType(TYPE$5.Ident),
	  // complex types
	  'custom-ident': customIdent,
	  'custom-property-name': customPropertyName,
	  'hex-color': hexColor,
	  'id-selector': idSelector,
	  // element( <id-selector> )
	  'an-plus-b': genericAnPlusB,
	  'urange': genericUrange,
	  'declaration-value': declarationValue,
	  'any-value': anyValue,
	  // dimensions
	  'dimension': calc(dimension(null)),
	  'angle': calc(dimension(ANGLE)),
	  'decibel': calc(dimension(DECIBEL)),
	  'frequency': calc(dimension(FREQUENCY)),
	  'flex': calc(dimension(FLEX)),
	  'length': calc(zero(dimension(LENGTH))),
	  'resolution': calc(dimension(RESOLUTION)),
	  'semitones': calc(dimension(SEMITONES)),
	  'time': calc(dimension(TIME)),
	  // percentage
	  'percentage': calc(percentage),
	  // numeric
	  'zero': zero(),
	  'number': calc(number),
	  'integer': calc(integer),
	  // old IE stuff
	  '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	  var error = createCustomError('SyntaxError', message);
	  error.input = input;
	  error.offset = offset;
	  error.rawMessage = message;
	  error.message = error.rawMessage + '\n' + '  ' + error.input + '\n' + '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';
	  return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function (str) {
	  this.str = str;
	  this.pos = 0;
	};

	Tokenizer.prototype = {
	  charCodeAt: function (pos) {
	    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	  },
	  charCode: function () {
	    return this.charCodeAt(this.pos);
	  },
	  nextCharCode: function () {
	    return this.charCodeAt(this.pos + 1);
	  },
	  nextNonWsCode: function (pos) {
	    return this.charCodeAt(this.findWsEnd(pos));
	  },
	  findWsEnd: function (pos) {
	    for (; pos < this.str.length; pos++) {
	      var code = this.str.charCodeAt(pos);

	      if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	        break;
	      }
	    }

	    return pos;
	  },
	  substringToPos: function (end) {
	    return this.str.substring(this.pos, this.pos = end);
	  },
	  eat: function (code) {
	    if (this.charCode() !== code) {
	      this.error('Expect `' + String.fromCharCode(code) + '`');
	    }

	    this.pos++;
	  },
	  peek: function () {
	    return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	  },
	  error: function (message) {
	    throw new _SyntaxError$1(message, this.str, this.pos);
	  }
	};
	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33; // !

	var NUMBERSIGN = 35; // #

	var AMPERSAND = 38; // &

	var APOSTROPHE = 39; // '

	var LEFTPARENTHESIS = 40; // (

	var RIGHTPARENTHESIS = 41; // )

	var ASTERISK = 42; // *

	var PLUSSIGN$2 = 43; // +

	var COMMA = 44; // ,

	var HYPERMINUS = 45; // -

	var LESSTHANSIGN = 60; // <

	var GREATERTHANSIGN = 62; // >

	var QUESTIONMARK$1 = 63; // ?

	var COMMERCIALAT = 64; // @

	var LEFTSQUAREBRACKET = 91; // [

	var RIGHTSQUAREBRACKET = 93; // ]

	var LEFTCURLYBRACKET = 123; // {

	var VERTICALLINE = 124; // |

	var RIGHTCURLYBRACKET = 125; // }

	var INFINITY = 8734; // ∞

	var NAME_CHAR = createCharMap(function (ch) {
	  return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	  ' ': 1,
	  '&&': 2,
	  '||': 3,
	  '|': 4
	};

	function createCharMap(fn) {
	  var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);

	  for (var i = 0; i < 128; i++) {
	    array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	  }

	  return array;
	}

	function scanSpaces(tokenizer) {
	  return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));
	}

	function scanWord(tokenizer) {
	  var end = tokenizer.pos;

	  for (; end < tokenizer.str.length; end++) {
	    var code = tokenizer.str.charCodeAt(end);

	    if (code >= 128 || NAME_CHAR[code] === 0) {
	      break;
	    }
	  }

	  if (tokenizer.pos === end) {
	    tokenizer.error('Expect a keyword');
	  }

	  return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	  var end = tokenizer.pos;

	  for (; end < tokenizer.str.length; end++) {
	    var code = tokenizer.str.charCodeAt(end);

	    if (code < 48 || code > 57) {
	      break;
	    }
	  }

	  if (tokenizer.pos === end) {
	    tokenizer.error('Expect a number');
	  }

	  return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	  var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	  if (end === -1) {
	    tokenizer.pos = tokenizer.str.length;
	    tokenizer.error('Expect an apostrophe');
	  }

	  return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	  var min = null;
	  var max = null;
	  tokenizer.eat(LEFTCURLYBRACKET);
	  min = scanNumber(tokenizer);

	  if (tokenizer.charCode() === COMMA) {
	    tokenizer.pos++;

	    if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	      max = scanNumber(tokenizer);
	    }
	  } else {
	    max = min;
	  }

	  tokenizer.eat(RIGHTCURLYBRACKET);
	  return {
	    min: Number(min),
	    max: max ? Number(max) : 0
	  };
	}

	function readMultiplier(tokenizer) {
	  var range = null;
	  var comma = false;

	  switch (tokenizer.charCode()) {
	    case ASTERISK:
	      tokenizer.pos++;
	      range = {
	        min: 0,
	        max: 0
	      };
	      break;

	    case PLUSSIGN$2:
	      tokenizer.pos++;
	      range = {
	        min: 1,
	        max: 0
	      };
	      break;

	    case QUESTIONMARK$1:
	      tokenizer.pos++;
	      range = {
	        min: 0,
	        max: 1
	      };
	      break;

	    case NUMBERSIGN:
	      tokenizer.pos++;
	      comma = true;

	      if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	        range = readMultiplierRange(tokenizer);
	      } else {
	        range = {
	          min: 1,
	          max: 0
	        };
	      }

	      break;

	    case LEFTCURLYBRACKET:
	      range = readMultiplierRange(tokenizer);
	      break;

	    default:
	      return null;
	  }

	  return {
	    type: 'Multiplier',
	    comma: comma,
	    min: range.min,
	    max: range.max,
	    term: null
	  };
	}

	function maybeMultiplied(tokenizer, node) {
	  var multiplier = readMultiplier(tokenizer);

	  if (multiplier !== null) {
	    multiplier.term = node;
	    return multiplier;
	  }

	  return node;
	}

	function maybeToken(tokenizer) {
	  var ch = tokenizer.peek();

	  if (ch === '') {
	    return null;
	  }

	  return {
	    type: 'Token',
	    value: ch
	  };
	}

	function readProperty(tokenizer) {
	  var name;
	  tokenizer.eat(LESSTHANSIGN);
	  tokenizer.eat(APOSTROPHE);
	  name = scanWord(tokenizer);
	  tokenizer.eat(APOSTROPHE);
	  tokenizer.eat(GREATERTHANSIGN);
	  return maybeMultiplied(tokenizer, {
	    type: 'Property',
	    name: name
	  });
	} // https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.


	function readTypeRange(tokenizer) {
	  // use null for Infinity to make AST format JSON serializable/deserializable
	  var min = null; // -Infinity

	  var max = null; // Infinity

	  var sign = 1;
	  tokenizer.eat(LEFTSQUAREBRACKET);

	  if (tokenizer.charCode() === HYPERMINUS) {
	    tokenizer.peek();
	    sign = -1;
	  }

	  if (sign == -1 && tokenizer.charCode() === INFINITY) {
	    tokenizer.peek();
	  } else {
	    min = sign * Number(scanNumber(tokenizer));
	  }

	  scanSpaces(tokenizer);
	  tokenizer.eat(COMMA);
	  scanSpaces(tokenizer);

	  if (tokenizer.charCode() === INFINITY) {
	    tokenizer.peek();
	  } else {
	    sign = 1;

	    if (tokenizer.charCode() === HYPERMINUS) {
	      tokenizer.peek();
	      sign = -1;
	    }

	    max = sign * Number(scanNumber(tokenizer));
	  }

	  tokenizer.eat(RIGHTSQUAREBRACKET); // If no range is indicated, either by using the bracketed range notation
	  // or in the property description, then [−∞,∞] is assumed.

	  if (min === null && max === null) {
	    return null;
	  }

	  return {
	    type: 'Range',
	    min: min,
	    max: max
	  };
	}

	function readType(tokenizer) {
	  var name;
	  var opts = null;
	  tokenizer.eat(LESSTHANSIGN);
	  name = scanWord(tokenizer);

	  if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	    tokenizer.pos += 2;
	    name += '()';
	  }

	  if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	    scanSpaces(tokenizer);
	    opts = readTypeRange(tokenizer);
	  }

	  tokenizer.eat(GREATERTHANSIGN);
	  return maybeMultiplied(tokenizer, {
	    type: 'Type',
	    name: name,
	    opts: opts
	  });
	}

	function readKeywordOrFunction(tokenizer) {
	  var name;
	  name = scanWord(tokenizer);

	  if (tokenizer.charCode() === LEFTPARENTHESIS) {
	    tokenizer.pos++;
	    return {
	      type: 'Function',
	      name: name
	    };
	  }

	  return maybeMultiplied(tokenizer, {
	    type: 'Keyword',
	    name: name
	  });
	}

	function regroupTerms(terms, combinators) {
	  function createGroup(terms, combinator) {
	    return {
	      type: 'Group',
	      terms: terms,
	      combinator: combinator,
	      disallowEmpty: false,
	      explicit: false
	    };
	  }

	  combinators = Object.keys(combinators).sort(function (a, b) {
	    return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	  });

	  while (combinators.length > 0) {
	    var combinator = combinators.shift();

	    for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	      var term = terms[i];

	      if (term.type === 'Combinator') {
	        if (term.value === combinator) {
	          if (subgroupStart === -1) {
	            subgroupStart = i - 1;
	          }

	          terms.splice(i, 1);
	          i--;
	        } else {
	          if (subgroupStart !== -1 && i - subgroupStart > 1) {
	            terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
	            i = subgroupStart + 1;
	          }

	          subgroupStart = -1;
	        }
	      }
	    }

	    if (subgroupStart !== -1 && combinators.length) {
	      terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
	    }
	  }

	  return combinator;
	}

	function readImplicitGroup(tokenizer) {
	  var terms = [];
	  var combinators = {};
	  var token;
	  var prevToken = null;
	  var prevTokenPos = tokenizer.pos;

	  while (token = peek(tokenizer)) {
	    if (token.type !== 'Spaces') {
	      if (token.type === 'Combinator') {
	        // check for combinator in group beginning and double combinator sequence
	        if (prevToken === null || prevToken.type === 'Combinator') {
	          tokenizer.pos = prevTokenPos;
	          tokenizer.error('Unexpected combinator');
	        }

	        combinators[token.value] = true;
	      } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	        combinators[' '] = true; // a b

	        terms.push({
	          type: 'Combinator',
	          value: ' '
	        });
	      }

	      terms.push(token);
	      prevToken = token;
	      prevTokenPos = tokenizer.pos;
	    }
	  } // check for combinator in group ending


	  if (prevToken !== null && prevToken.type === 'Combinator') {
	    tokenizer.pos -= prevTokenPos;
	    tokenizer.error('Unexpected combinator');
	  }

	  return {
	    type: 'Group',
	    terms: terms,
	    combinator: regroupTerms(terms, combinators) || ' ',
	    disallowEmpty: false,
	    explicit: false
	  };
	}

	function readGroup(tokenizer) {
	  var result;
	  tokenizer.eat(LEFTSQUAREBRACKET);
	  result = readImplicitGroup(tokenizer);
	  tokenizer.eat(RIGHTSQUAREBRACKET);
	  result.explicit = true;

	  if (tokenizer.charCode() === EXCLAMATIONMARK) {
	    tokenizer.pos++;
	    result.disallowEmpty = true;
	  }

	  return result;
	}

	function peek(tokenizer) {
	  var code = tokenizer.charCode();

	  if (code < 128 && NAME_CHAR[code] === 1) {
	    return readKeywordOrFunction(tokenizer);
	  }

	  switch (code) {
	    case RIGHTSQUAREBRACKET:
	      // don't eat, stop scan a group
	      break;

	    case LEFTSQUAREBRACKET:
	      return maybeMultiplied(tokenizer, readGroup(tokenizer));

	    case LESSTHANSIGN:
	      return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);

	    case VERTICALLINE:
	      return {
	        type: 'Combinator',
	        value: tokenizer.substringToPos(tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1)
	      };

	    case AMPERSAND:
	      tokenizer.pos++;
	      tokenizer.eat(AMPERSAND);
	      return {
	        type: 'Combinator',
	        value: '&&'
	      };

	    case COMMA:
	      tokenizer.pos++;
	      return {
	        type: 'Comma'
	      };

	    case APOSTROPHE:
	      return maybeMultiplied(tokenizer, {
	        type: 'String',
	        value: scanString(tokenizer)
	      });

	    case SPACE$1:
	    case TAB$1:
	    case N$2:
	    case R$1:
	    case F$1:
	      return {
	        type: 'Spaces',
	        value: scanSpaces(tokenizer)
	      };

	    case COMMERCIALAT:
	      code = tokenizer.nextCharCode();

	      if (code < 128 && NAME_CHAR[code] === 1) {
	        tokenizer.pos++;
	        return {
	          type: 'AtKeyword',
	          name: scanWord(tokenizer)
	        };
	      }

	      return maybeToken(tokenizer);

	    case ASTERISK:
	    case PLUSSIGN$2:
	    case QUESTIONMARK$1:
	    case NUMBERSIGN:
	    case EXCLAMATIONMARK:
	      // prohibited tokens (used as a multiplier start)
	      break;

	    case LEFTCURLYBRACKET:
	      // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	      // check next char isn't a number, because it's likely a disjoined multiplier
	      code = tokenizer.nextCharCode();

	      if (code < 48 || code > 57) {
	        return maybeToken(tokenizer);
	      }

	      break;

	    default:
	      return maybeToken(tokenizer);
	  }
	}

	function parse$2(source) {
	  var tokenizer = new tokenizer$1(source);
	  var result = readImplicitGroup(tokenizer);

	  if (tokenizer.pos !== source.length) {
	    tokenizer.error('Unexpected input');
	  } // reduce redundant groups with single group term


	  if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	    result = result.terms[0];
	  }

	  return result;
	} // warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)


	parse$2('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');
	var parse_1 = parse$2;

	var noop$2 = function () {};

	function ensureFunction(value) {
	  return typeof value === 'function' ? value : noop$2;
	}

	var walk = function (node, options, context) {
	  function walk(node) {
	    enter.call(context, node);

	    switch (node.type) {
	      case 'Group':
	        node.terms.forEach(walk);
	        break;

	      case 'Multiplier':
	        walk(node.term);
	        break;

	      case 'Type':
	      case 'Property':
	      case 'Keyword':
	      case 'AtKeyword':
	      case 'Function':
	      case 'String':
	      case 'Token':
	      case 'Comma':
	        break;

	      default:
	        throw new Error('Unknown type: ' + node.type);
	    }

	    leave.call(context, node);
	  }

	  var enter = noop$2;
	  var leave = noop$2;

	  if (typeof options === 'function') {
	    enter = options;
	  } else if (options) {
	    enter = ensureFunction(options.enter);
	    leave = ensureFunction(options.leave);
	  }

	  if (enter === noop$2 && leave === noop$2) {
	    throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	  }

	  walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	  decorator: function (handlers) {
	    var curNode = null;
	    var prev = {
	      len: 0,
	      node: null
	    };
	    var nodes = [prev];
	    var buffer = '';
	    return {
	      children: handlers.children,
	      node: function (node) {
	        var tmp = curNode;
	        curNode = node;
	        handlers.node.call(this, node);
	        curNode = tmp;
	      },
	      chunk: function (chunk) {
	        buffer += chunk;

	        if (prev.node !== curNode) {
	          nodes.push({
	            len: chunk.length,
	            node: curNode
	          });
	        } else {
	          prev.len += chunk.length;
	        }
	      },
	      result: function () {
	        return prepareTokens(buffer, nodes);
	      }
	    };
	  }
	};

	function prepareTokens(str, nodes) {
	  var tokens = [];
	  var nodesOffset = 0;
	  var nodesIndex = 0;
	  var currentNode = nodes ? nodes[nodesIndex].node : null;
	  tokenizer(str, tokenStream);

	  while (!tokenStream.eof) {
	    if (nodes) {
	      while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	        nodesOffset += nodes[nodesIndex++].len;
	        currentNode = nodes[nodesIndex].node;
	      }
	    }

	    tokens.push({
	      type: tokenStream.tokenType,
	      value: tokenStream.getTokenValue(),
	      index: tokenStream.tokenIndex,
	      // TODO: remove it, temporary solution
	      balance: tokenStream.balance[tokenStream.tokenIndex],
	      // TODO: remove it, temporary solution
	      node: currentNode
	    });
	    tokenStream.next(); // console.log({ ...tokens[tokens.length - 1], node: undefined });
	  }

	  return tokens;
	}

	var prepareTokens_1 = function (value, syntax) {
	  if (typeof value === 'string') {
	    return prepareTokens(value, null);
	  }

	  return syntax.generate(value, astToTokens);
	};

	var MATCH = {
	  type: 'Match'
	};
	var MISMATCH = {
	  type: 'Mismatch'
	};
	var DISALLOW_EMPTY = {
	  type: 'DisallowEmpty'
	};
	var LEFTPARENTHESIS$1 = 40; // (

	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	  // reduce node count
	  if (thenBranch === MATCH && elseBranch === MISMATCH) {
	    return match;
	  }

	  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	    return match;
	  }

	  if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	    thenBranch = match.then;
	    match = match.match;
	  }

	  return {
	    type: 'If',
	    match: match,
	    then: thenBranch,
	    else: elseBranch
	  };
	}

	function isFunctionType(name) {
	  return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1;
	}

	function isEnumCapatible(term) {
	  return term.type === 'Keyword' || term.type === 'AtKeyword' || term.type === 'Function' || term.type === 'Type' && isFunctionType(term.name);
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	  switch (combinator) {
	    case ' ':
	      // Juxtaposing components means that all of them must occur, in the given order.
	      //
	      // a b c
	      // =
	      // match a
	      //   then match b
	      //     then match c
	      //       then MATCH
	      //       else MISMATCH
	      //     else MISMATCH
	      //   else MISMATCH
	      var result = MATCH;

	      for (var i = terms.length - 1; i >= 0; i--) {
	        var term = terms[i];
	        result = createCondition(term, result, MISMATCH);
	      }
	      return result;

	    case '|':
	      // A bar (|) separates two or more alternatives: exactly one of them must occur.
	      //
	      // a | b | c
	      // =
	      // match a
	      //   then MATCH
	      //   else match b
	      //     then MATCH
	      //     else match c
	      //       then MATCH
	      //       else MISMATCH
	      var result = MISMATCH;
	      var map = null;

	      for (var i = terms.length - 1; i >= 0; i--) {
	        var term = terms[i]; // reduce sequence of keywords into a Enum

	        if (isEnumCapatible(term)) {
	          if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	            map = Object.create(null);
	            result = createCondition({
	              type: 'Enum',
	              map: map
	            }, MATCH, result);
	          }

	          if (map !== null) {
	            var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();

	            if (key in map === false) {
	              map[key] = term;
	              continue;
	            }
	          }
	        }

	        map = null; // create a new conditonal node

	        result = createCondition(term, MATCH, result);
	      }
	      return result;

	    case '&&':
	      // A double ampersand (&&) separates two or more components,
	      // all of which must occur, in any order.
	      // Use MatchOnce for groups with a large number of terms,
	      // since &&-groups produces at least N!-node trees
	      if (terms.length > 5) {
	        return {
	          type: 'MatchOnce',
	          terms: terms,
	          all: true
	        };
	      } // Use a combination tree for groups with small number of terms
	      //
	      // a && b && c
	      // =
	      // match a
	      //   then [b && c]
	      //   else match b
	      //     then [a && c]
	      //     else match c
	      //       then [a && b]
	      //       else MISMATCH
	      //
	      // a && b
	      // =
	      // match a
	      //   then match b
	      //     then MATCH
	      //     else MISMATCH
	      //   else match b
	      //     then match a
	      //       then MATCH
	      //       else MISMATCH
	      //     else MISMATCH


	      var result = MISMATCH;

	      for (var i = terms.length - 1; i >= 0; i--) {
	        var term = terms[i];
	        var thenClause;

	        if (terms.length > 1) {
	          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {
	            return newGroupTerm !== term;
	          }), false);
	        } else {
	          thenClause = MATCH;
	        }

	        result = createCondition(term, thenClause, result);
	      }
	      return result;

	    case '||':
	      // A double bar (||) separates two or more options:
	      // one or more of them must occur, in any order.
	      // Use MatchOnce for groups with a large number of terms,
	      // since ||-groups produces at least N!-node trees
	      if (terms.length > 5) {
	        return {
	          type: 'MatchOnce',
	          terms: terms,
	          all: false
	        };
	      } // Use a combination tree for groups with small number of terms
	      //
	      // a || b || c
	      // =
	      // match a
	      //   then [b || c]
	      //   else match b
	      //     then [a || c]
	      //     else match c
	      //       then [a || b]
	      //       else MISMATCH
	      //
	      // a || b
	      // =
	      // match a
	      //   then match b
	      //     then MATCH
	      //     else MATCH
	      //   else match b
	      //     then match a
	      //       then MATCH
	      //       else MATCH
	      //     else MISMATCH


	      var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	      for (var i = terms.length - 1; i >= 0; i--) {
	        var term = terms[i];
	        var thenClause;

	        if (terms.length > 1) {
	          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {
	            return newGroupTerm !== term;
	          }), true);
	        } else {
	          thenClause = MATCH;
	        }

	        result = createCondition(term, thenClause, result);
	      }
	      return result;
	  }
	}

	function buildMultiplierMatchGraph(node) {
	  var result = MATCH;
	  var matchTerm = buildMatchGraph(node.term);

	  if (node.max === 0) {
	    // disable repeating of empty match to prevent infinite loop
	    matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH); // an occurrence count is not limited, make a cycle;
	    // to collect more terms on each following matching mismatch

	    result = createCondition(matchTerm, null, // will be a loop
	    MISMATCH);
	    result.then = createCondition(MATCH, MATCH, result // make a loop
	    );

	    if (node.comma) {
	      result.then.else = createCondition({
	        type: 'Comma',
	        syntax: node
	      }, result, MISMATCH);
	    }
	  } else {
	    // create a match node chain for [min .. max] interval with optional matches
	    for (var i = node.min || 1; i <= node.max; i++) {
	      if (node.comma && result !== MATCH) {
	        result = createCondition({
	          type: 'Comma',
	          syntax: node
	        }, result, MISMATCH);
	      }

	      result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);
	    }
	  }

	  if (node.min === 0) {
	    // allow zero match
	    result = createCondition(MATCH, MATCH, result);
	  } else {
	    // create a match node chain to collect [0 ... min - 1] required matches
	    for (var i = 0; i < node.min - 1; i++) {
	      if (node.comma && result !== MATCH) {
	        result = createCondition({
	          type: 'Comma',
	          syntax: node
	        }, result, MISMATCH);
	      }

	      result = createCondition(matchTerm, result, MISMATCH);
	    }
	  }

	  return result;
	}

	function buildMatchGraph(node) {
	  if (typeof node === 'function') {
	    return {
	      type: 'Generic',
	      fn: node
	    };
	  }

	  switch (node.type) {
	    case 'Group':
	      var result = buildGroupMatchGraph(node.combinator, node.terms.map(buildMatchGraph), false);

	      if (node.disallowEmpty) {
	        result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
	      }

	      return result;

	    case 'Multiplier':
	      return buildMultiplierMatchGraph(node);

	    case 'Type':
	    case 'Property':
	      return {
	        type: node.type,
	        name: node.name,
	        syntax: node
	      };

	    case 'Keyword':
	      return {
	        type: node.type,
	        name: node.name.toLowerCase(),
	        syntax: node
	      };

	    case 'AtKeyword':
	      return {
	        type: node.type,
	        name: '@' + node.name.toLowerCase(),
	        syntax: node
	      };

	    case 'Function':
	      return {
	        type: node.type,
	        name: node.name.toLowerCase() + '(',
	        syntax: node
	      };

	    case 'String':
	      // convert a one char length String to a Token
	      if (node.value.length === 3) {
	        return {
	          type: 'Token',
	          value: node.value.charAt(1),
	          syntax: node
	        };
	      } // otherwise use it as is


	      return {
	        type: node.type,
	        value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	        syntax: node
	      };

	    case 'Token':
	      return {
	        type: node.type,
	        value: node.value,
	        syntax: node
	      };

	    case 'Comma':
	      return {
	        type: node.type,
	        syntax: node
	      };

	    default:
	      throw new Error('Unknown node type:', node.type);
	  }
	}

	var matchGraph = {
	  MATCH: MATCH,
	  MISMATCH: MISMATCH,
	  DISALLOW_EMPTY: DISALLOW_EMPTY,
	  buildMatchGraph: function (syntaxTree, ref) {
	    if (typeof syntaxTree === 'string') {
	      syntaxTree = parse_1(syntaxTree);
	    }

	    return {
	      type: 'MatchGraph',
	      match: buildMatchGraph(syntaxTree),
	      syntax: ref || null,
	      source: syntaxTree
	    };
	  }
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;
	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;
	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';
	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	  var prev = null;
	  var next = null;
	  var item = list;

	  while (item !== null) {
	    next = item.prev;
	    item.prev = prev;
	    prev = item;
	    item = next;
	  }

	  return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	  if (testStr.length !== referenceStr.length) {
	    return false;
	  }

	  for (var i = 0; i < testStr.length; i++) {
	    var testCode = testStr.charCodeAt(i);
	    var referenceCode = referenceStr.charCodeAt(i); // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).

	    if (testCode >= 0x0041 && testCode <= 0x005A) {
	      testCode = testCode | 32;
	    }

	    if (testCode !== referenceCode) {
	      return false;
	    }
	  }

	  return true;
	}

	function isCommaContextStart(token) {
	  if (token === null) {
	    return true;
	  }

	  return token.type === TYPE$6.Comma || token.type === TYPE$6.Function || token.type === TYPE$6.LeftParenthesis || token.type === TYPE$6.LeftSquareBracket || token.type === TYPE$6.LeftCurlyBracket || token.type === TYPE$6.Delim;
	}

	function isCommaContextEnd(token) {
	  if (token === null) {
	    return true;
	  }

	  return token.type === TYPE$6.RightParenthesis || token.type === TYPE$6.RightSquareBracket || token.type === TYPE$6.RightCurlyBracket || token.type === TYPE$6.Delim;
	}

	function internalMatch(tokens, state, syntaxes) {
	  function moveToNextToken() {
	    do {
	      tokenIndex++;
	      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	    } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	  }

	  function getNextToken(offset) {
	    var nextIndex = tokenIndex + offset;
	    return nextIndex < tokens.length ? tokens[nextIndex] : null;
	  }

	  function stateSnapshotFromSyntax(nextState, prev) {
	    return {
	      nextState: nextState,
	      matchStack: matchStack,
	      syntaxStack: syntaxStack,
	      thenStack: thenStack,
	      tokenIndex: tokenIndex,
	      prev: prev
	    };
	  }

	  function pushThenStack(nextState) {
	    thenStack = {
	      nextState: nextState,
	      matchStack: matchStack,
	      syntaxStack: syntaxStack,
	      prev: thenStack
	    };
	  }

	  function pushElseStack(nextState) {
	    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	  }

	  function addTokenToMatch() {
	    matchStack = {
	      type: TOKEN,
	      syntax: state.syntax,
	      token: token,
	      prev: matchStack
	    };
	    moveToNextToken();
	    syntaxStash = null;

	    if (tokenIndex > longestMatch) {
	      longestMatch = tokenIndex;
	    }
	  }

	  function openSyntax() {
	    syntaxStack = {
	      syntax: state.syntax,
	      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
	      prev: syntaxStack
	    };
	    matchStack = {
	      type: OPEN_SYNTAX,
	      syntax: state.syntax,
	      token: matchStack.token,
	      prev: matchStack
	    };
	  }

	  function closeSyntax() {
	    if (matchStack.type === OPEN_SYNTAX) {
	      matchStack = matchStack.prev;
	    } else {
	      matchStack = {
	        type: CLOSE_SYNTAX,
	        syntax: syntaxStack.syntax,
	        token: matchStack.token,
	        prev: matchStack
	      };
	    }

	    syntaxStack = syntaxStack.prev;
	  }

	  var syntaxStack = null;
	  var thenStack = null;
	  var elseStack = null; // null – stashing allowed, nothing stashed
	  // false – stashing disabled, nothing stashed
	  // anithing else – fail stashable syntaxes, some syntax stashed

	  var syntaxStash = null;
	  var iterationCount = 0; // count iterations and prevent infinite loop

	  var exitReason = null;
	  var token = null;
	  var tokenIndex = -1;
	  var longestMatch = 0;
	  var matchStack = {
	    type: STUB,
	    syntax: null,
	    token: null,
	    prev: null
	  };
	  moveToNextToken();

	  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	    // function mapList(list, fn) {
	    //     var result = [];
	    //     while (list) {
	    //         result.unshift(fn(list));
	    //         list = list.prev;
	    //     }
	    //     return result;
	    // }
	    // console.log('--\n',
	    //     '#' + iterationCount,
	    //     require('util').inspect({
	    //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	    //         token: token && token.value,
	    //         tokenIndex,
	    //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	    //     }, { depth: null })
	    // );
	    switch (state.type) {
	      case 'Match':
	        if (thenStack === null) {
	          // turn to MISMATCH when some tokens left unmatched
	          if (token !== null) {
	            // doesn't mismatch if just one token left and it's an IE hack
	            if (tokenIndex !== tokens.length - 1 || token.value !== '\\0' && token.value !== '\\9') {
	              state = MISMATCH$1;
	              break;
	            }
	          } // break the main loop, return a result - MATCH


	          exitReason = EXIT_REASON_MATCH;
	          break;
	        } // go to next syntax (`then` branch)


	        state = thenStack.nextState; // check match is not empty

	        if (state === DISALLOW_EMPTY$1) {
	          if (thenStack.matchStack === matchStack) {
	            state = MISMATCH$1;
	            break;
	          } else {
	            state = MATCH$1;
	          }
	        } // close syntax if needed


	        while (thenStack.syntaxStack !== syntaxStack) {
	          closeSyntax();
	        } // pop stack


	        thenStack = thenStack.prev;
	        break;

	      case 'Mismatch':
	        // when some syntax is stashed
	        if (syntaxStash !== null && syntaxStash !== false) {
	          // there is no else branches or a branch reduce match stack
	          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	            // restore state from the stash
	            elseStack = syntaxStash;
	            syntaxStash = false; // disable stashing
	          }
	        } else if (elseStack === null) {
	          // no else branches -> break the main loop
	          // return a result - MISMATCH
	          exitReason = EXIT_REASON_MISMATCH;
	          break;
	        } // go to next syntax (`else` branch)


	        state = elseStack.nextState; // restore all the rest stack states

	        thenStack = elseStack.thenStack;
	        syntaxStack = elseStack.syntaxStack;
	        matchStack = elseStack.matchStack;
	        tokenIndex = elseStack.tokenIndex;
	        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null; // pop stack

	        elseStack = elseStack.prev;
	        break;

	      case 'MatchGraph':
	        state = state.match;
	        break;

	      case 'If':
	        // IMPORTANT: else stack push must go first,
	        // since it stores the state of thenStack before changes
	        if (state.else !== MISMATCH$1) {
	          pushElseStack(state.else);
	        }

	        if (state.then !== MATCH$1) {
	          pushThenStack(state.then);
	        }

	        state = state.match;
	        break;

	      case 'MatchOnce':
	        state = {
	          type: 'MatchOnceBuffer',
	          syntax: state,
	          index: 0,
	          mask: 0
	        };
	        break;

	      case 'MatchOnceBuffer':
	        var terms = state.syntax.terms;

	        if (state.index === terms.length) {
	          // no matches at all or it's required all terms to be matched
	          if (state.mask === 0 || state.syntax.all) {
	            state = MISMATCH$1;
	            break;
	          } // a partial match is ok


	          state = MATCH$1;
	          break;
	        } // all terms are matched


	        if (state.mask === (1 << terms.length) - 1) {
	          state = MATCH$1;
	          break;
	        }

	        for (; state.index < terms.length; state.index++) {
	          var matchFlag = 1 << state.index;

	          if ((state.mask & matchFlag) === 0) {
	            // IMPORTANT: else stack push must go first,
	            // since it stores the state of thenStack before changes
	            pushElseStack(state);
	            pushThenStack({
	              type: 'AddMatchOnce',
	              syntax: state.syntax,
	              mask: state.mask | matchFlag
	            }); // match

	            state = terms[state.index++];
	            break;
	          }
	        }

	        break;

	      case 'AddMatchOnce':
	        state = {
	          type: 'MatchOnceBuffer',
	          syntax: state.syntax,
	          index: 0,
	          mask: state.mask
	        };
	        break;

	      case 'Enum':
	        if (token !== null) {
	          var name = token.value.toLowerCase(); // drop \0 and \9 hack from keyword name

	          if (name.indexOf('\\') !== -1) {
	            name = name.replace(/\\[09].*$/, '');
	          }

	          if (hasOwnProperty$2.call(state.map, name)) {
	            state = state.map[name];
	            break;
	          }
	        }

	        state = MISMATCH$1;
	        break;

	      case 'Generic':
	        var opts = syntaxStack !== null ? syntaxStack.opts : null;
	        var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	        if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	          while (tokenIndex < lastTokenIndex) {
	            addTokenToMatch();
	          }

	          state = MATCH$1;
	        } else {
	          state = MISMATCH$1;
	        }

	        break;

	      case 'Type':
	      case 'Property':
	        var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	        var dictSyntax = hasOwnProperty$2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	        if (!dictSyntax || !dictSyntax.match) {
	          throw new Error('Bad syntax reference: ' + (state.type === 'Type' ? '<' + state.name + '>' : '<\'' + state.name + '\'>'));
	        } // stash a syntax for types with low priority


	        if (syntaxStash !== false && token !== null && state.type === 'Type') {
	          var lowPriorityMatching = // https://drafts.csswg.org/css-values-4/#custom-idents
	          // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	          // can only claim the keyword if no other unfulfilled production can claim it.
	          state.name === 'custom-ident' && token.type === TYPE$6.Ident || // https://drafts.csswg.org/css-values-4/#lengths
	          // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	          // it must parse as a <number>
	          state.name === 'length' && token.value === '0';

	          if (lowPriorityMatching) {
	            if (syntaxStash === null) {
	              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	            }

	            state = MISMATCH$1;
	            break;
	          }
	        }

	        openSyntax();
	        state = dictSyntax.match;
	        break;

	      case 'Keyword':
	        var name = state.name;

	        if (token !== null) {
	          var keywordName = token.value; // drop \0 and \9 hack from keyword name

	          if (keywordName.indexOf('\\') !== -1) {
	            keywordName = keywordName.replace(/\\[09].*$/, '');
	          }

	          if (areStringsEqualCaseInsensitive(keywordName, name)) {
	            addTokenToMatch();
	            state = MATCH$1;
	            break;
	          }
	        }

	        state = MISMATCH$1;
	        break;

	      case 'AtKeyword':
	      case 'Function':
	        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	          addTokenToMatch();
	          state = MATCH$1;
	          break;
	        }

	        state = MISMATCH$1;
	        break;

	      case 'Token':
	        if (token !== null && token.value === state.value) {
	          addTokenToMatch();
	          state = MATCH$1;
	          break;
	        }

	        state = MISMATCH$1;
	        break;

	      case 'Comma':
	        if (token !== null && token.type === TYPE$6.Comma) {
	          if (isCommaContextStart(matchStack.token)) {
	            state = MISMATCH$1;
	          } else {
	            addTokenToMatch();
	            state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	          }
	        } else {
	          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	        }

	        break;

	      case 'String':
	        var string = '';

	        for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	          string += tokens[lastTokenIndex].value;
	        }

	        if (areStringsEqualCaseInsensitive(string, state.value)) {
	          while (tokenIndex < lastTokenIndex) {
	            addTokenToMatch();
	          }

	          state = MATCH$1;
	        } else {
	          state = MISMATCH$1;
	        }

	        break;

	      default:
	        throw new Error('Unknown node type: ' + state.type);
	    }
	  }

	  totalIterationCount += iterationCount;

	  switch (exitReason) {
	    case null:
	      console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	      exitReason = EXIT_REASON_ITERATION_LIMIT;
	      matchStack = null;
	      break;

	    case EXIT_REASON_MATCH:
	      while (syntaxStack !== null) {
	        closeSyntax();
	      }

	      break;

	    default:
	      matchStack = null;
	  }

	  return {
	    tokens: tokens,
	    reason: exitReason,
	    iterations: iterationCount,
	    match: matchStack,
	    longestMatch: longestMatch
	  };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	  if (matchResult.match !== null) {
	    var item = reverseList(matchResult.match).prev;
	    matchResult.match = [];

	    while (item !== null) {
	      switch (item.type) {
	        case STUB:
	          break;

	        case OPEN_SYNTAX:
	        case CLOSE_SYNTAX:
	          matchResult.match.push({
	            type: item.type,
	            syntax: item.syntax
	          });
	          break;

	        default:
	          matchResult.match.push({
	            token: item.token.value,
	            node: item.token.node
	          });
	          break;
	      }

	      item = item.prev;
	    }
	  }

	  return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	  if (matchResult.match === null) {
	    return matchResult;
	  }

	  var item = matchResult.match;
	  var host = matchResult.match = {
	    syntax: matchGraph.syntax || null,
	    match: []
	  };
	  var hostStack = [host]; // revert a list and start with 2nd item since 1st is a stub item

	  item = reverseList(item).prev; // build a tree

	  while (item !== null) {
	    switch (item.type) {
	      case OPEN_SYNTAX:
	        host.match.push(host = {
	          syntax: item.syntax,
	          match: []
	        });
	        hostStack.push(host);
	        break;

	      case CLOSE_SYNTAX:
	        hostStack.pop();
	        host = hostStack[hostStack.length - 1];
	        break;

	      default:
	        host.match.push({
	          syntax: item.syntax || null,
	          token: item.token.value,
	          node: item.token.node
	        });
	    }

	    item = item.prev;
	  }

	  return matchResult;
	}

	var match$1 = {
	  matchAsList: matchAsList,
	  matchAsTree: matchAsTree,
	  getTotalIterationCount: function () {
	    return totalIterationCount;
	  }
	};

	function getTrace(node) {
	  function shouldPutToTrace(syntax) {
	    if (syntax === null) {
	      return false;
	    }

	    return syntax.type === 'Type' || syntax.type === 'Property' || syntax.type === 'Keyword';
	  }

	  function hasMatch(matchNode) {
	    if (Array.isArray(matchNode.match)) {
	      // use for-loop for better perfomance
	      for (var i = 0; i < matchNode.match.length; i++) {
	        if (hasMatch(matchNode.match[i])) {
	          if (shouldPutToTrace(matchNode.syntax)) {
	            result.unshift(matchNode.syntax);
	          }

	          return true;
	        }
	      }
	    } else if (matchNode.node === node) {
	      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
	      return true;
	    }

	    return false;
	  }

	  var result = null;

	  if (this.matched !== null) {
	    hasMatch(this.matched);
	  }

	  return result;
	}

	function testNode(match, node, fn) {
	  var trace = getTrace.call(match, node);

	  if (trace === null) {
	    return false;
	  }

	  return trace.some(fn);
	}

	function isType(node, type) {
	  return testNode(this, node, function (matchNode) {
	    return matchNode.type === 'Type' && matchNode.name === type;
	  });
	}

	function isProperty(node, property) {
	  return testNode(this, node, function (matchNode) {
	    return matchNode.type === 'Property' && matchNode.name === property;
	  });
	}

	function isKeyword(node) {
	  return testNode(this, node, function (matchNode) {
	    return matchNode.type === 'Keyword';
	  });
	}

	var trace = {
	  getTrace: getTrace,
	  isType: isType,
	  isProperty: isProperty,
	  isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	  if ('node' in matchNode) {
	    return matchNode.node;
	  }

	  return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	  if ('node' in matchNode) {
	    return matchNode.node;
	  }

	  return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	  function findFragments(matchNode) {
	    if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
	      var start = getFirstMatchNode(matchNode);
	      var end = getLastMatchNode(matchNode);
	      lexer.syntax.walk(ast, function (node, item, list) {
	        if (node === start) {
	          var nodes = new List_1();

	          do {
	            nodes.appendData(item.data);

	            if (item.data === end) {
	              break;
	            }

	            item = item.next;
	          } while (item !== null);

	          fragments.push({
	            parent: list,
	            nodes: nodes
	          });
	        }
	      });
	    }

	    if (Array.isArray(matchNode.match)) {
	      matchNode.match.forEach(findFragments);
	    }
	  }

	  var fragments = [];

	  if (match.matched !== null) {
	    findFragments(match.matched);
	  }

	  return fragments;
	}

	var search = {
	  matchFragments: matchFragments
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	  // Number.isInteger(value) && value >= 0
	  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value && value >= 0;
	}

	function isValidLocation(loc) {
	  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
	}

	function createNodeStructureChecker(type, fields) {
	  return function checkNode(node, warn) {
	    if (!node || node.constructor !== Object) {
	      return warn(node, 'Type of node should be an Object');
	    }

	    for (var key in node) {
	      var valid = true;

	      if (hasOwnProperty$3.call(node, key) === false) {
	        continue;
	      }

	      if (key === 'type') {
	        if (node.type !== type) {
	          warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	        }
	      } else if (key === 'loc') {
	        if (node.loc === null) {
	          continue;
	        } else if (node.loc && node.loc.constructor === Object) {
	          if (typeof node.loc.source !== 'string') {
	            key += '.source';
	          } else if (!isValidLocation(node.loc.start)) {
	            key += '.start';
	          } else if (!isValidLocation(node.loc.end)) {
	            key += '.end';
	          } else {
	            continue;
	          }
	        }

	        valid = false;
	      } else if (fields.hasOwnProperty(key)) {
	        for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	          var fieldType = fields[key][i];

	          switch (fieldType) {
	            case String:
	              valid = typeof node[key] === 'string';
	              break;

	            case Boolean:
	              valid = typeof node[key] === 'boolean';
	              break;

	            case null:
	              valid = node[key] === null;
	              break;

	            default:
	              if (typeof fieldType === 'string') {
	                valid = node[key] && node[key].type === fieldType;
	              } else if (Array.isArray(fieldType)) {
	                valid = node[key] instanceof List_1;
	              }

	          }
	        }
	      } else {
	        warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	      }

	      if (!valid) {
	        warn(node, 'Bad value for `' + type + '.' + key + '`');
	      }
	    }

	    for (var key in fields) {
	      if (hasOwnProperty$3.call(fields, key) && hasOwnProperty$3.call(node, key) === false) {
	        warn(node, 'Field `' + type + '.' + key + '` is missed');
	      }
	    }
	  };
	}

	function processStructure(name, nodeType) {
	  var structure = nodeType.structure;
	  var fields = {
	    type: String,
	    loc: true
	  };
	  var docs = {
	    type: '"' + name + '"'
	  };

	  for (var key in structure) {
	    if (hasOwnProperty$3.call(structure, key) === false) {
	      continue;
	    }

	    var docsTypes = [];
	    var fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];

	    for (var i = 0; i < fieldTypes.length; i++) {
	      var fieldType = fieldTypes[i];

	      if (fieldType === String || fieldType === Boolean) {
	        docsTypes.push(fieldType.name);
	      } else if (fieldType === null) {
	        docsTypes.push('null');
	      } else if (typeof fieldType === 'string') {
	        docsTypes.push('<' + fieldType + '>');
	      } else if (Array.isArray(fieldType)) {
	        docsTypes.push('List'); // TODO: use type enum
	      } else {
	        throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	      }
	    }

	    docs[key] = docsTypes.join(' | ');
	  }

	  return {
	    docs: docs,
	    check: createNodeStructureChecker(name, fields)
	  };
	}

	var structure = {
	  getStructureFromConfig: function (config) {
	    var structure = {};

	    if (config.node) {
	      for (var name in config.node) {
	        if (hasOwnProperty$3.call(config.node, name)) {
	          var nodeType = config.node[name];

	          if (nodeType.structure) {
	            structure[name] = processStructure(name, nodeType);
	          } else {
	            throw new Error('Missed `structure` field in `' + name + '` node type definition');
	          }
	        }
	      }
	    }

	    return structure;
	  }
	};

	var SyntaxReferenceError$1 = error$1.SyntaxReferenceError;
	var MatchError$1 = error$1.MatchError;
	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match$1.matchAsTree;
	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	  var result = {};

	  for (var name in map) {
	    if (map[name].syntax) {
	      result[name] = syntaxAsAst ? map[name].syntax : generate_1(map[name].syntax, {
	        compact: compact
	      });
	    }
	  }

	  return result;
	}

	function valueHasVar(tokens) {
	  for (var i = 0; i < tokens.length; i++) {
	    if (tokens[i].value.toLowerCase() === 'var(') {
	      return true;
	    }
	  }

	  return false;
	}

	function buildMatchResult(match, error, iterations) {
	  return {
	    matched: match,
	    iterations: iterations,
	    error: error,
	    getTrace: trace.getTrace,
	    isType: trace.isType,
	    isProperty: trace.isProperty,
	    isKeyword: trace.isKeyword
	  };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	  var tokens = prepareTokens_1(value, lexer.syntax);
	  var result;

	  if (valueHasVar(tokens)) {
	    return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	  }

	  if (useCommon) {
	    result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	  }

	  if (!useCommon || !result.match) {
	    result = matchAsTree$1(tokens, syntax.match, lexer);

	    if (!result.match) {
	      return buildMatchResult(null, new MatchError$1(result.reason, syntax.syntax, value, result), result.iterations);
	    }
	  }

	  return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function (config, syntax, structure) {
	  this.valueCommonSyntax = cssWideKeywords$1;
	  this.syntax = syntax;
	  this.generic = false;
	  this.atrules = {};
	  this.properties = {};
	  this.types = {};
	  this.structure = structure || getStructureFromConfig(config);

	  if (config) {
	    if (config.types) {
	      for (var name in config.types) {
	        this.addType_(name, config.types[name]);
	      }
	    }

	    if (config.generic) {
	      this.generic = true;

	      for (var name in generic) {
	        this.addType_(name, generic[name]);
	      }
	    }

	    if (config.atrules) {
	      for (var name in config.atrules) {
	        this.addAtrule_(name, config.atrules[name]);
	      }
	    }

	    if (config.properties) {
	      for (var name in config.properties) {
	        this.addProperty_(name, config.properties[name]);
	      }
	    }
	  }
	};

	Lexer.prototype = {
	  structure: {},
	  checkStructure: function (ast) {
	    function collectWarning(node, message) {
	      warns.push({
	        node: node,
	        message: message
	      });
	    }

	    var structure = this.structure;
	    var warns = [];
	    this.syntax.walk(ast, function (node) {
	      if (structure.hasOwnProperty(node.type)) {
	        structure[node.type].check(node, collectWarning);
	      } else {
	        collectWarning(node, 'Unknown node type `' + node.type + '`');
	      }
	    });
	    return warns.length ? warns : false;
	  },
	  createDescriptor: function (syntax, type, name) {
	    var ref = {
	      type: type,
	      name: name
	    };
	    var descriptor = {
	      type: type,
	      name: name,
	      syntax: null,
	      match: null
	    };

	    if (typeof syntax === 'function') {
	      descriptor.match = buildMatchGraph$1(syntax, ref);
	    } else {
	      if (typeof syntax === 'string') {
	        // lazy parsing on first access
	        Object.defineProperty(descriptor, 'syntax', {
	          get: function () {
	            Object.defineProperty(descriptor, 'syntax', {
	              value: parse_1(syntax)
	            });
	            return descriptor.syntax;
	          }
	        });
	      } else {
	        descriptor.syntax = syntax;
	      } // lazy graph build on first access


	      Object.defineProperty(descriptor, 'match', {
	        get: function () {
	          Object.defineProperty(descriptor, 'match', {
	            value: buildMatchGraph$1(descriptor.syntax, ref)
	          });
	          return descriptor.match;
	        }
	      });
	    }

	    return descriptor;
	  },
	  addAtrule_: function (name, syntax) {
	    this.atrules[name] = {
	      prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	      descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((res, name) => {
	        res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	        return res;
	      }, {}) : null
	    };
	  },
	  addProperty_: function (name, syntax) {
	    this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	  },
	  addType_: function (name, syntax) {
	    this.types[name] = this.createDescriptor(syntax, 'Type', name);

	    if (syntax === generic['-ms-legacy-expression']) {
	      this.valueCommonSyntax = cssWideKeywordsWithExpression;
	    }
	  },
	  matchAtrulePrelude: function (atruleName, prelude) {
	    var atrule = names.keyword(atruleName);
	    var atrulePreludeSyntax = atrule.vendor ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename) : this.getAtrulePrelude(atrule.name);

	    if (!atrulePreludeSyntax) {
	      if (atrule.basename in this.atrules) {
	        return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	      }

	      return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	    }

	    return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	  },
	  matchAtruleDescriptor: function (atruleName, descriptorName, value) {
	    var atrule = names.keyword(atruleName);
	    var descriptor = names.keyword(descriptorName);
	    var atruleEntry = atrule.vendor ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];

	    if (!atruleEntry) {
	      return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	    }

	    if (!atruleEntry.descriptors) {
	      return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	    }

	    var atruleDescriptorSyntax = descriptor.vendor ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename] : atruleEntry.descriptors[descriptor.name];

	    if (!atruleDescriptorSyntax) {
	      return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	    }

	    return matchSyntax(this, atruleDescriptorSyntax, value, true);
	  },
	  matchDeclaration: function (node) {
	    if (node.type !== 'Declaration') {
	      return buildMatchResult(null, new Error('Not a Declaration node'));
	    }

	    return this.matchProperty(node.property, node.value);
	  },
	  matchProperty: function (propertyName, value) {
	    var property = names.property(propertyName); // don't match syntax for a custom property

	    if (property.custom) {
	      return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	    }

	    var propertySyntax = property.vendor ? this.getProperty(property.name) || this.getProperty(property.basename) : this.getProperty(property.name);

	    if (!propertySyntax) {
	      return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	    }

	    return matchSyntax(this, propertySyntax, value, true);
	  },
	  matchType: function (typeName, value) {
	    var typeSyntax = this.getType(typeName);

	    if (!typeSyntax) {
	      return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	    }

	    return matchSyntax(this, typeSyntax, value, false);
	  },
	  match: function (syntax, value) {
	    if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	      return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	    }

	    if (typeof syntax === 'string' || !syntax.match) {
	      syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	    }

	    return matchSyntax(this, syntax, value, false);
	  },
	  findValueFragments: function (propertyName, value, type, name) {
	    return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	  },
	  findDeclarationValueFragments: function (declaration, type, name) {
	    return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	  },
	  findAllFragments: function (ast, type, name) {
	    var result = [];
	    this.syntax.walk(ast, {
	      visit: 'Declaration',
	      enter: function (declaration) {
	        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	      }.bind(this)
	    });
	    return result;
	  },
	  getAtrulePrelude: function (atruleName) {
	    return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	  },
	  getAtruleDescriptor: function (atruleName, name) {
	    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
	  },
	  getProperty: function (name) {
	    return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	  },
	  getType: function (name) {
	    return this.types.hasOwnProperty(name) ? this.types[name] : null;
	  },
	  validate: function () {
	    function validate(syntax, name, broken, descriptor) {
	      if (broken.hasOwnProperty(name)) {
	        return broken[name];
	      }

	      broken[name] = false;

	      if (descriptor.syntax !== null) {
	        walk(descriptor.syntax, function (node) {
	          if (node.type !== 'Type' && node.type !== 'Property') {
	            return;
	          }

	          var map = node.type === 'Type' ? syntax.types : syntax.properties;
	          var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	          if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	            broken[name] = true;
	          }
	        }, this);
	      }
	    }

	    var brokenTypes = {};
	    var brokenProperties = {};

	    for (var key in this.types) {
	      validate(this, key, brokenTypes, this.types[key]);
	    }

	    for (var key in this.properties) {
	      validate(this, key, brokenProperties, this.properties[key]);
	    }

	    brokenTypes = Object.keys(brokenTypes).filter(function (name) {
	      return brokenTypes[name];
	    });
	    brokenProperties = Object.keys(brokenProperties).filter(function (name) {
	      return brokenProperties[name];
	    });

	    if (brokenTypes.length || brokenProperties.length) {
	      return {
	        types: brokenTypes,
	        properties: brokenProperties
	      };
	    }

	    return null;
	  },
	  dump: function (syntaxAsAst, pretty) {
	    return {
	      generic: this.generic,
	      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	    };
	  },
	  toString: function () {
	    return JSON.stringify(this.dump());
	  }
	};
	var Lexer_1 = Lexer;

	var definitionSyntax = {
	  SyntaxError: _SyntaxError$1,
	  parse: parse_1,
	  generate: generate_1,
	  walk: walk
	};

	var isBOM$2 = tokenizer.isBOM;
	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	  var sourceLength = source.length;
	  var lines = adoptBuffer(host.lines, sourceLength); // +1

	  var line = host.startLine;
	  var columns = adoptBuffer(host.columns, sourceLength);
	  var column = host.startColumn;
	  var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	  for (var i = startOffset; i < sourceLength; i++) {
	    // -1
	    var code = source.charCodeAt(i);
	    lines[i] = line;
	    columns[i] = column++;

	    if (code === N$3 || code === R$2 || code === F$2) {
	      if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	        i++;
	        lines[i] = line;
	        columns[i] = column;
	      }

	      line++;
	      column = 1;
	    }
	  }

	  lines[i] = line;
	  columns[i] = column;
	  host.lines = lines;
	  host.columns = columns;
	}

	var OffsetToLocation = function () {
	  this.lines = null;
	  this.columns = null;
	  this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	  setSource: function (source, startOffset, startLine, startColumn) {
	    this.source = source;
	    this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	    this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	    this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	    this.linesAndColumnsComputed = false;
	  },
	  ensureLinesAndColumnsComputed: function () {
	    if (!this.linesAndColumnsComputed) {
	      computeLinesAndColumns(this, this.source);
	      this.linesAndColumnsComputed = true;
	    }
	  },
	  getLocation: function (offset, filename) {
	    this.ensureLinesAndColumnsComputed();
	    return {
	      source: filename,
	      offset: this.startOffset + offset,
	      line: this.lines[offset],
	      column: this.columns[offset]
	    };
	  },
	  getLocationRange: function (start, end, filename) {
	    this.ensureLinesAndColumnsComputed();
	    return {
	      source: filename,
	      start: {
	        offset: this.startOffset + start,
	        line: this.lines[start],
	        column: this.columns[start]
	      },
	      end: {
	        offset: this.startOffset + end,
	        line: this.lines[end],
	        column: this.columns[end]
	      }
	    };
	  }
	};
	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	  var children = this.createList();
	  var child = null;
	  var context = {
	    recognizer: recognizer,
	    space: null,
	    ignoreWS: false,
	    ignoreWSAfter: false
	  };
	  this.scanner.skipSC();

	  while (!this.scanner.eof) {
	    switch (this.scanner.tokenType) {
	      case COMMENT$2:
	        this.scanner.next();
	        continue;

	      case WHITESPACE$2:
	        if (context.ignoreWS) {
	          this.scanner.next();
	        } else {
	          context.space = this.WhiteSpace();
	        }

	        continue;
	    }

	    child = recognizer.getNode.call(this, context);

	    if (child === undefined) {
	      break;
	    }

	    if (context.space !== null) {
	      children.push(context.space);
	      context.space = null;
	    }

	    children.push(child);

	    if (context.ignoreWSAfter) {
	      context.ignoreWSAfter = false;
	      context.ignoreWS = true;
	    } else {
	      context.ignoreWS = false;
	    }
	  }

	  return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function () {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)

	var NULL = 0;

	function createParseContext(name) {
	  return function () {
	    return this[name]();
	  };
	}

	function processConfig(config) {
	  var parserConfig = {
	    context: {},
	    scope: {},
	    atrule: {},
	    pseudo: {}
	  };

	  if (config.parseContext) {
	    for (var name in config.parseContext) {
	      switch (typeof config.parseContext[name]) {
	        case 'function':
	          parserConfig.context[name] = config.parseContext[name];
	          break;

	        case 'string':
	          parserConfig.context[name] = createParseContext(config.parseContext[name]);
	          break;
	      }
	    }
	  }

	  if (config.scope) {
	    for (var name in config.scope) {
	      parserConfig.scope[name] = config.scope[name];
	    }
	  }

	  if (config.atrule) {
	    for (var name in config.atrule) {
	      var atrule = config.atrule[name];

	      if (atrule.parse) {
	        parserConfig.atrule[name] = atrule.parse;
	      }
	    }
	  }

	  if (config.pseudo) {
	    for (var name in config.pseudo) {
	      var pseudo = config.pseudo[name];

	      if (pseudo.parse) {
	        parserConfig.pseudo[name] = pseudo.parse;
	      }
	    }
	  }

	  if (config.node) {
	    for (var name in config.node) {
	      parserConfig[name] = config.node[name].parse;
	    }
	  }

	  return parserConfig;
	}

	var create = function createParser(config) {
	  var parser = {
	    scanner: new TokenStream_1(),
	    locationMap: new OffsetToLocation_1(),
	    filename: '<unknown>',
	    needPositions: false,
	    onParseError: noop$3,
	    onParseErrorThrow: false,
	    parseAtrulePrelude: true,
	    parseRulePrelude: true,
	    parseValue: true,
	    parseCustomProperty: false,
	    readSequence: sequence,
	    createList: function () {
	      return new List_1();
	    },
	    createSingleNodeList: function (node) {
	      return new List_1().appendData(node);
	    },
	    getFirstListNode: function (list) {
	      return list && list.first();
	    },
	    getLastListNode: function (list) {
	      return list.last();
	    },
	    parseWithFallback: function (consumer, fallback) {
	      var startToken = this.scanner.tokenIndex;

	      try {
	        return consumer.call(this);
	      } catch (e) {
	        if (this.onParseErrorThrow) {
	          throw e;
	        }

	        var fallbackNode = fallback.call(this, startToken);
	        this.onParseErrorThrow = true;
	        this.onParseError(e, fallbackNode);
	        this.onParseErrorThrow = false;
	        return fallbackNode;
	      }
	    },
	    lookupNonWSType: function (offset) {
	      do {
	        var type = this.scanner.lookupType(offset++);

	        if (type !== WHITESPACE$3) {
	          return type;
	        }
	      } while (type !== NULL);

	      return NULL;
	    },
	    eat: function (tokenType) {
	      if (this.scanner.tokenType !== tokenType) {
	        var offset = this.scanner.tokenStart;
	        var message = NAME$2[tokenType] + ' is expected'; // tweak message and offset

	        switch (tokenType) {
	          case IDENT$2:
	            // when identifier is expected but there is a function or url
	            if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {
	              offset = this.scanner.tokenEnd - 1;
	              message = 'Identifier is expected but function found';
	            } else {
	              message = 'Identifier is expected';
	            }

	            break;

	          case HASH:
	            if (this.scanner.isDelim(NUMBERSIGN$1)) {
	              this.scanner.next();
	              offset++;
	              message = 'Name is expected';
	            }

	            break;

	          case PERCENTAGE:
	            if (this.scanner.tokenType === NUMBER$2) {
	              offset = this.scanner.tokenEnd;
	              message = 'Percent sign is expected';
	            }

	            break;

	          default:
	            // when test type is part of another token show error for current position + 1
	            // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	              offset = offset + 1;
	            }

	        }

	        this.error(message, offset);
	      }

	      this.scanner.next();
	    },
	    consume: function (tokenType) {
	      var value = this.scanner.getTokenValue();
	      this.eat(tokenType);
	      return value;
	    },
	    consumeFunctionName: function () {
	      var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);
	      this.eat(FUNCTION);
	      return name;
	    },
	    getLocation: function (start, end) {
	      if (this.needPositions) {
	        return this.locationMap.getLocationRange(start, end, this.filename);
	      }

	      return null;
	    },
	    getLocationFromList: function (list) {
	      if (this.needPositions) {
	        var head = this.getFirstListNode(list);
	        var tail = this.getLastListNode(list);
	        return this.locationMap.getLocationRange(head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart, tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart, this.filename);
	      }

	      return null;
	    },
	    error: function (message, offset) {
	      var location = typeof offset !== 'undefined' && offset < this.scanner.source.length ? this.locationMap.getLocation(offset) : this.scanner.eof ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1)) : this.locationMap.getLocation(this.scanner.tokenStart);
	      throw new _SyntaxError(message || 'Unexpected input', this.scanner.source, location.offset, location.line, location.column);
	    }
	  };
	  config = processConfig(config || {});

	  for (var key in config) {
	    parser[key] = config[key];
	  }

	  return function (source, options) {
	    options = options || {};
	    var context = options.context || 'default';
	    var ast;
	    tokenizer(source, parser.scanner);
	    parser.locationMap.setSource(source, options.offset, options.line, options.column);
	    parser.filename = options.filename || '<unknown>';
	    parser.needPositions = Boolean(options.positions);
	    parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	    parser.onParseErrorThrow = false;
	    parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	    parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	    parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	    parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	    if (!parser.context.hasOwnProperty(context)) {
	      throw new Error('Unknown context `' + context + '`');
	    }

	    ast = parser.context[context].call(parser, options);

	    if (!parser.scanner.eof) {
	      parser.error();
	    }

	    return ast;
	  };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */

	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }

	  throw new TypeError("Must be between 0 and 63: " + number);
	};
	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */


	var decode = function (charCode) {
	  var bigA = 65; // 'A'

	  var bigZ = 90; // 'Z'

	  var littleA = 97; // 'a'

	  var littleZ = 122; // 'z'

	  var zero = 48; // '0'

	  var nine = 57; // '9'

	  var plus = 43; // '+'

	  var slash = 47; // '/'

	  var littleOffset = 26;
	  var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ

	  if (bigA <= charCode && charCode <= bigZ) {
	    return charCode - bigA;
	  } // 26 - 51: abcdefghijklmnopqrstuvwxyz


	  if (littleA <= charCode && charCode <= littleZ) {
	    return charCode - littleA + littleOffset;
	  } // 52 - 61: 0123456789


	  if (zero <= charCode && charCode <= nine) {
	    return charCode - zero + numberOffset;
	  } // 62: +


	  if (charCode == plus) {
	    return 62;
	  } // 63: /


	  if (charCode == slash) {
	    return 63;
	  } // Invalid base64 digit.


	  return -1;
	};

	var base64 = {
	  encode: encode,
	  decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5; // binary: 100000

	var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111

	var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000

	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */

	function toVLQSigned(aValue) {
	  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
	}
	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */


	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative ? -shifted : shifted;
	}
	/**
	 * Returns the base 64 VLQ encoded value.
	 */


	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;
	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;

	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }

	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};
	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */


	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));

	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
	  encode: encode$1,
	  decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	  /* -*- Mode: js; js-indent-level: 2; -*- */

	  /*
	   * Copyright 2011 Mozilla Foundation and contributors
	   * Licensed under the New BSD license. See LICENSE or:
	   * http://opensource.org/licenses/BSD-3-Clause
	   */

	  /**
	   * This is a helper function for getting values from parameter/options
	   * objects.
	   *
	   * @param args The object we are extracting values from
	   * @param name The name of the property we are getting.
	   * @param defaultValue An optional value to return if the property is missing
	   * from the object. If this is not specified and the property is missing, an
	   * error will be thrown.
	   */
	  function getArg(aArgs, aName, aDefaultValue) {
	    if (aName in aArgs) {
	      return aArgs[aName];
	    } else if (arguments.length === 3) {
	      return aDefaultValue;
	    } else {
	      throw new Error('"' + aName + '" is a required argument.');
	    }
	  }

	  exports.getArg = getArg;
	  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	  var dataUrlRegexp = /^data:.+\,.+$/;

	  function urlParse(aUrl) {
	    var match = aUrl.match(urlRegexp);

	    if (!match) {
	      return null;
	    }

	    return {
	      scheme: match[1],
	      auth: match[2],
	      host: match[3],
	      port: match[4],
	      path: match[5]
	    };
	  }

	  exports.urlParse = urlParse;

	  function urlGenerate(aParsedUrl) {
	    var url = '';

	    if (aParsedUrl.scheme) {
	      url += aParsedUrl.scheme + ':';
	    }

	    url += '//';

	    if (aParsedUrl.auth) {
	      url += aParsedUrl.auth + '@';
	    }

	    if (aParsedUrl.host) {
	      url += aParsedUrl.host;
	    }

	    if (aParsedUrl.port) {
	      url += ":" + aParsedUrl.port;
	    }

	    if (aParsedUrl.path) {
	      url += aParsedUrl.path;
	    }

	    return url;
	  }

	  exports.urlGenerate = urlGenerate;
	  /**
	   * Normalizes a path, or the path portion of a URL:
	   *
	   * - Replaces consecutive slashes with one slash.
	   * - Removes unnecessary '.' parts.
	   * - Removes unnecessary '<dir>/..' parts.
	   *
	   * Based on code in the Node.js 'path' core module.
	   *
	   * @param aPath The path or url to normalize.
	   */

	  function normalize(aPath) {
	    var path = aPath;
	    var url = urlParse(aPath);

	    if (url) {
	      if (!url.path) {
	        return aPath;
	      }

	      path = url.path;
	    }

	    var isAbsolute = exports.isAbsolute(path);
	    var parts = path.split(/\/+/);

	    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	      part = parts[i];

	      if (part === '.') {
	        parts.splice(i, 1);
	      } else if (part === '..') {
	        up++;
	      } else if (up > 0) {
	        if (part === '') {
	          // The first part is blank if the path is absolute. Trying to go
	          // above the root is a no-op. Therefore we can remove all '..' parts
	          // directly after the root.
	          parts.splice(i + 1, up);
	          up = 0;
	        } else {
	          parts.splice(i, 2);
	          up--;
	        }
	      }
	    }

	    path = parts.join('/');

	    if (path === '') {
	      path = isAbsolute ? '/' : '.';
	    }

	    if (url) {
	      url.path = path;
	      return urlGenerate(url);
	    }

	    return path;
	  }

	  exports.normalize = normalize;
	  /**
	   * Joins two paths/URLs.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be joined with the root.
	   *
	   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	   *   first.
	   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	   *   is updated with the result and aRoot is returned. Otherwise the result
	   *   is returned.
	   *   - If aPath is absolute, the result is aPath.
	   *   - Otherwise the two paths are joined with a slash.
	   * - Joining for example 'http://' and 'www.example.com' is also supported.
	   */

	  function join(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }

	    if (aPath === "") {
	      aPath = ".";
	    }

	    var aPathUrl = urlParse(aPath);
	    var aRootUrl = urlParse(aRoot);

	    if (aRootUrl) {
	      aRoot = aRootUrl.path || '/';
	    } // `join(foo, '//www.example.org')`


	    if (aPathUrl && !aPathUrl.scheme) {
	      if (aRootUrl) {
	        aPathUrl.scheme = aRootUrl.scheme;
	      }

	      return urlGenerate(aPathUrl);
	    }

	    if (aPathUrl || aPath.match(dataUrlRegexp)) {
	      return aPath;
	    } // `join('http://', 'www.example.com')`


	    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	      aRootUrl.host = aPath;
	      return urlGenerate(aRootUrl);
	    }

	    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	    if (aRootUrl) {
	      aRootUrl.path = joined;
	      return urlGenerate(aRootUrl);
	    }

	    return joined;
	  }

	  exports.join = join;

	  exports.isAbsolute = function (aPath) {
	    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	  };
	  /**
	   * Make a path relative to a URL or another path.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be made relative to aRoot.
	   */


	  function relative(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }

	    aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
	    // checking whether the root is a prefix of the path won't work. Instead, we
	    // need to remove components from the root one by one, until either we find
	    // a prefix that fits, or we run out of components to remove.

	    var level = 0;

	    while (aPath.indexOf(aRoot + '/') !== 0) {
	      var index = aRoot.lastIndexOf("/");

	      if (index < 0) {
	        return aPath;
	      } // If the only part of the root that is left is the scheme (i.e. http://,
	      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	      // have exhausted all components, so the path is not relative to the root.


	      aRoot = aRoot.slice(0, index);

	      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	        return aPath;
	      }

	      ++level;
	    } // Make sure we add a "../" for each component we removed from the root.


	    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	  }

	  exports.relative = relative;

	  var supportsNullProto = function () {
	    var obj = Object.create(null);
	    return !('__proto__' in obj);
	  }();

	  function identity(s) {
	    return s;
	  }
	  /**
	   * Because behavior goes wacky when you set `__proto__` on objects, we
	   * have to prefix all the strings in our set with an arbitrary character.
	   *
	   * See https://github.com/mozilla/source-map/pull/31 and
	   * https://github.com/mozilla/source-map/issues/30
	   *
	   * @param String aStr
	   */


	  function toSetString(aStr) {
	    if (isProtoString(aStr)) {
	      return '$' + aStr;
	    }

	    return aStr;
	  }

	  exports.toSetString = supportsNullProto ? identity : toSetString;

	  function fromSetString(aStr) {
	    if (isProtoString(aStr)) {
	      return aStr.slice(1);
	    }

	    return aStr;
	  }

	  exports.fromSetString = supportsNullProto ? identity : fromSetString;

	  function isProtoString(s) {
	    if (!s) {
	      return false;
	    }

	    var length = s.length;

	    if (length < 9
	    /* "__proto__".length */
	    ) {
	        return false;
	      }

	    if (s.charCodeAt(length - 1) !== 95
	    /* '_' */
	    || s.charCodeAt(length - 2) !== 95
	    /* '_' */
	    || s.charCodeAt(length - 3) !== 111
	    /* 'o' */
	    || s.charCodeAt(length - 4) !== 116
	    /* 't' */
	    || s.charCodeAt(length - 5) !== 111
	    /* 'o' */
	    || s.charCodeAt(length - 6) !== 114
	    /* 'r' */
	    || s.charCodeAt(length - 7) !== 112
	    /* 'p' */
	    || s.charCodeAt(length - 8) !== 95
	    /* '_' */
	    || s.charCodeAt(length - 9) !== 95
	    /* '_' */
	    ) {
	        return false;
	      }

	    for (var i = length - 10; i >= 0; i--) {
	      if (s.charCodeAt(i) !== 36
	      /* '$' */
	      ) {
	          return false;
	        }
	    }

	    return true;
	  }
	  /**
	   * Comparator between two mappings where the original positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same original source/line/column, but different generated
	   * line and column the same. Useful when searching for a mapping with a
	   * stubbed out mapping.
	   */


	  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	    var cmp = strcmp(mappingA.source, mappingB.source);

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalLine - mappingB.originalLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalColumn - mappingB.originalColumn;

	    if (cmp !== 0 || onlyCompareOriginal) {
	      return cmp;
	    }

	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.generatedLine - mappingB.generatedLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    return strcmp(mappingA.name, mappingB.name);
	  }

	  exports.compareByOriginalPositions = compareByOriginalPositions;
	  /**
	   * Comparator between two mappings with deflated source and name indices where
	   * the generated positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same generated line and column, but different
	   * source/name/original line and column the same. Useful when searching for a
	   * mapping with a stubbed out mapping.
	   */

	  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

	    if (cmp !== 0 || onlyCompareGenerated) {
	      return cmp;
	    }

	    cmp = strcmp(mappingA.source, mappingB.source);

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalLine - mappingB.originalLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalColumn - mappingB.originalColumn;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    return strcmp(mappingA.name, mappingB.name);
	  }

	  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	  function strcmp(aStr1, aStr2) {
	    if (aStr1 === aStr2) {
	      return 0;
	    }

	    if (aStr1 === null) {
	      return 1; // aStr2 !== null
	    }

	    if (aStr2 === null) {
	      return -1; // aStr1 !== null
	    }

	    if (aStr1 > aStr2) {
	      return 1;
	    }

	    return -1;
	  }
	  /**
	   * Comparator between two mappings with inflated source and name strings where
	   * the generated positions are compared.
	   */


	  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = strcmp(mappingA.source, mappingB.source);

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalLine - mappingB.originalLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalColumn - mappingB.originalColumn;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    return strcmp(mappingA.name, mappingB.name);
	  }

	  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	  /**
	   * Strip any JSON XSSI avoidance prefix from the string (as documented
	   * in the source maps specification), and then parse the string as
	   * JSON.
	   */

	  function parseSourceMapInput(str) {
	    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	  }

	  exports.parseSourceMapInput = parseSourceMapInput;
	  /**
	   * Compute the URL of a source given the the source root, the source's
	   * URL, and the source map's URL.
	   */

	  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	    sourceURL = sourceURL || '';

	    if (sourceRoot) {
	      // This follows what Chrome does.
	      if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	        sourceRoot += '/';
	      } // The spec says:
	      //   Line 4: An optional source root, useful for relocating source
	      //   files on a server or removing repeated values in the
	      //   “sources” entry.  This value is prepended to the individual
	      //   entries in the “source” field.


	      sourceURL = sourceRoot + sourceURL;
	    } // Historically, SourceMapConsumer did not take the sourceMapURL as
	    // a parameter.  This mode is still somewhat supported, which is why
	    // this code block is conditional.  However, it's preferable to pass
	    // the source map URL to SourceMapConsumer, so that this function
	    // can implement the source URL resolution algorithm as outlined in
	    // the spec.  This block is basically the equivalent of:
	    //    new URL(sourceURL, sourceMapURL).toString()
	    // ... except it avoids using URL, which wasn't available in the
	    // older releases of node still supported by this library.
	    //
	    // The spec says:
	    //   If the sources are not absolute URLs after prepending of the
	    //   “sourceRoot”, the sources are resolved relative to the
	    //   SourceMap (like resolving script src in a html document).


	    if (sourceMapURL) {
	      var parsed = urlParse(sourceMapURL);

	      if (!parsed) {
	        throw new Error("sourceMapURL could not be parsed");
	      }

	      if (parsed.path) {
	        // Strip the last path component, but keep the "/".
	        var index = parsed.path.lastIndexOf('/');

	        if (index >= 0) {
	          parsed.path = parsed.path.substring(0, index + 1);
	        }
	      }

	      sourceURL = join(urlGenerate(parsed), sourceURL);
	    }

	    return normalize(sourceURL);
	  }

	  exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */

	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";
	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */

	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}
	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */


	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();

	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }

	  return set;
	};
	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */


	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};
	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */


	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;

	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }

	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};
	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */


	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};
	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */


	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);

	    if (idx >= 0) {
	      return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);

	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};
	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */


	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }

	  throw new Error('No element indexed by ' + aIdx);
	};
	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */


	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;
	var arraySet = {
	  ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */

	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}
	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */


	function MappingList() {
	  this._array = [];
	  this._sorted = true; // Serves as infimum

	  this._last = {
	    generatedLine: -1,
	    generatedColumn: 0
	  };
	}
	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */


	MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
	  this._array.forEach(aCallback, aThisArg);
	};
	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */


	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;

	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;

	    this._array.push(aMapping);
	  }
	};
	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */


	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);

	    this._sorted = true;
	  }

	  return this._array;
	};

	var MappingList_1 = MappingList;
	var mappingList = {
	  MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;
	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */

	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }

	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;
	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */

	SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	  var sourceRoot = aSourceMapConsumer.sourceRoot;
	  var generator = new SourceMapGenerator({
	    file: aSourceMapConsumer.file,
	    sourceRoot: sourceRoot
	  });
	  aSourceMapConsumer.eachMapping(function (mapping) {
	    var newMapping = {
	      generated: {
	        line: mapping.generatedLine,
	        column: mapping.generatedColumn
	      }
	    };

	    if (mapping.source != null) {
	      newMapping.source = mapping.source;

	      if (sourceRoot != null) {
	        newMapping.source = util.relative(sourceRoot, newMapping.source);
	      }

	      newMapping.original = {
	        line: mapping.originalLine,
	        column: mapping.originalColumn
	      };

	      if (mapping.name != null) {
	        newMapping.name = mapping.name;
	      }
	    }

	    generator.addMapping(newMapping);
	  });
	  aSourceMapConsumer.sources.forEach(function (sourceFile) {
	    var sourceRelative = sourceFile;

	    if (sourceRoot !== null) {
	      sourceRelative = util.relative(sourceRoot, sourceFile);
	    }

	    if (!generator._sources.has(sourceRelative)) {
	      generator._sources.add(sourceRelative);
	    }

	    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

	    if (content != null) {
	      generator.setSourceContent(sourceFile, content);
	    }
	  });
	  return generator;
	};
	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */


	SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
	  var generated = util.getArg(aArgs, 'generated');
	  var original = util.getArg(aArgs, 'original', null);
	  var source = util.getArg(aArgs, 'source', null);
	  var name = util.getArg(aArgs, 'name', null);

	  if (!this._skipValidation) {
	    this._validateMapping(generated, original, source, name);
	  }

	  if (source != null) {
	    source = String(source);

	    if (!this._sources.has(source)) {
	      this._sources.add(source);
	    }
	  }

	  if (name != null) {
	    name = String(name);

	    if (!this._names.has(name)) {
	      this._names.add(name);
	    }
	  }

	  this._mappings.add({
	    generatedLine: generated.line,
	    generatedColumn: generated.column,
	    originalLine: original != null && original.line,
	    originalColumn: original != null && original.column,
	    source: source,
	    name: name
	  });
	};
	/**
	 * Set the source content for a source file.
	 */


	SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	  var source = aSourceFile;

	  if (this._sourceRoot != null) {
	    source = util.relative(this._sourceRoot, source);
	  }

	  if (aSourceContent != null) {
	    // Add the source content to the _sourcesContents map.
	    // Create a new _sourcesContents map if the property is null.
	    if (!this._sourcesContents) {
	      this._sourcesContents = Object.create(null);
	    }

	    this._sourcesContents[util.toSetString(source)] = aSourceContent;
	  } else if (this._sourcesContents) {
	    // Remove the source file from the _sourcesContents map.
	    // If the _sourcesContents map is empty, set the property to null.
	    delete this._sourcesContents[util.toSetString(source)];

	    if (Object.keys(this._sourcesContents).length === 0) {
	      this._sourcesContents = null;
	    }
	  }
	};
	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */


	SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	  var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap

	  if (aSourceFile == null) {
	    if (aSourceMapConsumer.file == null) {
	      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
	    }

	    sourceFile = aSourceMapConsumer.file;
	  }

	  var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.

	  if (sourceRoot != null) {
	    sourceFile = util.relative(sourceRoot, sourceFile);
	  } // Applying the SourceMap can add and remove items from the sources and
	  // the names array.


	  var newSources = new ArraySet$1();
	  var newNames = new ArraySet$1(); // Find mappings for the "sourceFile"

	  this._mappings.unsortedForEach(function (mapping) {
	    if (mapping.source === sourceFile && mapping.originalLine != null) {
	      // Check if it can be mapped by the source map, then update the mapping.
	      var original = aSourceMapConsumer.originalPositionFor({
	        line: mapping.originalLine,
	        column: mapping.originalColumn
	      });

	      if (original.source != null) {
	        // Copy mapping
	        mapping.source = original.source;

	        if (aSourceMapPath != null) {
	          mapping.source = util.join(aSourceMapPath, mapping.source);
	        }

	        if (sourceRoot != null) {
	          mapping.source = util.relative(sourceRoot, mapping.source);
	        }

	        mapping.originalLine = original.line;
	        mapping.originalColumn = original.column;

	        if (original.name != null) {
	          mapping.name = original.name;
	        }
	      }
	    }

	    var source = mapping.source;

	    if (source != null && !newSources.has(source)) {
	      newSources.add(source);
	    }

	    var name = mapping.name;

	    if (name != null && !newNames.has(name)) {
	      newNames.add(name);
	    }
	  }, this);

	  this._sources = newSources;
	  this._names = newNames; // Copy sourcesContents of applied map.

	  aSourceMapConsumer.sources.forEach(function (sourceFile) {
	    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

	    if (content != null) {
	      if (aSourceMapPath != null) {
	        sourceFile = util.join(aSourceMapPath, sourceFile);
	      }

	      if (sourceRoot != null) {
	        sourceFile = util.relative(sourceRoot, sourceFile);
	      }

	      this.setSourceContent(sourceFile, content);
	    }
	  }, this);
	};
	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */


	SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
	  // When aOriginal is truthy but has empty values for .line and .column,
	  // it is most likely a programmer error. In this case we throw a very
	  // specific error message to try to guide them the right way.
	  // For example: https://github.com/Polymer/polymer-bundler/pull/519
	  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
	  }

	  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
	    // Case 1.
	    return;
	  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
	    // Cases 2 and 3.
	    return;
	  } else {
	    throw new Error('Invalid mapping: ' + JSON.stringify({
	      generated: aGenerated,
	      source: aSource,
	      original: aOriginal,
	      name: aName
	    }));
	  }
	};
	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */


	SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
	  var previousGeneratedColumn = 0;
	  var previousGeneratedLine = 1;
	  var previousOriginalColumn = 0;
	  var previousOriginalLine = 0;
	  var previousName = 0;
	  var previousSource = 0;
	  var result = '';
	  var next;
	  var mapping;
	  var nameIdx;
	  var sourceIdx;

	  var mappings = this._mappings.toArray();

	  for (var i = 0, len = mappings.length; i < len; i++) {
	    mapping = mappings[i];
	    next = '';

	    if (mapping.generatedLine !== previousGeneratedLine) {
	      previousGeneratedColumn = 0;

	      while (mapping.generatedLine !== previousGeneratedLine) {
	        next += ';';
	        previousGeneratedLine++;
	      }
	    } else {
	      if (i > 0) {
	        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	          continue;
	        }

	        next += ',';
	      }
	    }

	    next += base64Vlq.encode(mapping.generatedColumn - previousGeneratedColumn);
	    previousGeneratedColumn = mapping.generatedColumn;

	    if (mapping.source != null) {
	      sourceIdx = this._sources.indexOf(mapping.source);
	      next += base64Vlq.encode(sourceIdx - previousSource);
	      previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3

	      next += base64Vlq.encode(mapping.originalLine - 1 - previousOriginalLine);
	      previousOriginalLine = mapping.originalLine - 1;
	      next += base64Vlq.encode(mapping.originalColumn - previousOriginalColumn);
	      previousOriginalColumn = mapping.originalColumn;

	      if (mapping.name != null) {
	        nameIdx = this._names.indexOf(mapping.name);
	        next += base64Vlq.encode(nameIdx - previousName);
	        previousName = nameIdx;
	      }
	    }

	    result += next;
	  }

	  return result;
	};

	SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	  return aSources.map(function (source) {
	    if (!this._sourcesContents) {
	      return null;
	    }

	    if (aSourceRoot != null) {
	      source = util.relative(aSourceRoot, source);
	    }

	    var key = util.toSetString(source);
	    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
	  }, this);
	};
	/**
	 * Externalize the source map.
	 */


	SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
	  var map = {
	    version: this._version,
	    sources: this._sources.toArray(),
	    names: this._names.toArray(),
	    mappings: this._serializeMappings()
	  };

	  if (this._file != null) {
	    map.file = this._file;
	  }

	  if (this._sourceRoot != null) {
	    map.sourceRoot = this._sourceRoot;
	  }

	  if (this._sourcesContents) {
	    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	  }

	  return map;
	};
	/**
	 * Render the source map being generated to a string.
	 */


	SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
	  return JSON.stringify(this.toJSON());
	};

	var SourceMapGenerator_1 = SourceMapGenerator;
	var sourceMapGenerator = {
	  SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	  Atrule: true,
	  Selector: true,
	  Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	  var map = new SourceMapGenerator$1();
	  var line = 1;
	  var column = 0;
	  var generated = {
	    line: 1,
	    column: 0
	  };
	  var original = {
	    line: 0,
	    // should be zero to add first mapping
	    column: 0
	  };
	  var sourceMappingActive = false;
	  var activatedGenerated = {
	    line: 1,
	    column: 0
	  };
	  var activatedMapping = {
	    generated: activatedGenerated
	  };
	  var handlersNode = handlers.node;

	  handlers.node = function (node) {
	    if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	      var nodeLine = node.loc.start.line;
	      var nodeColumn = node.loc.start.column - 1;

	      if (original.line !== nodeLine || original.column !== nodeColumn) {
	        original.line = nodeLine;
	        original.column = nodeColumn;
	        generated.line = line;
	        generated.column = column;

	        if (sourceMappingActive) {
	          sourceMappingActive = false;

	          if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
	            map.addMapping(activatedMapping);
	          }
	        }

	        sourceMappingActive = true;
	        map.addMapping({
	          source: node.loc.source,
	          original: original,
	          generated: generated
	        });
	      }
	    }

	    handlersNode.call(this, node);

	    if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	      activatedGenerated.line = line;
	      activatedGenerated.column = column;
	    }
	  };

	  var handlersChunk = handlers.chunk;

	  handlers.chunk = function (chunk) {
	    for (var i = 0; i < chunk.length; i++) {
	      if (chunk.charCodeAt(i) === 10) {
	        // \n
	        line++;
	        column = 0;
	      } else {
	        column++;
	      }
	    }

	    handlersChunk(chunk);
	  };

	  var handlersResult = handlers.result;

	  handlers.result = function () {
	    if (sourceMappingActive) {
	      map.addMapping(activatedMapping);
	    }

	    return {
	      css: handlersResult(),
	      map: map
	    };
	  };

	  return handlers;
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	  var list = node.children;
	  var prev = null;

	  if (typeof delimeter !== 'function') {
	    list.forEach(this.node, this);
	  } else {
	    list.forEach(function (node) {
	      if (prev !== null) {
	        delimeter.call(this, prev);
	      }

	      this.node(node);
	      prev = node;
	    }, this);
	  }
	}

	var create$1 = function createGenerator(config) {
	  function processNode(node) {
	    if (hasOwnProperty$4.call(types, node.type)) {
	      types[node.type].call(this, node);
	    } else {
	      throw new Error('Unknown node type: ' + node.type);
	    }
	  }

	  var types = {};

	  if (config.node) {
	    for (var name in config.node) {
	      types[name] = config.node[name].generate;
	    }
	  }

	  return function (node, options) {
	    var buffer = '';
	    var handlers = {
	      children: processChildren,
	      node: processNode,
	      chunk: function (chunk) {
	        buffer += chunk;
	      },
	      result: function () {
	        return buffer;
	      }
	    };

	    if (options) {
	      if (typeof options.decorator === 'function') {
	        handlers = options.decorator(handlers);
	      }

	      if (options.sourceMap) {
	        handlers = sourceMap(handlers);
	      }
	    }

	    handlers.node(node);
	    return handlers.result();
	  };
	};

	var create$2 = function createConvertors(walk) {
	  return {
	    fromPlainObject: function (ast) {
	      walk(ast, {
	        enter: function (node) {
	          if (node.children && node.children instanceof List_1 === false) {
	            node.children = new List_1().fromArray(node.children);
	          }
	        }
	      });
	      return ast;
	    },
	    toPlainObject: function (ast) {
	      walk(ast, {
	        leave: function (node) {
	          if (node.children && node.children instanceof List_1) {
	            node.children = node.children.toArray();
	          }
	        }
	      });
	      return ast;
	    }
	  };
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;

	var noop$4 = function () {};

	function ensureFunction$1(value) {
	  return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	  return function (node, item, list) {
	    if (node.type === type) {
	      fn.call(this, node, item, list);
	    }
	  };
	}

	function getWalkersFromStructure(name, nodeType) {
	  var structure = nodeType.structure;
	  var walkers = [];

	  for (var key in structure) {
	    if (hasOwnProperty$5.call(structure, key) === false) {
	      continue;
	    }

	    var fieldTypes = structure[key];
	    var walker = {
	      name: key,
	      type: false,
	      nullable: false
	    };

	    if (!Array.isArray(structure[key])) {
	      fieldTypes = [structure[key]];
	    }

	    for (var i = 0; i < fieldTypes.length; i++) {
	      var fieldType = fieldTypes[i];

	      if (fieldType === null) {
	        walker.nullable = true;
	      } else if (typeof fieldType === 'string') {
	        walker.type = 'node';
	      } else if (Array.isArray(fieldType)) {
	        walker.type = 'list';
	      }
	    }

	    if (walker.type) {
	      walkers.push(walker);
	    }
	  }

	  if (walkers.length) {
	    return {
	      context: nodeType.walkContext,
	      fields: walkers
	    };
	  }

	  return null;
	}

	function getTypesFromConfig(config) {
	  var types = {};

	  for (var name in config.node) {
	    if (hasOwnProperty$5.call(config.node, name)) {
	      var nodeType = config.node[name];

	      if (!nodeType.structure) {
	        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	      }

	      types[name] = getWalkersFromStructure(name, nodeType);
	    }
	  }

	  return types;
	}

	function createTypeIterator(config, reverse) {
	  var fields = config.fields.slice();
	  var contextName = config.context;
	  var useContext = typeof contextName === 'string';

	  if (reverse) {
	    fields.reverse();
	  }

	  return function (node, context, walk) {
	    var prevContextValue;

	    if (useContext) {
	      prevContextValue = context[contextName];
	      context[contextName] = node;
	    }

	    for (var i = 0; i < fields.length; i++) {
	      var field = fields[i];
	      var ref = node[field.name];

	      if (!field.nullable || ref) {
	        if (field.type === 'list') {
	          if (reverse) {
	            ref.forEachRight(walk);
	          } else {
	            ref.forEach(walk);
	          }
	        } else {
	          walk(ref);
	        }
	      }
	    }

	    if (useContext) {
	      context[contextName] = prevContextValue;
	    }
	  };
	}

	function createFastTraveralMap(iterators) {
	  return {
	    Atrule: {
	      StyleSheet: iterators.StyleSheet,
	      Atrule: iterators.Atrule,
	      Rule: iterators.Rule,
	      Block: iterators.Block
	    },
	    Rule: {
	      StyleSheet: iterators.StyleSheet,
	      Atrule: iterators.Atrule,
	      Rule: iterators.Rule,
	      Block: iterators.Block
	    },
	    Declaration: {
	      StyleSheet: iterators.StyleSheet,
	      Atrule: iterators.Atrule,
	      Rule: iterators.Rule,
	      Block: iterators.Block,
	      DeclarationList: iterators.DeclarationList
	    }
	  };
	}

	var create$3 = function createWalker(config) {
	  var types = getTypesFromConfig(config);
	  var iteratorsNatural = {};
	  var iteratorsReverse = {};

	  for (var name in types) {
	    if (hasOwnProperty$5.call(types, name) && types[name] !== null) {
	      iteratorsNatural[name] = createTypeIterator(types[name], false);
	      iteratorsReverse[name] = createTypeIterator(types[name], true);
	    }
	  }

	  var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	  var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	  var walk = function (root, options) {
	    function walkNode(node, item, list) {
	      enter.call(context, node, item, list);

	      if (iterators.hasOwnProperty(node.type)) {
	        iterators[node.type](node, context, walkNode);
	      }

	      leave.call(context, node, item, list);
	    }

	    var enter = noop$4;
	    var leave = noop$4;
	    var iterators = iteratorsNatural;
	    var context = {
	      root: root,
	      stylesheet: null,
	      atrule: null,
	      atrulePrelude: null,
	      rule: null,
	      selector: null,
	      block: null,
	      declaration: null,
	      function: null
	    };

	    if (typeof options === 'function') {
	      enter = options;
	    } else if (options) {
	      enter = ensureFunction$1(options.enter);
	      leave = ensureFunction$1(options.leave);

	      if (options.reverse) {
	        iterators = iteratorsReverse;
	      }

	      if (options.visit) {
	        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	          iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
	        } else if (!types.hasOwnProperty(options.visit)) {
	          throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	        }

	        enter = invokeForType(enter, options.visit);
	        leave = invokeForType(leave, options.visit);
	      }
	    }

	    if (enter === noop$4 && leave === noop$4) {
	      throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    } // swap handlers in reverse mode to invert visit order


	    if (options.reverse) {
	      var tmp = enter;
	      enter = leave;
	      leave = tmp;
	    }

	    walkNode(root);
	  };

	  walk.find = function (ast, fn) {
	    var found = null;
	    walk(ast, function (node, item, list) {
	      if (found === null && fn.call(this, node, item, list)) {
	        found = node;
	      }
	    });
	    return found;
	  };

	  walk.findLast = function (ast, fn) {
	    var found = null;
	    walk(ast, {
	      reverse: true,
	      enter: function (node, item, list) {
	        if (found === null && fn.call(this, node, item, list)) {
	          found = node;
	        }
	      }
	    });
	    return found;
	  };

	  walk.findAll = function (ast, fn) {
	    var found = [];
	    walk(ast, function (node, item, list) {
	      if (fn.call(this, node, item, list)) {
	        found.push(node);
	      }
	    });
	    return found;
	  };

	  return walk;
	};

	var clone$1 = function clone(node) {
	  var result = {};

	  for (var key in node) {
	    var value = node[key];

	    if (value) {
	      if (Array.isArray(value) || value instanceof List_1) {
	        value = value.map(clone);
	      } else if (value.constructor === Object) {
	        value = clone(value);
	      }
	    }

	    result[key] = value;
	  }

	  return result;
	};

	var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
	var shape = {
	  generic: true,
	  types: {},
	  atrules: {},
	  properties: {},
	  parseContext: {},
	  scope: {},
	  atrule: ['parse'],
	  pseudo: ['parse'],
	  node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject$2(value) {
	  return value && value.constructor === Object;
	}

	function copy(value) {
	  if (isObject$2(value)) {
	    return Object.assign({}, value);
	  } else {
	    return value;
	  }
	}

	function extend$1(dest, src) {
	  for (var key in src) {
	    if (hasOwnProperty$6.call(src, key)) {
	      if (isObject$2(dest[key])) {
	        extend$1(dest[key], copy(src[key]));
	      } else {
	        dest[key] = copy(src[key]);
	      }
	    }
	  }
	}

	function mix(dest, src, shape) {
	  for (var key in shape) {
	    if (hasOwnProperty$6.call(shape, key) === false) {
	      continue;
	    }

	    if (shape[key] === true) {
	      if (key in src) {
	        if (hasOwnProperty$6.call(src, key)) {
	          dest[key] = copy(src[key]);
	        }
	      }
	    } else if (shape[key]) {
	      if (isObject$2(shape[key])) {
	        var res = {};
	        extend$1(res, dest[key]);
	        extend$1(res, src[key]);
	        dest[key] = res;
	      } else if (Array.isArray(shape[key])) {
	        var res = {};
	        var innerShape = shape[key].reduce(function (s, k) {
	          s[k] = true;
	          return s;
	        }, {});

	        for (var name in dest[key]) {
	          if (hasOwnProperty$6.call(dest[key], name)) {
	            res[name] = {};

	            if (dest[key] && dest[key][name]) {
	              mix(res[name], dest[key][name], innerShape);
	            }
	          }
	        }

	        for (var name in src[key]) {
	          if (hasOwnProperty$6.call(src[key], name)) {
	            if (!res[name]) {
	              res[name] = {};
	            }

	            if (src[key] && src[key][name]) {
	              mix(res[name], src[key][name], innerShape);
	            }
	          }
	        }

	        dest[key] = res;
	      }
	    }
	  }

	  return dest;
	}

	var mix_1 = function (dest, src) {
	  return mix(dest, src, shape);
	};

	function createSyntax(config) {
	  var parse = create(config);
	  var walk = create$3(config);
	  var generate = create$1(config);
	  var convert = create$2(walk);
	  var syntax = {
	    List: List_1,
	    SyntaxError: _SyntaxError,
	    TokenStream: TokenStream_1,
	    Lexer: Lexer_1,
	    vendorPrefix: names.vendorPrefix,
	    keyword: names.keyword,
	    property: names.property,
	    isCustomProperty: names.isCustomProperty,
	    definitionSyntax: definitionSyntax,
	    lexer: null,
	    createLexer: function (config) {
	      return new Lexer_1(config, syntax, syntax.lexer.structure);
	    },
	    tokenize: tokenizer,
	    parse: parse,
	    walk: walk,
	    generate: generate,
	    find: walk.find,
	    findLast: walk.findLast,
	    findAll: walk.findAll,
	    clone: clone$1,
	    fromPlainObject: convert.fromPlainObject,
	    toPlainObject: convert.toPlainObject,
	    createSyntax: function (config) {
	      return createSyntax(mix_1({}, config));
	    },
	    fork: function (extension) {
	      var base = mix_1({}, config); // copy of config

	      return createSyntax(typeof extension === 'function' ? extension(base, Object.assign) : mix_1(base, extension));
	    }
	  };
	  syntax.lexer = new Lexer_1({
	    generic: true,
	    types: config.types,
	    atrules: config.atrules,
	    properties: config.properties,
	    node: config.node
	  }, syntax);
	  return syntax;
	}

	var create_1 = function (config) {
	  return createSyntax(mix_1({}, config));
	};

	var create$4 = {
	  create: create_1
	};

	var generic$1 = true;
	var types$1 = {
		"absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large",
		"alpha-value": "<number>|<percentage>",
		"angle-percentage": "<angle>|<percentage>",
		"angular-color-hint": "<angle-percentage>",
		"angular-color-stop": "<color>&&<color-stop-angle>?",
		"angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
		"animateable-feature": "scroll-position|contents|<custom-ident>",
		attachment: "scroll|fixed|local",
		"attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
		"attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
		"attr-modifier": "i|s",
		"attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
		"auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
		"auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
		"baseline-position": "[first|last]? baseline",
		"basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>",
		"bg-image": "none|<image>",
		"bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
		"bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
		"bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
		"blur()": "blur( <length> )",
		"blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
		box: "border-box|padding-box|content-box",
		"brightness()": "brightness( <number-percentage> )",
		"calc()": "calc( <calc-sum> )",
		"calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
		"calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
		"calc-value": "<number>|<dimension>|<percentage>|( <calc-sum> )",
		"cf-final-image": "<image>|<color>",
		"cf-mixing-image": "<percentage>?&&<image>",
		"circle()": "circle( [<shape-radius>]? [at <position>]? )",
		"clamp()": "clamp( <calc-sum>#{3} )",
		"class-selector": "'.' <ident-token>",
		"clip-source": "<url>",
		color: "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>",
		"color-stop": "<color-stop-length>|<color-stop-angle>",
		"color-stop-angle": "<angle-percentage>{1,2}",
		"color-stop-length": "<length-percentage>{1,2}",
		"color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
		combinator: "'>'|'+'|'~'|['||']",
		"common-lig-values": "[common-ligatures|no-common-ligatures]",
		compat: "searchfield|textarea|push-button|button-bevel|slider-horizontal|checkbox|radio|square-button|menulist|menulist-button|listbox|meter|progress-bar",
		"composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
		"compositing-operator": "add|subtract|intersect|exclude",
		"compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!",
		"compound-selector-list": "<compound-selector>#",
		"complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
		"complex-selector-list": "<complex-selector>#",
		"conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
		"contextual-alt-values": "[contextual|no-contextual]",
		"content-distribution": "space-between|space-around|space-evenly|stretch",
		"content-list": "[<string>|contents|<url>|<quote>|<attr()>|counter( <ident> , <'list-style-type'>? )]+",
		"content-position": "center|start|end|flex-start|flex-end",
		"content-replacement": "<image>",
		"contrast()": "contrast( [<number-percentage>] )",
		"counter()": "counter( <custom-ident> , [<counter-style>|none]? )",
		"counter-style": "<counter-style-name>|symbols( )",
		"counter-style-name": "<custom-ident>",
		"counters()": "counters( <custom-ident> , <string> , [<counter-style>|none]? )",
		"cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
		"cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number> , <number> , <number> , <number> )",
		"deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
		"discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
		"display-box": "contents|none",
		"display-inside": "flow|flow-root|table|flex|grid|ruby",
		"display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
		"display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
		"display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
		"display-outside": "block|inline|run-in",
		"drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
		"east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
		"east-asian-width-values": "[full-width|proportional-width]",
		"element()": "element( <id-selector> )",
		"ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
		"ending-shape": "circle|ellipse",
		"env()": "env( <custom-ident> , <declaration-value>? )",
		"explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
		"family-name": "<string>|<custom-ident>+",
		"feature-tag-value": "<string> [<integer>|on|off]?",
		"feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
		"feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
		"feature-value-block-list": "<feature-value-block>+",
		"feature-value-declaration": "<custom-ident> : <integer>+ ;",
		"feature-value-declaration-list": "<feature-value-declaration>",
		"feature-value-name": "<custom-ident>",
		"fill-rule": "nonzero|evenodd",
		"filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
		"filter-function-list": "[<filter-function>|<url>]+",
		"final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
		"fit-content()": "fit-content( [<length>|<percentage>] )",
		"fixed-breadth": "<length-percentage>",
		"fixed-repeat": "repeat( [<positive-integer>] , [<line-names>? <fixed-size>]+ <line-names>? )",
		"fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
		"font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
		"font-variant-css21": "[normal|small-caps]",
		"font-weight-absolute": "normal|bold|<number>",
		"frequency-percentage": "<frequency>|<percentage>",
		"general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )",
		"generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system",
		"generic-name": "serif|sans-serif|cursive|fantasy|monospace",
		"geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
		gradient: "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<-legacy-gradient>",
		"grayscale()": "grayscale( <number-percentage> )",
		"grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
		"historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
		"hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
		"hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
		hue: "<number>|<angle>",
		"hue-rotate()": "hue-rotate( <angle> )",
		image: "<url>|<image()>|<image-set()>|<element()>|<cross-fade()>|<gradient>",
		"image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
		"image-set()": "image-set( <image-set-option># )",
		"image-set-option": "[<image>|<string>] <resolution>",
		"image-src": "<url>|<string>",
		"image-tags": "ltr|rtl",
		"inflexible-breadth": "<length>|<percentage>|min-content|max-content|auto",
		"inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
		"invert()": "invert( <number-percentage> )",
		"keyframes-name": "<custom-ident>|<string>",
		"keyframe-block": "<keyframe-selector># { <declaration-list> }",
		"keyframe-block-list": "<keyframe-block>+",
		"keyframe-selector": "from|to|<percentage>",
		"leader()": "leader( <leader-type> )",
		"leader-type": "dotted|solid|space|<string>",
		"length-percentage": "<length>|<percentage>",
		"line-names": "'[' <custom-ident>* ']'",
		"line-name-list": "[<line-names>|<name-repeat>]+",
		"line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
		"line-width": "<length>|thin|medium|thick",
		"linear-color-hint": "<length-percentage>",
		"linear-color-stop": "<color> <color-stop-length>?",
		"linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
		"mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
		"mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
		"mask-reference": "none|<image>|<mask-source>",
		"mask-source": "<url>",
		"masking-mode": "alpha|luminance|match-source",
		"matrix()": "matrix( <number>#{6} )",
		"matrix3d()": "matrix3d( <number>#{16} )",
		"max()": "max( <calc-sum># )",
		"media-and": "<media-in-parens> [and <media-in-parens>]+",
		"media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
		"media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
		"media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
		"media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
		"media-not": "not <media-in-parens>",
		"media-or": "<media-in-parens> [or <media-in-parens>]+",
		"media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
		"media-query-list": "<media-query>#",
		"media-type": "<ident>",
		"mf-boolean": "<mf-name>",
		"mf-name": "<ident>",
		"mf-plain": "<mf-name> : <mf-value>",
		"mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
		"mf-value": "<number>|<dimension>|<ident>|<ratio>",
		"min()": "min( <calc-sum># )",
		"minmax()": "minmax( [<length>|<percentage>|<flex>|min-content|max-content|auto] , [<length>|<percentage>|<flex>|min-content|max-content|auto] )",
		"named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>",
		"namespace-prefix": "<ident>",
		"ns-prefix": "[<ident-token>|'*']? '|'",
		"number-percentage": "<number>|<percentage>",
		"numeric-figure-values": "[lining-nums|oldstyle-nums]",
		"numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
		"numeric-spacing-values": "[proportional-nums|tabular-nums]",
		nth: "<an-plus-b>|even|odd",
		"opacity()": "opacity( [<number-percentage>] )",
		"overflow-position": "unsafe|safe",
		"outline-radius": "<length>|<percentage>",
		"page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
		"page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
		"page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
		"page-selector-list": "[<page-selector>#]?",
		"page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
		"perspective()": "perspective( <length> )",
		"polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
		position: "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
		"pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
		"pseudo-element-selector": "':' <pseudo-class-selector>",
		"pseudo-page": ": [left|right|first|blank]",
		quote: "open-quote|close-quote|no-open-quote|no-close-quote",
		"radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
		"relative-selector": "<combinator>? <complex-selector>",
		"relative-selector-list": "<relative-selector>#",
		"relative-size": "larger|smaller",
		"repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
		"repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
		"repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
		"rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
		"rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
		"rotate()": "rotate( [<angle>|<zero>] )",
		"rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
		"rotateX()": "rotateX( [<angle>|<zero>] )",
		"rotateY()": "rotateY( [<angle>|<zero>] )",
		"rotateZ()": "rotateZ( [<angle>|<zero>] )",
		"saturate()": "saturate( <number-percentage> )",
		"scale()": "scale( <number> , <number>? )",
		"scale3d()": "scale3d( <number> , <number> , <number> )",
		"scaleX()": "scaleX( <number> )",
		"scaleY()": "scaleY( <number> )",
		"scaleZ()": "scaleZ( <number> )",
		"self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
		"shape-radius": "<length-percentage>|closest-side|farthest-side",
		"skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
		"skewX()": "skewX( [<angle>|<zero>] )",
		"skewY()": "skewY( [<angle>|<zero>] )",
		"sepia()": "sepia( <number-percentage> )",
		shadow: "inset?&&<length>{2,4}&&<color>?",
		"shadow-t": "[<length>{2,3}&&<color>?]",
		shape: "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
		"shape-box": "<box>|margin-box",
		"side-or-corner": "[left|right]||[top|bottom]",
		"single-animation": "<time>||<timing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]",
		"single-animation-direction": "normal|reverse|alternate|alternate-reverse",
		"single-animation-fill-mode": "none|forwards|backwards|both",
		"single-animation-iteration-count": "infinite|<number>",
		"single-animation-play-state": "running|paused",
		"single-transition": "[none|<single-transition-property>]||<time>||<timing-function>||<time>",
		"single-transition-property": "all|<custom-ident>",
		size: "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
		"step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
		"step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
		"subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
		"supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
		"supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
		"supports-feature": "<supports-decl>|<supports-selector-fn>",
		"supports-decl": "( <declaration> )",
		"supports-selector-fn": "selector( <complex-selector> )",
		symbol: "<string>|<image>|<custom-ident>",
		target: "<target-counter()>|<target-counters()>|<target-text()>",
		"target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
		"target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
		"target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
		"time-percentage": "<time>|<percentage>",
		"timing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
		"track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
		"track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
		"track-repeat": "repeat( [<positive-integer>] , [<line-names>? <track-size>]+ <line-names>? )",
		"track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( [<length>|<percentage>] )",
		"transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
		"transform-list": "<transform-function>+",
		"translate()": "translate( <length-percentage> , <length-percentage>? )",
		"translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
		"translateX()": "translateX( <length-percentage> )",
		"translateY()": "translateY( <length-percentage> )",
		"translateZ()": "translateZ( <length> )",
		"type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
		"type-selector": "<wq-name>|<ns-prefix>? '*'",
		"var()": "var( <custom-property-name> , <declaration-value>? )",
		"viewport-length": "auto|<length-percentage>",
		"wq-name": "<ns-prefix>? <ident-token>",
		"-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
		"-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
		"-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
		"-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
		"-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
		"-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
		"-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
		"-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
		"-legacy-radial-gradient-shape": "circle|ellipse",
		"-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
		"-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
		"-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
		"-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
		"-non-standard-width": "min-intrinsic|intrinsic|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content",
		"-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
		"-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
		"-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
		"-webkit-gradient-radius": "<length>|<percentage>",
		"-webkit-gradient-type": "linear|radial",
		"-webkit-mask-box-repeat": "repeat|stretch|round",
		"-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text",
		"-ms-filter-function-list": "<-ms-filter-function>+",
		"-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
		"-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
		"-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
		"-ms-filter": "<string>",
		age: "child|young|old",
		"attr-name": "<wq-name>",
		"attr-fallback": "<any-value>",
		"border-radius": "<length-percentage>{1,2}",
		bottom: "<length>|auto",
		"generic-voice": "[<age>? <gender> <integer>?]",
		gender: "male|female|neutral",
		left: "<length>|auto",
		"mask-image": "<mask-reference>#",
		"name-repeat": "repeat( [<positive-integer>|auto-fill] , <line-names>+ )",
		paint: "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
		"path()": "path( <string> )",
		ratio: "<integer> / <integer>",
		right: "<length>|auto",
		"svg-length": "<percentage>|<length>|<number>",
		"svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
		top: "<length>|auto",
		"track-group": "'(' [<string>* <track-minmax> <string>*]+ ')' ['[' <positive-integer> ']']?|<track-minmax>",
		"track-list-v0": "[<string>* <track-group> <string>*]+|none",
		"track-minmax": "minmax( <track-breadth> , <track-breadth> )|auto|<track-breadth>|fit-content",
		x: "<number>",
		y: "<number>",
		declaration: "<ident-token> : <declaration-value>? ['!' important]?",
		"declaration-list": "[<declaration>? ';']* <declaration>?",
		url: "url( <string> <url-modifier>* )|<url-token>",
		"url-modifier": "<ident>|<function-token> <any-value> )",
		"number-zero-one": "<number [0,1]>",
		"number-one-or-greater": "<number [1,∞]>",
		"positive-integer": "<integer [0,∞]>"
	};
	var properties$1 = {
		"--*": "<declaration-value>",
		"-ms-accelerator": "false|true",
		"-ms-block-progression": "tb|rl|bt|lr",
		"-ms-content-zoom-chaining": "none|chained",
		"-ms-content-zooming": "none|zoom",
		"-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		"-ms-content-zoom-limit-max": "<percentage>",
		"-ms-content-zoom-limit-min": "<percentage>",
		"-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
		"-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
		"-ms-content-zoom-snap-type": "none|proximity|mandatory",
		"-ms-filter": "<string>",
		"-ms-flow-from": "[none|<custom-ident>]#",
		"-ms-flow-into": "[none|<custom-ident>]#",
		"-ms-high-contrast-adjust": "auto|none",
		"-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
		"-ms-hyphenate-limit-lines": "no-limit|<integer>",
		"-ms-hyphenate-limit-zone": "<percentage>|<length>",
		"-ms-ime-align": "auto|after",
		"-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
		"-ms-scrollbar-3dlight-color": "<color>",
		"-ms-scrollbar-arrow-color": "<color>",
		"-ms-scrollbar-base-color": "<color>",
		"-ms-scrollbar-darkshadow-color": "<color>",
		"-ms-scrollbar-face-color": "<color>",
		"-ms-scrollbar-highlight-color": "<color>",
		"-ms-scrollbar-shadow-color": "<color>",
		"-ms-scrollbar-track-color": "<color>",
		"-ms-scroll-chaining": "chained|none",
		"-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		"-ms-scroll-limit-x-max": "auto|<length>",
		"-ms-scroll-limit-x-min": "<length>",
		"-ms-scroll-limit-y-max": "auto|<length>",
		"-ms-scroll-limit-y-min": "<length>",
		"-ms-scroll-rails": "none|railed",
		"-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
		"-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
		"-ms-scroll-snap-type": "none|proximity|mandatory",
		"-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		"-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		"-ms-scroll-translation": "none|vertical-to-horizontal",
		"-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
		"-ms-touch-select": "grippers|none",
		"-ms-user-select": "none|element|text",
		"-ms-wrap-flow": "auto|both|start|end|maximum|clear",
		"-ms-wrap-margin": "<length>",
		"-ms-wrap-through": "wrap|none",
		"-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
		"-moz-binding": "<url>|none",
		"-moz-border-bottom-colors": "<color>+|none",
		"-moz-border-left-colors": "<color>+|none",
		"-moz-border-right-colors": "<color>+|none",
		"-moz-border-top-colors": "<color>+|none",
		"-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
		"-moz-float-edge": "border-box|content-box|margin-box|padding-box",
		"-moz-force-broken-image-icon": "<integer>",
		"-moz-image-region": "<shape>|auto",
		"-moz-orient": "inline|block|horizontal|vertical",
		"-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
		"-moz-outline-radius-bottomleft": "<outline-radius>",
		"-moz-outline-radius-bottomright": "<outline-radius>",
		"-moz-outline-radius-topleft": "<outline-radius>",
		"-moz-outline-radius-topright": "<outline-radius>",
		"-moz-stack-sizing": "ignore|stretch-to-fit",
		"-moz-text-blink": "none|blink",
		"-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
		"-moz-user-input": "auto|none|enabled|disabled",
		"-moz-user-modify": "read-only|read-write|write-only",
		"-moz-window-dragging": "drag|no-drag",
		"-moz-window-shadow": "default|menu|tooltip|sheet|none",
		"-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|listbox|listitem|media-fullscreen-button|media-mute-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield",
		"-webkit-border-before": "<'border-width'>||<'border-style'>||<'color'>",
		"-webkit-border-before-color": "<'color'>",
		"-webkit-border-before-style": "<'border-style'>",
		"-webkit-border-before-width": "<'border-width'>",
		"-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
		"-webkit-line-clamp": "none|<integer>",
		"-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
		"-webkit-mask-attachment": "<attachment>#",
		"-webkit-mask-clip": "[<box>|border|padding|content|text]#",
		"-webkit-mask-composite": "<composite-style>#",
		"-webkit-mask-image": "<mask-reference>#",
		"-webkit-mask-origin": "[<box>|border|padding|content]#",
		"-webkit-mask-position": "<position>#",
		"-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
		"-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
		"-webkit-mask-repeat": "<repeat-style>#",
		"-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
		"-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
		"-webkit-mask-size": "<bg-size>#",
		"-webkit-overflow-scrolling": "auto|touch",
		"-webkit-tap-highlight-color": "<color>",
		"-webkit-text-fill-color": "<color>",
		"-webkit-text-stroke": "<length>||<color>",
		"-webkit-text-stroke-color": "<color>",
		"-webkit-text-stroke-width": "<length>",
		"-webkit-touch-callout": "default|none",
		"-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
		"align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
		"align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
		"align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
		all: "initial|inherit|unset|revert",
		animation: "<single-animation>#",
		"animation-delay": "<time>#",
		"animation-direction": "<single-animation-direction>#",
		"animation-duration": "<time>#",
		"animation-fill-mode": "<single-animation-fill-mode>#",
		"animation-iteration-count": "<single-animation-iteration-count>#",
		"animation-name": "[none|<keyframes-name>]#",
		"animation-play-state": "<single-animation-play-state>#",
		"animation-timing-function": "<timing-function>#",
		appearance: "none|auto|button|textfield|<compat>",
		azimuth: "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
		"backdrop-filter": "none|<filter-function-list>",
		"backface-visibility": "visible|hidden",
		background: "[<bg-layer> ,]* <final-bg-layer>",
		"background-attachment": "<attachment>#",
		"background-blend-mode": "<blend-mode>#",
		"background-clip": "<box>#",
		"background-color": "<color>",
		"background-image": "<bg-image>#",
		"background-origin": "<box>#",
		"background-position": "<bg-position>#",
		"background-position-x": "[center|[left|right|x-start|x-end]? <length-percentage>?]#",
		"background-position-y": "[center|[top|bottom|y-start|y-end]? <length-percentage>?]#",
		"background-repeat": "<repeat-style>#",
		"background-size": "<bg-size>#",
		"block-overflow": "clip|ellipsis|<string>",
		"block-size": "<'width'>",
		border: "<line-width>||<line-style>||<color>",
		"border-block": "<'border-top-width'>||<'border-top-style'>||<'color'>",
		"border-block-color": "<'border-top-color'>{1,2}",
		"border-block-style": "<'border-top-style'>",
		"border-block-width": "<'border-top-width'>",
		"border-block-end": "<'border-top-width'>||<'border-top-style'>||<'color'>",
		"border-block-end-color": "<'border-top-color'>",
		"border-block-end-style": "<'border-top-style'>",
		"border-block-end-width": "<'border-top-width'>",
		"border-block-start": "<'border-top-width'>||<'border-top-style'>||<'color'>",
		"border-block-start-color": "<'border-top-color'>",
		"border-block-start-style": "<'border-top-style'>",
		"border-block-start-width": "<'border-top-width'>",
		"border-bottom": "<line-width>||<line-style>||<color>",
		"border-bottom-color": "<'border-top-color'>",
		"border-bottom-left-radius": "<length-percentage>{1,2}",
		"border-bottom-right-radius": "<length-percentage>{1,2}",
		"border-bottom-style": "<line-style>",
		"border-bottom-width": "<line-width>",
		"border-collapse": "collapse|separate",
		"border-color": "<color>{1,4}",
		"border-end-end-radius": "<length-percentage>{1,2}",
		"border-end-start-radius": "<length-percentage>{1,2}",
		"border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
		"border-image-outset": "[<length>|<number>]{1,4}",
		"border-image-repeat": "[stretch|repeat|round|space]{1,2}",
		"border-image-slice": "<number-percentage>{1,4}&&fill?",
		"border-image-source": "none|<image>",
		"border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
		"border-inline": "<'border-top-width'>||<'border-top-style'>||<'color'>",
		"border-inline-end": "<'border-top-width'>||<'border-top-style'>||<'color'>",
		"border-inline-color": "<'border-top-color'>{1,2}",
		"border-inline-style": "<'border-top-style'>",
		"border-inline-width": "<'border-top-width'>",
		"border-inline-end-color": "<'border-top-color'>",
		"border-inline-end-style": "<'border-top-style'>",
		"border-inline-end-width": "<'border-top-width'>",
		"border-inline-start": "<'border-top-width'>||<'border-top-style'>||<'color'>",
		"border-inline-start-color": "<'border-top-color'>",
		"border-inline-start-style": "<'border-top-style'>",
		"border-inline-start-width": "<'border-top-width'>",
		"border-left": "<line-width>||<line-style>||<color>",
		"border-left-color": "<color>",
		"border-left-style": "<line-style>",
		"border-left-width": "<line-width>",
		"border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
		"border-right": "<line-width>||<line-style>||<color>",
		"border-right-color": "<color>",
		"border-right-style": "<line-style>",
		"border-right-width": "<line-width>",
		"border-spacing": "<length> <length>?",
		"border-start-end-radius": "<length-percentage>{1,2}",
		"border-start-start-radius": "<length-percentage>{1,2}",
		"border-style": "<line-style>{1,4}",
		"border-top": "<line-width>||<line-style>||<color>",
		"border-top-color": "<color>",
		"border-top-left-radius": "<length-percentage>{1,2}",
		"border-top-right-radius": "<length-percentage>{1,2}",
		"border-top-style": "<line-style>",
		"border-top-width": "<line-width>",
		"border-width": "<line-width>{1,4}",
		bottom: "<length>|<percentage>|auto",
		"box-align": "start|center|end|baseline|stretch",
		"box-decoration-break": "slice|clone",
		"box-direction": "normal|reverse|inherit",
		"box-flex": "<number>",
		"box-flex-group": "<integer>",
		"box-lines": "single|multiple",
		"box-ordinal-group": "<integer>",
		"box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
		"box-pack": "start|center|end|justify",
		"box-shadow": "none|<shadow>#",
		"box-sizing": "content-box|border-box",
		"break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
		"break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
		"break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
		"caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
		"caret-color": "auto|<color>",
		clear: "none|left|right|both|inline-start|inline-end",
		clip: "<shape>|auto",
		"clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
		color: "<color>",
		"color-adjust": "economy|exact",
		"column-count": "<integer>|auto",
		"column-fill": "auto|balance|balance-all",
		"column-gap": "normal|<length-percentage>",
		"column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
		"column-rule-color": "<color>",
		"column-rule-style": "<'border-style'>",
		"column-rule-width": "<'border-width'>",
		"column-span": "none|all",
		"column-width": "<length>|auto",
		columns: "<'column-width'>||<'column-count'>",
		contain: "none|strict|content|[size||layout||style||paint]",
		content: "normal|none|[<content-replacement>|<content-list>] [/ <string>]?",
		"counter-increment": "[<custom-ident> <integer>?]+|none",
		"counter-reset": "[<custom-ident> <integer>?]+|none",
		"counter-set": "[<custom-ident> <integer>?]+|none",
		cursor: "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
		direction: "ltr|rtl",
		display: "block|contents|flex|flow|flow-root|grid|inline|inline-block|inline-flex|inline-grid|inline-list-item|inline-table|list-item|none|ruby|ruby-base|ruby-base-container|ruby-text|ruby-text-container|run-in|table|table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|-ms-flexbox|-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box",
		"empty-cells": "show|hide",
		filter: "none|<filter-function-list>|<-ms-filter-function-list>",
		flex: "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
		"flex-basis": "content|<'width'>",
		"flex-direction": "row|row-reverse|column|column-reverse",
		"flex-flow": "<'flex-direction'>||<'flex-wrap'>",
		"flex-grow": "<number>",
		"flex-shrink": "<number>",
		"flex-wrap": "nowrap|wrap|wrap-reverse",
		float: "left|right|none|inline-start|inline-end",
		font: "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar",
		"font-family": "[<family-name>|<generic-family>]#",
		"font-feature-settings": "normal|<feature-tag-value>#",
		"font-kerning": "auto|normal|none",
		"font-language-override": "normal|<string>",
		"font-optical-sizing": "auto|none",
		"font-variation-settings": "normal|[<string> <number>]#",
		"font-size": "<absolute-size>|<relative-size>|<length-percentage>",
		"font-size-adjust": "none|<number>",
		"font-stretch": "<font-stretch-absolute>",
		"font-style": "normal|italic|oblique <angle>?",
		"font-synthesis": "none|[weight||style]",
		"font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
		"font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
		"font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
		"font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
		"font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
		"font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
		"font-variant-position": "normal|sub|super",
		"font-weight": "<font-weight-absolute>|bolder|lighter",
		gap: "<'row-gap'> <'column-gap'>?",
		grid: "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
		"grid-area": "<grid-line> [/ <grid-line>]{0,3}",
		"grid-auto-columns": "<track-size>+",
		"grid-auto-flow": "[row|column]||dense",
		"grid-auto-rows": "<track-size>+",
		"grid-column": "<grid-line> [/ <grid-line>]?",
		"grid-column-end": "<grid-line>",
		"grid-column-gap": "<length-percentage>",
		"grid-column-start": "<grid-line>",
		"grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
		"grid-row": "<grid-line> [/ <grid-line>]?",
		"grid-row-end": "<grid-line>",
		"grid-row-gap": "<length-percentage>",
		"grid-row-start": "<grid-line>",
		"grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
		"grid-template-areas": "none|<string>+",
		"grid-template-columns": "none|<track-list>|<auto-track-list>",
		"grid-template-rows": "none|<track-list>|<auto-track-list>",
		"hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
		height: "[<length>|<percentage>]&&[border-box|content-box]?|available|min-content|max-content|fit-content|auto",
		hyphens: "none|manual|auto",
		"image-orientation": "from-image|<angle>|[<angle>? flip]",
		"image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
		"image-resolution": "[from-image||<resolution>]&&snap?",
		"ime-mode": "auto|normal|active|inactive|disabled",
		"initial-letter": "normal|[<number> <integer>?]",
		"initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
		"inline-size": "<'width'>",
		inset: "<'top'>{1,4}",
		"inset-block": "<'top'>{1,2}",
		"inset-block-end": "<'top'>",
		"inset-block-start": "<'top'>",
		"inset-inline": "<'top'>{1,2}",
		"inset-inline-end": "<'top'>",
		"inset-inline-start": "<'top'>",
		isolation: "auto|isolate",
		"justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
		"justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
		"justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
		left: "<length>|<percentage>|auto",
		"letter-spacing": "normal|<length-percentage>",
		"line-break": "auto|loose|normal|strict",
		"line-clamp": "none|<integer>",
		"line-height": "normal|<number>|<length>|<percentage>",
		"line-height-step": "<length>",
		"list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
		"list-style-image": "<url>|none",
		"list-style-position": "inside|outside",
		"list-style-type": "<counter-style>|<string>|none",
		margin: "[<length>|<percentage>|auto]{1,4}",
		"margin-block": "<'margin-left'>{1,2}",
		"margin-block-end": "<'margin-left'>",
		"margin-block-start": "<'margin-left'>",
		"margin-bottom": "<length>|<percentage>|auto",
		"margin-inline": "<'margin-left'>{1,2}",
		"margin-inline-end": "<'margin-left'>",
		"margin-inline-start": "<'margin-left'>",
		"margin-left": "<length>|<percentage>|auto",
		"margin-right": "<length>|<percentage>|auto",
		"margin-top": "<length>|<percentage>|auto",
		mask: "<mask-layer>#",
		"mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
		"mask-border-mode": "luminance|alpha",
		"mask-border-outset": "[<length>|<number>]{1,4}",
		"mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
		"mask-border-slice": "<number-percentage>{1,4} fill?",
		"mask-border-source": "none|<image>",
		"mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
		"mask-clip": "[<geometry-box>|no-clip]#",
		"mask-composite": "<compositing-operator>#",
		"mask-image": "<mask-reference>#",
		"mask-mode": "<masking-mode>#",
		"mask-origin": "<geometry-box>#",
		"mask-position": "<position>#",
		"mask-repeat": "<repeat-style>#",
		"mask-size": "<bg-size>#",
		"mask-type": "luminance|alpha",
		"max-block-size": "<'max-width'>",
		"max-height": "<length>|<percentage>|none|max-content|min-content|fit-content|fill-available",
		"max-inline-size": "<'max-width'>",
		"max-lines": "none|<integer>",
		"max-width": "<length>|<percentage>|none|max-content|min-content|fit-content|fill-available|<-non-standard-width>",
		"min-block-size": "<'min-width'>",
		"min-height": "<length>|<percentage>|auto|max-content|min-content|fit-content|fill-available",
		"min-inline-size": "<'min-width'>",
		"min-width": "<length>|<percentage>|auto|max-content|min-content|fit-content|fill-available|<-non-standard-width>",
		"mix-blend-mode": "<blend-mode>",
		"object-fit": "fill|contain|cover|none|scale-down",
		"object-position": "<position>",
		offset: "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
		"offset-anchor": "auto|<position>",
		"offset-distance": "<length-percentage>",
		"offset-path": "none|ray( [<angle>&&<size>?&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]",
		"offset-position": "auto|<position>",
		"offset-rotate": "[auto|reverse]||<angle>",
		opacity: "<number-zero-one>",
		order: "<integer>",
		orphans: "<integer>",
		outline: "[<'outline-color'>||<'outline-style'>||<'outline-width'>]",
		"outline-color": "<color>|invert",
		"outline-offset": "<length>",
		"outline-style": "auto|<'border-style'>",
		"outline-width": "<line-width>",
		overflow: "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
		"overflow-anchor": "auto|none",
		"overflow-block": "visible|hidden|clip|scroll|auto",
		"overflow-clip-box": "padding-box|content-box",
		"overflow-inline": "visible|hidden|clip|scroll|auto",
		"overflow-wrap": "normal|break-word|anywhere",
		"overflow-x": "visible|hidden|clip|scroll|auto",
		"overflow-y": "visible|hidden|clip|scroll|auto",
		"overscroll-behavior": "[contain|none|auto]{1,2}",
		"overscroll-behavior-x": "contain|none|auto",
		"overscroll-behavior-y": "contain|none|auto",
		padding: "[<length>|<percentage>]{1,4}",
		"padding-block": "<'padding-left'>{1,2}",
		"padding-block-end": "<'padding-left'>",
		"padding-block-start": "<'padding-left'>",
		"padding-bottom": "<length>|<percentage>",
		"padding-inline": "<'padding-left'>{1,2}",
		"padding-inline-end": "<'padding-left'>",
		"padding-inline-start": "<'padding-left'>",
		"padding-left": "<length>|<percentage>",
		"padding-right": "<length>|<percentage>",
		"padding-top": "<length>|<percentage>",
		"page-break-after": "auto|always|avoid|left|right|recto|verso",
		"page-break-before": "auto|always|avoid|left|right|recto|verso",
		"page-break-inside": "auto|avoid",
		"paint-order": "normal|[fill||stroke||markers]",
		perspective: "none|<length>",
		"perspective-origin": "<position>",
		"place-content": "<'align-content'> <'justify-content'>?",
		"place-items": "<'align-items'> <'justify-items'>?",
		"place-self": "<'align-self'> <'justify-self'>?",
		"pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
		position: "static|relative|absolute|sticky|fixed|-webkit-sticky",
		quotes: "none|[<string> <string>]+",
		resize: "none|both|horizontal|vertical|block|inline",
		right: "<length>|<percentage>|auto",
		rotate: "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
		"row-gap": "normal|<length-percentage>",
		"ruby-align": "start|center|space-between|space-around",
		"ruby-merge": "separate|collapse|auto",
		"ruby-position": "over|under|inter-character",
		scale: "none|<number>{1,3}",
		"scrollbar-color": "auto|dark|light|<color>{2}",
		"scrollbar-width": "auto|thin|none",
		"scroll-behavior": "auto|smooth",
		"scroll-margin": "<length>{1,4}",
		"scroll-margin-block": "<length>{1,2}",
		"scroll-margin-block-start": "<length>",
		"scroll-margin-block-end": "<length>",
		"scroll-margin-bottom": "<length>",
		"scroll-margin-inline": "<length>{1,2}",
		"scroll-margin-inline-start": "<length>",
		"scroll-margin-inline-end": "<length>",
		"scroll-margin-left": "<length>",
		"scroll-margin-right": "<length>",
		"scroll-margin-top": "<length>",
		"scroll-padding": "[auto|<length-percentage>]{1,4}",
		"scroll-padding-block": "[auto|<length-percentage>]{1,2}",
		"scroll-padding-block-start": "auto|<length-percentage>",
		"scroll-padding-block-end": "auto|<length-percentage>",
		"scroll-padding-bottom": "auto|<length-percentage>",
		"scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
		"scroll-padding-inline-start": "auto|<length-percentage>",
		"scroll-padding-inline-end": "auto|<length-percentage>",
		"scroll-padding-left": "auto|<length-percentage>",
		"scroll-padding-right": "auto|<length-percentage>",
		"scroll-padding-top": "auto|<length-percentage>",
		"scroll-snap-align": "[none|start|end|center]{1,2}",
		"scroll-snap-coordinate": "none|<position>#",
		"scroll-snap-destination": "<position>",
		"scroll-snap-points-x": "none|repeat( <length-percentage> )",
		"scroll-snap-points-y": "none|repeat( <length-percentage> )",
		"scroll-snap-stop": "normal|always",
		"scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
		"scroll-snap-type-x": "none|mandatory|proximity",
		"scroll-snap-type-y": "none|mandatory|proximity",
		"shape-image-threshold": "<number>",
		"shape-margin": "<length-percentage>",
		"shape-outside": "none|<shape-box>||<basic-shape>|<image>",
		"tab-size": "<integer>|<length>",
		"table-layout": "auto|fixed",
		"text-align": "start|end|left|right|center|justify|match-parent",
		"text-align-last": "auto|start|end|left|right|center|justify",
		"text-combine-upright": "none|all|[digits <integer>?]",
		"text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>",
		"text-decoration-color": "<color>",
		"text-decoration-line": "none|[underline||overline||line-through||blink]",
		"text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
		"text-decoration-skip-ink": "auto|none",
		"text-decoration-style": "solid|double|dotted|dashed|wavy",
		"text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
		"text-emphasis-color": "<color>",
		"text-emphasis-position": "[over|under]&&[right|left]",
		"text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
		"text-indent": "<length-percentage>&&hanging?&&each-line?",
		"text-justify": "auto|inter-character|inter-word|none",
		"text-orientation": "mixed|upright|sideways",
		"text-overflow": "[clip|ellipsis|<string>]{1,2}",
		"text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
		"text-shadow": "none|<shadow-t>#",
		"text-size-adjust": "none|auto|<percentage>",
		"text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
		"text-underline-position": "auto|[under||[left|right]]",
		top: "<length>|<percentage>|auto",
		"touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
		transform: "none|<transform-list>",
		"transform-box": "border-box|fill-box|view-box",
		"transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
		"transform-style": "flat|preserve-3d",
		transition: "<single-transition>#",
		"transition-delay": "<time>#",
		"transition-duration": "<time>#",
		"transition-property": "none|<single-transition-property>#",
		"transition-timing-function": "<timing-function>#",
		translate: "none|<length-percentage> [<length-percentage> <length>?]?",
		"unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate",
		"user-select": "auto|text|none|contain|all",
		"vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
		visibility: "visible|hidden|collapse",
		"white-space": "normal|pre|nowrap|pre-wrap|pre-line",
		widows: "<integer>",
		width: "[<length>|<percentage>]&&[border-box|content-box]?|available|min-content|max-content|fit-content|auto",
		"will-change": "auto|<animateable-feature>#",
		"word-break": "normal|break-all|keep-all|break-word",
		"word-spacing": "normal|<length-percentage>",
		"word-wrap": "normal|break-word",
		"writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
		"z-index": "auto|<integer>",
		zoom: "normal|reset|<number>|<percentage>",
		"-moz-background-clip": "padding|border",
		"-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
		"-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
		"-moz-border-radius-topleft": "<'border-top-left-radius'>",
		"-moz-border-radius-topright": "<'border-bottom-right-radius'>",
		"-moz-control-character-visibility": "visible|hidden",
		"-moz-osx-font-smoothing": "auto|grayscale",
		"-moz-user-select": "none|text|all|-moz-none",
		"-ms-flex-align": "start|end|center|baseline|stretch",
		"-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
		"-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
		"-ms-flex-negative": "<'flex-shrink'>",
		"-ms-flex-pack": "start|end|center|justify|distribute",
		"-ms-flex-order": "<integer>",
		"-ms-flex-positive": "<'flex-grow'>",
		"-ms-flex-preferred-size": "<'flex-basis'>",
		"-ms-interpolation-mode": "nearest-neighbor|bicubic",
		"-ms-grid-column-align": "start|end|center|stretch",
		"-ms-grid-columns": "<track-list-v0>",
		"-ms-grid-row-align": "start|end|center|stretch",
		"-ms-grid-rows": "<track-list-v0>",
		"-ms-hyphenate-limit-last": "none|always|column|page|spread",
		"-webkit-background-clip": "[<box>|border|padding|content|text]#",
		"-webkit-column-break-after": "always|auto|avoid",
		"-webkit-column-break-before": "always|auto|avoid",
		"-webkit-column-break-inside": "always|auto|avoid",
		"-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
		"-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
		"-webkit-print-color-adjust": "economy|exact",
		"-webkit-text-security": "none|circle|disc|square",
		"-webkit-user-drag": "none|element|auto",
		"-webkit-user-select": "auto|none|text|all",
		"alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
		"baseline-shift": "baseline|sub|super|<svg-length>",
		behavior: "<url>+",
		"clip-rule": "nonzero|evenodd",
		cue: "<'cue-before'> <'cue-after'>?",
		"cue-after": "<url> <decibel>?|none",
		"cue-before": "<url> <decibel>?|none",
		"dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
		fill: "<paint>",
		"fill-opacity": "<number-zero-one>",
		"fill-rule": "nonzero|evenodd",
		"glyph-orientation-horizontal": "<angle>",
		"glyph-orientation-vertical": "<angle>",
		kerning: "auto|<svg-length>",
		marker: "none|<url>",
		"marker-end": "none|<url>",
		"marker-mid": "none|<url>",
		"marker-start": "none|<url>",
		pause: "<'pause-before'> <'pause-after'>?",
		"pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
		"pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
		rest: "<'rest-before'> <'rest-after'>?",
		"rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
		"rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
		"shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
		src: "[<url> [format( <string># )]?|local( <family-name> )]#",
		speak: "auto|none|normal",
		"speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
		stroke: "<paint>",
		"stroke-dasharray": "none|[<svg-length>+]#",
		"stroke-dashoffset": "<svg-length>",
		"stroke-linecap": "butt|round|square",
		"stroke-linejoin": "miter|round|bevel",
		"stroke-miterlimit": "<number-one-or-greater>",
		"stroke-opacity": "<number-zero-one>",
		"stroke-width": "<svg-length>",
		"text-anchor": "start|middle|end",
		"unicode-range": "<urange>#",
		"voice-balance": "<number>|left|center|right|leftwards|rightwards",
		"voice-duration": "auto|<time>",
		"voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
		"voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
		"voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
		"voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
		"voice-stress": "normal|strong|moderate|none|reduced",
		"voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]"
	};
	var defaultSyntax = {
		generic: generic$1,
		types: types$1,
		properties: properties$1
	};

	var defaultSyntax$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		generic: generic$1,
		types: types$1,
		properties: properties$1,
		'default': defaultSyntax
	});

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;
	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B; // U+002B PLUS SIGN (+)

	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)

	var N$4 = 0x006E; // U+006E LATIN SMALL LETTER N (n)

	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	  var pos = this.scanner.tokenStart + offset;
	  var code = this.scanner.source.charCodeAt(pos);

	  if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	    if (disallowSign) {
	      this.error('Number sign is not allowed');
	    }

	    pos++;
	  }

	  for (; pos < this.scanner.tokenEnd; pos++) {
	    if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	      this.error('Integer is expected', pos);
	    }
	  }
	}

	function checkTokenIsInteger(disallowSign) {
	  return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	  if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	    var msg = '';

	    switch (code) {
	      case N$4:
	        msg = 'N is expected';
	        break;

	      case HYPHENMINUS$3:
	        msg = 'HyphenMinus is expected';
	        break;
	    }

	    this.error(msg, this.scanner.tokenStart + offset);
	  }
	} // ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>


	function consumeB$1() {
	  var offset = 0;
	  var sign = 0;
	  var type = this.scanner.tokenType;

	  while (type === WHITESPACE$4 || type === COMMENT$3) {
	    type = this.scanner.lookupType(++offset);
	  }

	  if (type !== NUMBER$3) {
	    if (this.scanner.isDelim(PLUSSIGN$3, offset) || this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	      sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	      do {
	        type = this.scanner.lookupType(++offset);
	      } while (type === WHITESPACE$4 || type === COMMENT$3);

	      if (type !== NUMBER$3) {
	        this.scanner.skip(offset);
	        checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	      }
	    } else {
	      return null;
	    }
	  }

	  if (offset > 0) {
	    this.scanner.skip(offset);
	  }

	  if (sign === 0) {
	    type = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	    if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	      this.error('Number sign is expected');
	    }
	  }

	  checkTokenIsInteger.call(this, sign !== 0);
	  return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	} // An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb


	var AnPlusB = {
	  name: 'AnPlusB',
	  structure: {
	    a: [String, null],
	    b: [String, null]
	  },
	  parse: function () {
	    /* eslint-disable brace-style*/
	    var start = this.scanner.tokenStart;
	    var a = null;
	    var b = null; // <integer>

	    if (this.scanner.tokenType === NUMBER$3) {
	      checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	      b = this.consume(NUMBER$3);
	    } // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	        a = '-1';
	        expectCharCode.call(this, 1, N$4);

	        switch (this.scanner.getTokenLength()) {
	          // -n
	          // -n <signed-integer>
	          // -n ['+' | '-'] <signless-integer>
	          case 2:
	            this.scanner.next();
	            b = consumeB$1.call(this);
	            break;
	          // -n- <signless-integer>

	          case 3:
	            expectCharCode.call(this, 2, HYPHENMINUS$3);
	            this.scanner.next();
	            this.scanner.skipSC();
	            checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            b = '-' + this.consume(NUMBER$3);
	            break;
	          // <dashndashdigit-ident>

	          default:
	            expectCharCode.call(this, 2, HYPHENMINUS$3);
	            checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	            this.scanner.next();
	            b = this.scanner.substrToCursor(start + 2);
	        }
	      } // '+'? n
	      // '+'? n <signed-integer>
	      // '+'? n ['+' | '-'] <signless-integer>
	      // '+'? n- <signless-integer>
	      // '+'? <ndashdigit-ident>
	      else if (this.scanner.tokenType === IDENT$3 || this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3) {
	          var sign = 0;
	          a = '1'; // just ignore a plus

	          if (this.scanner.isDelim(PLUSSIGN$3)) {
	            sign = 1;
	            this.scanner.next();
	          }

	          expectCharCode.call(this, 0, N$4);

	          switch (this.scanner.getTokenLength()) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	              this.scanner.next();
	              b = consumeB$1.call(this);
	              break;
	            // '+'? n- <signless-integer>

	            case 2:
	              expectCharCode.call(this, 1, HYPHENMINUS$3);
	              this.scanner.next();
	              this.scanner.skipSC();
	              checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	              b = '-' + this.consume(NUMBER$3);
	              break;
	            // '+'? <ndashdigit-ident>

	            default:
	              expectCharCode.call(this, 1, HYPHENMINUS$3);
	              checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	              this.scanner.next();
	              b = this.scanner.substrToCursor(start + sign + 1);
	          }
	        } // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	              if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                break;
	              }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	              this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i); // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>

	            if (i + 1 === this.scanner.tokenEnd) {
	              this.scanner.next();
	              b = consumeB$1.call(this);
	            } else {
	              expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3); // <ndash-dimension> <signless-integer>

	              if (i + 2 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                this.scanner.skipSC();
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                b = '-' + this.consume(NUMBER$3);
	              } // <ndashdigit-dimension>
	              else {
	                  checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                  this.scanner.next();
	                  b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	          } else {
	            this.error();
	          }

	    if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	      a = a.substr(1);
	    }

	    if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	      b = b.substr(1);
	    }

	    return {
	      type: 'AnPlusB',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      a: a,
	      b: b
	    };
	  },
	  generate: function (node) {
	    var a = node.a !== null && node.a !== undefined;
	    var b = node.b !== null && node.b !== undefined;

	    if (a) {
	      this.chunk(node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	      node.a === '1' ? 'n' : // eslint-disable-line operator-linebreak, indent
	      node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	      node.a + 'n' // eslint-disable-line operator-linebreak, indent
	      );

	      if (b) {
	        b = String(node.b);

	        if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	          this.chunk(b.charAt(0));
	          this.chunk(b.substr(1));
	        } else {
	          this.chunk('+');
	          this.chunk(b);
	        }
	      }
	    } else {
	      this.chunk(String(node.b));
	    }
	  }
	};

	var TYPE$a = tokenizer.TYPE;
	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	  if (this.scanner.tokenIndex > 0) {
	    if (this.scanner.lookupType(-1) === WhiteSpace) {
	      return this.scanner.tokenIndex > 1 ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1) : this.scanner.firstCharOffset;
	    }
	  }

	  return this.scanner.tokenStart;
	} // 0, 0, false


	function balanceEnd() {
	  return 0;
	} // LEFTCURLYBRACKET, 0, false


	function leftCurlyBracket(tokenType) {
	  return tokenType === LeftCurlyBracket ? 1 : 0;
	} // LEFTCURLYBRACKET, SEMICOLON, false


	function leftCurlyBracketOrSemicolon(tokenType) {
	  return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	} // EXCLAMATIONMARK, SEMICOLON, false


	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	  if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	    return 1;
	  }

	  return tokenType === Semicolon ? 1 : 0;
	} // 0, SEMICOLON, true


	function semicolonIncluded(tokenType) {
	  return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	  name: 'Raw',
	  structure: {
	    value: String
	  },
	  parse: function (startToken, mode, excludeWhiteSpace) {
	    var startOffset = this.scanner.getTokenStart(startToken);
	    var endOffset;
	    this.scanner.skip(this.scanner.getRawLength(startToken, mode || balanceEnd));

	    if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	      endOffset = getOffsetExcludeWS.call(this);
	    } else {
	      endOffset = this.scanner.tokenStart;
	    }

	    return {
	      type: 'Raw',
	      loc: this.getLocation(startOffset, endOffset),
	      value: this.scanner.source.substring(startOffset, endOffset)
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.value);
	  },
	  mode: {
	    default: balanceEnd,
	    leftCurlyBracket: leftCurlyBracket,
	    leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	    exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	    semicolonIncluded: semicolonIncluded
	  }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;
	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	  return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	  for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	    if (type === RIGHTCURLYBRACKET$1) {
	      return true;
	    }

	    if (type === LEFTCURLYBRACKET$1 || type === ATKEYWORD) {
	      return false;
	    }
	  }

	  return false;
	}

	var Atrule = {
	  name: 'Atrule',
	  structure: {
	    name: String,
	    prelude: ['AtrulePrelude', 'Raw', null],
	    block: ['Block', null]
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var name;
	    var nameLowerCase;
	    var prelude = null;
	    var block = null;
	    this.eat(ATKEYWORD);
	    name = this.scanner.substrToCursor(start + 1);
	    nameLowerCase = name.toLowerCase();
	    this.scanner.skipSC(); // parse prelude

	    if (this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET$1 && this.scanner.tokenType !== SEMICOLON) {
	      if (this.parseAtrulePrelude) {
	        prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw); // turn empty AtrulePrelude into null

	        if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	          prelude = null;
	        }
	      } else {
	        prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	      }

	      this.scanner.skipSC();
	    }

	    switch (this.scanner.tokenType) {
	      case SEMICOLON:
	        this.scanner.next();
	        break;

	      case LEFTCURLYBRACKET$1:
	        if (this.atrule.hasOwnProperty(nameLowerCase) && typeof this.atrule[nameLowerCase].block === 'function') {
	          block = this.atrule[nameLowerCase].block.call(this);
	        } else {
	          // TODO: should consume block content as Raw?
	          block = this.Block(isDeclarationBlockAtrule.call(this));
	        }

	        break;
	    }

	    return {
	      type: 'Atrule',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      name: name,
	      prelude: prelude,
	      block: block
	    };
	  },
	  generate: function (node) {
	    this.chunk('@');
	    this.chunk(node.name);

	    if (node.prelude !== null) {
	      this.chunk(' ');
	      this.node(node.prelude);
	    }

	    if (node.block) {
	      this.node(node.block);
	    } else {
	      this.chunk(';');
	    }
	  },
	  walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;
	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;
	var AtrulePrelude = {
	  name: 'AtrulePrelude',
	  structure: {
	    children: [[]]
	  },
	  parse: function (name) {
	    var children = null;

	    if (name !== null) {
	      name = name.toLowerCase();
	    }

	    this.scanner.skipSC();

	    if (this.atrule.hasOwnProperty(name) && typeof this.atrule[name].prelude === 'function') {
	      // custom consumer
	      children = this.atrule[name].prelude.call(this);
	    } else {
	      // default consumer
	      children = this.readSequence(this.scope.AtrulePrelude);
	    }

	    this.scanner.skipSC();

	    if (this.scanner.eof !== true && this.scanner.tokenType !== LEFTCURLYBRACKET$2 && this.scanner.tokenType !== SEMICOLON$1) {
	      this.error('Semicolon or block is expected');
	    }

	    if (children === null) {
	      children = this.createList();
	    }

	    return {
	      type: 'AtrulePrelude',
	      loc: this.getLocationFromList(children),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.children(node);
	  },
	  walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;
	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024; // U+0024 DOLLAR SIGN ($)

	var ASTERISK$1 = 0x002A; // U+002A ASTERISK (*)

	var EQUALSSIGN = 0x003D; // U+003D EQUALS SIGN (=)

	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)

	var VERTICALLINE$1 = 0x007C; // U+007C VERTICAL LINE (|)

	var TILDE = 0x007E; // U+007E TILDE (~)

	function getAttributeName() {
	  if (this.scanner.eof) {
	    this.error('Unexpected end of input');
	  }

	  var start = this.scanner.tokenStart;
	  var expectIdent = false;
	  var checkColon = true;

	  if (this.scanner.isDelim(ASTERISK$1)) {
	    expectIdent = true;
	    checkColon = false;
	    this.scanner.next();
	  } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	    this.eat(IDENT$4);
	  }

	  if (this.scanner.isDelim(VERTICALLINE$1)) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	      this.scanner.next();
	      this.eat(IDENT$4);
	    } else if (expectIdent) {
	      this.error('Identifier is expected', this.scanner.tokenEnd);
	    }
	  } else if (expectIdent) {
	    this.error('Vertical line is expected');
	  }

	  if (checkColon && this.scanner.tokenType === COLON) {
	    this.scanner.next();
	    this.eat(IDENT$4);
	  }

	  return {
	    type: 'Identifier',
	    loc: this.getLocation(start, this.scanner.tokenStart),
	    name: this.scanner.substrToCursor(start)
	  };
	}

	function getOperator() {
	  var start = this.scanner.tokenStart;
	  var code = this.scanner.source.charCodeAt(start);

	  if (code !== EQUALSSIGN && // =
	  code !== TILDE && // ~=
	  code !== CIRCUMFLEXACCENT && // ^=
	  code !== DOLLARSIGN && // $=
	  code !== ASTERISK$1 && // *=
	  code !== VERTICALLINE$1 // |=
	  ) {
	      this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	  this.scanner.next();

	  if (code !== EQUALSSIGN) {
	    if (!this.scanner.isDelim(EQUALSSIGN)) {
	      this.error('Equal sign is expected');
	    }

	    this.scanner.next();
	  }

	  return this.scanner.substrToCursor(start);
	} // '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'


	var AttributeSelector = {
	  name: 'AttributeSelector',
	  structure: {
	    name: 'Identifier',
	    matcher: [String, null],
	    value: ['String', 'Identifier', null],
	    flags: [String, null]
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var name;
	    var matcher = null;
	    var value = null;
	    var flags = null;
	    this.eat(LEFTSQUAREBRACKET$1);
	    this.scanner.skipSC();
	    name = getAttributeName.call(this);
	    this.scanner.skipSC();

	    if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	      // avoid case `[name i]`
	      if (this.scanner.tokenType !== IDENT$4) {
	        matcher = getOperator.call(this);
	        this.scanner.skipSC();
	        value = this.scanner.tokenType === STRING ? this.String() : this.Identifier();
	        this.scanner.skipSC();
	      } // attribute flags


	      if (this.scanner.tokenType === IDENT$4) {
	        flags = this.scanner.getTokenValue();
	        this.scanner.next();
	        this.scanner.skipSC();
	      }
	    }

	    this.eat(RIGHTSQUAREBRACKET$1);
	    return {
	      type: 'AttributeSelector',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      name: name,
	      matcher: matcher,
	      value: value,
	      flags: flags
	    };
	  },
	  generate: function (node) {
	    var flagsPrefix = ' ';
	    this.chunk('[');
	    this.node(node.name);

	    if (node.matcher !== null) {
	      this.chunk(node.matcher);

	      if (node.value !== null) {
	        this.node(node.value); // space between string and flags is not required

	        if (node.value.type === 'String') {
	          flagsPrefix = '';
	        }
	      }
	    }

	    if (node.flags !== null) {
	      this.chunk(flagsPrefix);
	      this.chunk(node.flags);
	    }

	    this.chunk(']');
	  }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;
	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	  return this.Raw(startToken, null, true);
	}

	function consumeRule() {
	  return this.parseWithFallback(this.Rule, consumeRaw$1);
	}

	function consumeRawDeclaration(startToken) {
	  return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}

	function consumeDeclaration() {
	  if (this.scanner.tokenType === SEMICOLON$2) {
	    return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	  }

	  var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	  if (this.scanner.tokenType === SEMICOLON$2) {
	    this.scanner.next();
	  }

	  return node;
	}

	var Block = {
	  name: 'Block',
	  structure: {
	    children: [['Atrule', 'Rule', 'Declaration']]
	  },
	  parse: function (isDeclaration) {
	    var consumer = isDeclaration ? consumeDeclaration : consumeRule;
	    var start = this.scanner.tokenStart;
	    var children = this.createList();
	    this.eat(LEFTCURLYBRACKET$3);

	    scan: while (!this.scanner.eof) {
	      switch (this.scanner.tokenType) {
	        case RIGHTCURLYBRACKET$2:
	          break scan;

	        case WHITESPACE$5:
	        case COMMENT$4:
	          this.scanner.next();
	          break;

	        case ATKEYWORD$1:
	          children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	          break;

	        default:
	          children.push(consumer.call(this));
	      }
	    }

	    if (!this.scanner.eof) {
	      this.eat(RIGHTCURLYBRACKET$2);
	    }

	    return {
	      type: 'Block',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.chunk('{');
	    this.children(node, function (prev) {
	      if (prev.type === 'Declaration') {
	        this.chunk(';');
	      }
	    });
	    this.chunk('}');
	  },
	  walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;
	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;
	var Brackets = {
	  name: 'Brackets',
	  structure: {
	    children: [[]]
	  },
	  parse: function (readSequence, recognizer) {
	    var start = this.scanner.tokenStart;
	    var children = null;
	    this.eat(LEFTSQUAREBRACKET$2);
	    children = readSequence.call(this, recognizer);

	    if (!this.scanner.eof) {
	      this.eat(RIGHTSQUAREBRACKET$2);
	    }

	    return {
	      type: 'Brackets',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.chunk('[');
	    this.children(node);
	    this.chunk(']');
	  }
	};

	var CDC = tokenizer.TYPE.CDC;
	var CDC_1 = {
	  name: 'CDC',
	  structure: [],
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    this.eat(CDC); // -->

	    return {
	      type: 'CDC',
	      loc: this.getLocation(start, this.scanner.tokenStart)
	    };
	  },
	  generate: function () {
	    this.chunk('-->');
	  }
	};

	var CDO = tokenizer.TYPE.CDO;
	var CDO_1 = {
	  name: 'CDO',
	  structure: [],
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    this.eat(CDO); // <!--

	    return {
	      type: 'CDO',
	      loc: this.getLocation(start, this.scanner.tokenStart)
	    };
	  },
	  generate: function () {
	    this.chunk('<!--');
	  }
	};

	var TYPE$g = tokenizer.TYPE;
	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)
	// '.' ident

	var ClassSelector = {
	  name: 'ClassSelector',
	  structure: {
	    name: String
	  },
	  parse: function () {
	    if (!this.scanner.isDelim(FULLSTOP)) {
	      this.error('Full stop is expected');
	    }

	    this.scanner.next();
	    return {
	      type: 'ClassSelector',
	      loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	      name: this.consume(IDENT$5)
	    };
	  },
	  generate: function (node) {
	    this.chunk('.');
	    this.chunk(node.name);
	  }
	};

	var TYPE$h = tokenizer.TYPE;
	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B; // U+002B PLUS SIGN (+)

	var SOLIDUS = 0x002F; // U+002F SOLIDUS (/)

	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)

	var TILDE$1 = 0x007E; // U+007E TILDE (~)
	// + | > | ~ | /deep/

	var Combinator = {
	  name: 'Combinator',
	  structure: {
	    name: String
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	    switch (code) {
	      case GREATERTHANSIGN$1:
	      case PLUSSIGN$4:
	      case TILDE$1:
	        this.scanner.next();
	        break;

	      case SOLIDUS:
	        this.scanner.next();

	        if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	          this.error('Identifier `deep` is expected');
	        }

	        this.scanner.next();

	        if (!this.scanner.isDelim(SOLIDUS)) {
	          this.error('Solidus is expected');
	        }

	        this.scanner.next();
	        break;

	      default:
	        this.error('Combinator is expected');
	    }

	    return {
	      type: 'Combinator',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      name: this.scanner.substrToCursor(start)
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.name);
	  }
	};

	var TYPE$i = tokenizer.TYPE;
	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A; // U+002A ASTERISK (*)

	var SOLIDUS$1 = 0x002F; // U+002F SOLIDUS (/)
	// '/*' .* '*/'

	var Comment = {
	  name: 'Comment',
	  structure: {
	    value: String
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var end = this.scanner.tokenEnd;
	    this.eat(COMMENT$5);

	    if (end - start + 2 >= 2 && this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 && this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	      end -= 2;
	    }

	    return {
	      type: 'Comment',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      value: this.scanner.source.substring(start + 2, end)
	    };
	  },
	  generate: function (node) {
	    this.chunk('/*');
	    this.chunk(node.value);
	    this.chunk('*/');
	  }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;
	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	var NUMBERSIGN$2 = 0x0023; // U+0023 NUMBER SIGN (#)

	var DOLLARSIGN$1 = 0x0024; // U+0024 DOLLAR SIGN ($)

	var AMPERSAND$1 = 0x0026; // U+0026 ANPERSAND (&)

	var ASTERISK$3 = 0x002A; // U+002A ASTERISK (*)

	var PLUSSIGN$5 = 0x002B; // U+002B PLUS SIGN (+)

	var SOLIDUS$2 = 0x002F; // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	  return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	  return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	  var startValueToken = this.scanner.tokenIndex;
	  var value = this.Value();

	  if (value.type !== 'Raw' && this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON$3 && this.scanner.isDelim(EXCLAMATIONMARK$2) === false && this.scanner.isBalanceEdge(startValueToken) === false) {
	    this.error();
	  }

	  return value;
	}

	var Declaration = {
	  name: 'Declaration',
	  structure: {
	    important: [Boolean, String],
	    property: String,
	    value: ['Value', 'Raw']
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var startToken = this.scanner.tokenIndex;
	    var property = readProperty$1.call(this);
	    var customProperty = isCustomProperty$1(property);
	    var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	    var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	    var important = false;
	    var value;
	    this.scanner.skipSC();
	    this.eat(COLON$1);

	    if (!customProperty) {
	      this.scanner.skipSC();
	    }

	    if (parseValue) {
	      value = this.parseWithFallback(consumeValue, consumeRaw);
	    } else {
	      value = consumeRaw.call(this, this.scanner.tokenIndex);
	    }

	    if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	      important = getImportant.call(this);
	      this.scanner.skipSC();
	    } // Do not include semicolon to range per spec
	    // https://drafts.csswg.org/css-syntax/#declaration-diagram


	    if (this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON$3 && this.scanner.isBalanceEdge(startToken) === false) {
	      this.error();
	    }

	    return {
	      type: 'Declaration',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      important: important,
	      property: property,
	      value: value
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.property);
	    this.chunk(':');
	    this.node(node.value);

	    if (node.important) {
	      this.chunk(node.important === true ? '!important' : '!' + node.important);
	    }
	  },
	  walkContext: 'declaration'
	};

	function readProperty$1() {
	  var start = this.scanner.tokenStart;

	  if (this.scanner.tokenType === DELIM$2) {
	    switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	      case ASTERISK$3:
	      case DOLLARSIGN$1:
	      case PLUSSIGN$5:
	      case NUMBERSIGN$2:
	      case AMPERSAND$1:
	        this.scanner.next();
	        break;
	      // TODO: not sure we should support this hack

	      case SOLIDUS$2:
	        this.scanner.next();

	        if (this.scanner.isDelim(SOLIDUS$2)) {
	          this.scanner.next();
	        }

	        break;
	    }
	  }

	  if (this.scanner.tokenType === HASH$1) {
	    this.eat(HASH$1);
	  } else {
	    this.eat(IDENT$7);
	  }

	  return this.scanner.substrToCursor(start);
	} // ! ws* important


	function getImportant() {
	  this.eat(DELIM$2);
	  this.scanner.skipSC();
	  var important = this.consume(IDENT$7); // store original value in case it differ from `important`
	  // for better original source restoring and hacks like `!ie` support

	  return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;
	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	  return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	  name: 'DeclarationList',
	  structure: {
	    children: [['Declaration']]
	  },
	  parse: function () {
	    var children = this.createList();

	     while (!this.scanner.eof) {
	      switch (this.scanner.tokenType) {
	        case WHITESPACE$6:
	        case COMMENT$6:
	        case SEMICOLON$4:
	          this.scanner.next();
	          break;

	        default:
	          children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	      }
	    }

	    return {
	      type: 'DeclarationList',
	      loc: this.getLocationFromList(children),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.children(node, function (prev) {
	      if (prev.type === 'Declaration') {
	        this.chunk(';');
	      }
	    });
	  }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;
	var DIMENSION$3 = TYPE$l.Dimension;
	var Dimension = {
	  name: 'Dimension',
	  structure: {
	    value: String,
	    unit: String
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var numberEnd = consumeNumber$3(this.scanner.source, start);
	    this.eat(DIMENSION$3);
	    return {
	      type: 'Dimension',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      value: this.scanner.source.substring(start, numberEnd),
	      unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.value);
	    this.chunk(node.unit);
	  }
	};

	var TYPE$m = tokenizer.TYPE;
	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis; // <function-token> <sequence> )

	var _Function = {
	  name: 'Function',
	  structure: {
	    name: String,
	    children: [[]]
	  },
	  parse: function (readSequence, recognizer) {
	    var start = this.scanner.tokenStart;
	    var name = this.consumeFunctionName();
	    var nameLowerCase = name.toLowerCase();
	    var children;
	    children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);

	    if (!this.scanner.eof) {
	      this.eat(RIGHTPARENTHESIS$2);
	    }

	    return {
	      type: 'Function',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      name: name,
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.name);
	    this.chunk('(');
	    this.children(node);
	    this.chunk(')');
	  },
	  walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;
	var HASH$2 = TYPE$n.Hash; // '#' ident

	var HexColor = {
	  name: 'HexColor',
	  structure: {
	    value: String
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    this.eat(HASH$2);
	    return {
	      type: 'HexColor',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      value: this.scanner.substrToCursor(start + 1)
	    };
	  },
	  generate: function (node) {
	    this.chunk('#');
	    this.chunk(node.value);
	  }
	};

	var TYPE$o = tokenizer.TYPE;
	var IDENT$8 = TYPE$o.Ident;
	var Identifier = {
	  name: 'Identifier',
	  structure: {
	    name: String
	  },
	  parse: function () {
	    return {
	      type: 'Identifier',
	      loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	      name: this.consume(IDENT$8)
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.name);
	  }
	};

	var TYPE$p = tokenizer.TYPE;
	var HASH$3 = TYPE$p.Hash; // <hash-token>

	var IdSelector = {
	  name: 'IdSelector',
	  structure: {
	    name: String
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart; // TODO: check value is an ident

	    this.eat(HASH$3);
	    return {
	      type: 'IdSelector',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      name: this.scanner.substrToCursor(start + 1)
	    };
	  },
	  generate: function (node) {
	    this.chunk('#');
	    this.chunk(node.name);
	  }
	};

	var TYPE$q = tokenizer.TYPE;
	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;
	var MediaFeature = {
	  name: 'MediaFeature',
	  structure: {
	    name: String,
	    value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var name;
	    var value = null;
	    this.eat(LEFTPARENTHESIS$2);
	    this.scanner.skipSC();
	    name = this.consume(IDENT$9);
	    this.scanner.skipSC();

	    if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	      this.eat(COLON$2);
	      this.scanner.skipSC();

	      switch (this.scanner.tokenType) {
	        case NUMBER$4:
	          if (this.lookupNonWSType(1) === DELIM$3) {
	            value = this.Ratio();
	          } else {
	            value = this.Number();
	          }

	          break;

	        case DIMENSION$4:
	          value = this.Dimension();
	          break;

	        case IDENT$9:
	          value = this.Identifier();
	          break;

	        default:
	          this.error('Number, dimension, ratio or identifier is expected');
	      }

	      this.scanner.skipSC();
	    }

	    this.eat(RIGHTPARENTHESIS$3);
	    return {
	      type: 'MediaFeature',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      name: name,
	      value: value
	    };
	  },
	  generate: function (node) {
	    this.chunk('(');
	    this.chunk(node.name);

	    if (node.value !== null) {
	      this.chunk(':');
	      this.node(node.value);
	    }

	    this.chunk(')');
	  }
	};

	var TYPE$r = tokenizer.TYPE;
	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;
	var MediaQuery = {
	  name: 'MediaQuery',
	  structure: {
	    children: [['Identifier', 'MediaFeature', 'WhiteSpace']]
	  },
	  parse: function () {
	    this.scanner.skipSC();
	    var children = this.createList();
	    var child = null;
	    var space = null;

	    scan: while (!this.scanner.eof) {
	      switch (this.scanner.tokenType) {
	        case COMMENT$7:
	          this.scanner.next();
	          continue;

	        case WHITESPACE$7:
	          space = this.WhiteSpace();
	          continue;

	        case IDENT$a:
	          child = this.Identifier();
	          break;

	        case LEFTPARENTHESIS$3:
	          child = this.MediaFeature();
	          break;

	        default:
	          break scan;
	      }

	      if (space !== null) {
	        children.push(space);
	        space = null;
	      }

	      children.push(child);
	    }

	    if (child === null) {
	      this.error('Identifier or parenthesis is expected');
	    }

	    return {
	      type: 'MediaQuery',
	      loc: this.getLocationFromList(children),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.children(node);
	  }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;
	var MediaQueryList = {
	  name: 'MediaQueryList',
	  structure: {
	    children: [['MediaQuery']]
	  },
	  parse: function (relative) {
	    var children = this.createList();
	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	      children.push(this.MediaQuery(relative));

	      if (this.scanner.tokenType !== COMMA$1) {
	        break;
	      }

	      this.scanner.next();
	    }

	    return {
	      type: 'MediaQueryList',
	      loc: this.getLocationFromList(children),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.children(node, function () {
	      this.chunk(',');
	    });
	  }
	};

	var Nth = {
	  name: 'Nth',
	  structure: {
	    nth: ['AnPlusB', 'Identifier'],
	    selector: ['SelectorList', null]
	  },
	  parse: function (allowOfClause) {
	    this.scanner.skipSC();
	    var start = this.scanner.tokenStart;
	    var end = start;
	    var selector = null;
	    var query;

	    if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	      query = this.Identifier();
	    } else {
	      query = this.AnPlusB();
	    }

	    this.scanner.skipSC();

	    if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	      this.scanner.next();
	      selector = this.SelectorList();

	      if (this.needPositions) {
	        end = this.getLastListNode(selector.children).loc.end.offset;
	      }
	    } else {
	      if (this.needPositions) {
	        end = query.loc.end.offset;
	      }
	    }

	    return {
	      type: 'Nth',
	      loc: this.getLocation(start, end),
	      nth: query,
	      selector: selector
	    };
	  },
	  generate: function (node) {
	    this.node(node.nth);

	    if (node.selector !== null) {
	      this.chunk(' of ');
	      this.node(node.selector);
	    }
	  }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;
	var _Number = {
	  name: 'Number',
	  structure: {
	    value: String
	  },
	  parse: function () {
	    return {
	      type: 'Number',
	      loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	      value: this.consume(NUMBER$5)
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.value);
	  }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	  name: 'Operator',
	  structure: {
	    value: String
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    this.scanner.next();
	    return {
	      type: 'Operator',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      value: this.scanner.substrToCursor(start)
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.value);
	  }
	};

	var TYPE$s = tokenizer.TYPE;
	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;
	var Parentheses = {
	  name: 'Parentheses',
	  structure: {
	    children: [[]]
	  },
	  parse: function (readSequence, recognizer) {
	    var start = this.scanner.tokenStart;
	    var children = null;
	    this.eat(LEFTPARENTHESIS$4);
	    children = readSequence.call(this, recognizer);

	    if (!this.scanner.eof) {
	      this.eat(RIGHTPARENTHESIS$4);
	    }

	    return {
	      type: 'Parentheses',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.chunk('(');
	    this.children(node);
	    this.chunk(')');
	  }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;
	var PERCENTAGE$1 = TYPE$t.Percentage;
	var Percentage = {
	  name: 'Percentage',
	  structure: {
	    value: String
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var numberEnd = consumeNumber$4(this.scanner.source, start);
	    this.eat(PERCENTAGE$1);
	    return {
	      type: 'Percentage',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      value: this.scanner.source.substring(start, numberEnd)
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.value);
	    this.chunk('%');
	  }
	};

	var TYPE$u = tokenizer.TYPE;
	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis; // : [ <ident> | <function-token> <any-value>? ) ]

	var PseudoClassSelector = {
	  name: 'PseudoClassSelector',
	  structure: {
	    name: String,
	    children: [['Raw'], null]
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var children = null;
	    var name;
	    var nameLowerCase;
	    this.eat(COLON$3);

	    if (this.scanner.tokenType === FUNCTION$1) {
	      name = this.consumeFunctionName();
	      nameLowerCase = name.toLowerCase();

	      if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	        this.scanner.skipSC();
	        children = this.pseudo[nameLowerCase].call(this);
	        this.scanner.skipSC();
	      } else {
	        children = this.createList();
	        children.push(this.Raw(this.scanner.tokenIndex, null, false));
	      }

	      this.eat(RIGHTPARENTHESIS$5);
	    } else {
	      name = this.consume(IDENT$b);
	    }

	    return {
	      type: 'PseudoClassSelector',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      name: name,
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.chunk(':');
	    this.chunk(node.name);

	    if (node.children !== null) {
	      this.chunk('(');
	      this.children(node);
	      this.chunk(')');
	    }
	  },
	  walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;
	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis; // :: [ <ident> | <function-token> <any-value>? ) ]

	var PseudoElementSelector = {
	  name: 'PseudoElementSelector',
	  structure: {
	    name: String,
	    children: [['Raw'], null]
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var children = null;
	    var name;
	    var nameLowerCase;
	    this.eat(COLON$4);
	    this.eat(COLON$4);

	    if (this.scanner.tokenType === FUNCTION$2) {
	      name = this.consumeFunctionName();
	      nameLowerCase = name.toLowerCase();

	      if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	        this.scanner.skipSC();
	        children = this.pseudo[nameLowerCase].call(this);
	        this.scanner.skipSC();
	      } else {
	        children = this.createList();
	        children.push(this.Raw(this.scanner.tokenIndex, null, false));
	      }

	      this.eat(RIGHTPARENTHESIS$6);
	    } else {
	      name = this.consume(IDENT$c);
	    }

	    return {
	      type: 'PseudoElementSelector',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      name: name,
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.chunk('::');
	    this.chunk(node.name);

	    if (node.children !== null) {
	      this.chunk('(');
	      this.children(node);
	      this.chunk(')');
	    }
	  },
	  walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;
	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F; // U+002F SOLIDUS (/)

	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)
	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.

	function consumeNumber$5() {
	  this.scanner.skipWS();
	  var value = this.consume(NUMBER$6);

	  for (var i = 0; i < value.length; i++) {
	    var code = value.charCodeAt(i);

	    if (!isDigit$5(code) && code !== FULLSTOP$1) {
	      this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	    }
	  }

	  if (Number(value) === 0) {
	    this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	  }

	  return value;
	} // <positive-integer> S* '/' S* <positive-integer>


	var Ratio = {
	  name: 'Ratio',
	  structure: {
	    left: String,
	    right: String
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var left = consumeNumber$5.call(this);
	    var right;
	    this.scanner.skipWS();

	    if (!this.scanner.isDelim(SOLIDUS$3)) {
	      this.error('Solidus is expected');
	    }

	    this.eat(DELIM$4);
	    right = consumeNumber$5.call(this);
	    return {
	      type: 'Ratio',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      left: left,
	      right: right
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.left);
	    this.chunk('/');
	    this.chunk(node.right);
	  }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;
	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	  return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	  var prelude = this.SelectorList();

	  if (prelude.type !== 'Raw' && this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	    this.error();
	  }

	  return prelude;
	}

	var Rule = {
	  name: 'Rule',
	  structure: {
	    prelude: ['SelectorList', 'Raw'],
	    block: ['Block']
	  },
	  parse: function () {
	    var startToken = this.scanner.tokenIndex;
	    var startOffset = this.scanner.tokenStart;
	    var prelude;
	    var block;

	    if (this.parseRulePrelude) {
	      prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	    } else {
	      prelude = consumeRaw$3.call(this, startToken);
	    }

	    block = this.Block(true);
	    return {
	      type: 'Rule',
	      loc: this.getLocation(startOffset, this.scanner.tokenStart),
	      prelude: prelude,
	      block: block
	    };
	  },
	  generate: function (node) {
	    this.node(node.prelude);
	    this.node(node.block);
	  },
	  walkContext: 'rule'
	};

	var Selector = {
	  name: 'Selector',
	  structure: {
	    children: [['TypeSelector', 'IdSelector', 'ClassSelector', 'AttributeSelector', 'PseudoClassSelector', 'PseudoElementSelector', 'Combinator', 'WhiteSpace']]
	  },
	  parse: function () {
	    var children = this.readSequence(this.scope.Selector); // nothing were consumed

	    if (this.getFirstListNode(children) === null) {
	      this.error('Selector is expected');
	    }

	    return {
	      type: 'Selector',
	      loc: this.getLocationFromList(children),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.children(node);
	  }
	};

	var TYPE$y = tokenizer.TYPE;
	var COMMA$2 = TYPE$y.Comma;
	var SelectorList = {
	  name: 'SelectorList',
	  structure: {
	    children: [['Selector', 'Raw']]
	  },
	  parse: function () {
	    var children = this.createList();

	    while (!this.scanner.eof) {
	      children.push(this.Selector());

	      if (this.scanner.tokenType === COMMA$2) {
	        this.scanner.next();
	        continue;
	      }

	      break;
	    }

	    return {
	      type: 'SelectorList',
	      loc: this.getLocationFromList(children),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.children(node, function () {
	      this.chunk(',');
	    });
	  },
	  walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;
	var _String = {
	  name: 'String',
	  structure: {
	    value: String
	  },
	  parse: function () {
	    return {
	      type: 'String',
	      loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	      value: this.consume(STRING$1)
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.value);
	  }
	};

	var TYPE$z = tokenizer.TYPE;
	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	  return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	  name: 'StyleSheet',
	  structure: {
	    children: [['Comment', 'CDO', 'CDC', 'Atrule', 'Rule', 'Raw']]
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var children = this.createList();
	    var child;

	     while (!this.scanner.eof) {
	      switch (this.scanner.tokenType) {
	        case WHITESPACE$8:
	          this.scanner.next();
	          continue;

	        case COMMENT$8:
	          // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	          if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	            this.scanner.next();
	            continue;
	          }

	          child = this.Comment();
	          break;

	        case CDO$1:
	          // <!--
	          child = this.CDO();
	          break;

	        case CDC$1:
	          // -->
	          child = this.CDC();
	          break;
	        // CSS Syntax Module Level 3
	        // §2.2 Error handling
	        // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.

	        case ATKEYWORD$2:
	          child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	          break;
	        // Anything else starts a qualified rule ...

	        default:
	          child = this.parseWithFallback(this.Rule, consumeRaw$4);
	      }

	      children.push(child);
	    }

	    return {
	      type: 'StyleSheet',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.children(node);
	  },
	  walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;
	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A; // U+002A ASTERISK (*)

	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	  if (this.scanner.tokenType !== IDENT$d && this.scanner.isDelim(ASTERISK$4) === false) {
	    this.error('Identifier or asterisk is expected');
	  }

	  this.scanner.next();
	} // ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*


	var TypeSelector = {
	  name: 'TypeSelector',
	  structure: {
	    name: String
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;

	    if (this.scanner.isDelim(VERTICALLINE$2)) {
	      this.scanner.next();
	      eatIdentifierOrAsterisk.call(this);
	    } else {
	      eatIdentifierOrAsterisk.call(this);

	      if (this.scanner.isDelim(VERTICALLINE$2)) {
	        this.scanner.next();
	        eatIdentifierOrAsterisk.call(this);
	      }
	    }

	    return {
	      type: 'TypeSelector',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      name: this.scanner.substrToCursor(start)
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.name);
	  }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;
	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B; // U+002B PLUS SIGN (+)

	var HYPHENMINUS$4 = 0x002D; // U+002D HYPHEN-MINUS (-)

	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)

	var U$1 = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	  for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	      if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	        this.error();
	      }

	      return -1;
	    }

	    if (!isHexDigit$4(code)) {
	      this.error(allowDash && len !== 0 ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected' : len < 6 ? 'Hex digit is expected' : 'Unexpected input', pos);
	    }

	    if (++len > 6) {
	      this.error('Too many hex digits', pos);
	    }
	  }

	  this.scanner.next();
	  return len;
	}

	function eatQuestionMarkSequence(max) {
	  var count = 0;

	  while (this.scanner.isDelim(QUESTIONMARK$2)) {
	    if (++count > max) {
	      this.error('Too many question marks');
	    }

	    this.scanner.next();
	  }
	}

	function startsWith$2(code) {
	  if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	    this.error(NAME$3[code] + ' is expected');
	  }
	} // https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+


	function scanUnicodeRange() {
	  var hexLength = 0; // u '+' <ident-token> '?'*
	  // u '+' '?'+

	  if (this.scanner.isDelim(PLUSSIGN$6)) {
	    this.scanner.next();

	    if (this.scanner.tokenType === IDENT$e) {
	      hexLength = eatHexSequence.call(this, 0, true);

	      if (hexLength > 0) {
	        eatQuestionMarkSequence.call(this, 6 - hexLength);
	      }

	      return;
	    }

	    if (this.scanner.isDelim(QUESTIONMARK$2)) {
	      this.scanner.next();
	      eatQuestionMarkSequence.call(this, 5);
	      return;
	    }

	    this.error('Hex digit or question mark is expected');
	    return;
	  } // u <number-token> '?'*
	  // u <number-token> <dimension-token>
	  // u <number-token> <number-token>


	  if (this.scanner.tokenType === NUMBER$7) {
	    startsWith$2.call(this, PLUSSIGN$6);
	    hexLength = eatHexSequence.call(this, 1, true);

	    if (this.scanner.isDelim(QUESTIONMARK$2)) {
	      eatQuestionMarkSequence.call(this, 6 - hexLength);
	      return;
	    }

	    if (this.scanner.tokenType === DIMENSION$5 || this.scanner.tokenType === NUMBER$7) {
	      startsWith$2.call(this, HYPHENMINUS$4);
	      eatHexSequence.call(this, 1, false);
	      return;
	    }

	    return;
	  } // u <dimension-token> '?'*


	  if (this.scanner.tokenType === DIMENSION$5) {
	    startsWith$2.call(this, PLUSSIGN$6);
	    hexLength = eatHexSequence.call(this, 1, true);

	    if (hexLength > 0) {
	      eatQuestionMarkSequence.call(this, 6 - hexLength);
	    }

	    return;
	  }

	  this.error();
	}

	var UnicodeRange = {
	  name: 'UnicodeRange',
	  structure: {
	    value: String
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart; // U or u

	    if (!cmpChar$4(this.scanner.source, start, U$1)) {
	      this.error('U is expected');
	    }

	    if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	      this.error('Plus sign is expected');
	    }

	    this.scanner.next();
	    scanUnicodeRange.call(this);
	    return {
	      type: 'UnicodeRange',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      value: this.scanner.substrToCursor(start)
	    };
	  },
	  generate: function (node) {
	    this.chunk(node.value);
	  }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;
	var FUNCTION$3 = TYPE$C.Function;
	var URL$1 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis; // <url-token> | <function-token> <string> )

	var Url = {
	  name: 'Url',
	  structure: {
	    value: ['String', 'Raw']
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var value;

	    switch (this.scanner.tokenType) {
	      case URL$1:
	        var rawStart = start + 4;
	        var rawEnd = this.scanner.tokenEnd - 1;

	        while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	          rawStart++;
	        }

	        while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	          rawEnd--;
	        }

	        value = {
	          type: 'Raw',
	          loc: this.getLocation(rawStart, rawEnd),
	          value: this.scanner.source.substring(rawStart, rawEnd)
	        };
	        this.eat(URL$1);
	        break;

	      case FUNCTION$3:
	        if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	          this.error('Function name must be `url`');
	        }

	        this.eat(FUNCTION$3);
	        this.scanner.skipSC();
	        value = this.String();
	        this.scanner.skipSC();
	        this.eat(RIGHTPARENTHESIS$7);
	        break;

	      default:
	        this.error('Url or Function is expected');
	    }

	    return {
	      type: 'Url',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      value: value
	    };
	  },
	  generate: function (node) {
	    this.chunk('url');
	    this.chunk('(');
	    this.node(node.value);
	    this.chunk(')');
	  }
	};

	var Value = {
	  name: 'Value',
	  structure: {
	    children: [[]]
	  },
	  parse: function () {
	    var start = this.scanner.tokenStart;
	    var children = this.readSequence(this.scope.Value);
	    return {
	      type: 'Value',
	      loc: this.getLocation(start, this.scanner.tokenStart),
	      children: children
	    };
	  },
	  generate: function (node) {
	    this.children(node);
	  }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	  type: 'WhiteSpace',
	  loc: null,
	  value: ' '
	});
	var WhiteSpace$1 = {
	  name: 'WhiteSpace',
	  structure: {
	    value: String
	  },
	  parse: function () {
	    this.eat(WHITESPACE$9);
	    return SPACE$2; // return {
	    //     type: 'WhiteSpace',
	    //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	    //     value: this.consume(WHITESPACE)
	    // };
	  },
	  generate: function (node) {
	    this.chunk(node.value);
	  }
	};

	var node = {
	  AnPlusB: AnPlusB,
	  Atrule: Atrule,
	  AtrulePrelude: AtrulePrelude,
	  AttributeSelector: AttributeSelector,
	  Block: Block,
	  Brackets: Brackets,
	  CDC: CDC_1,
	  CDO: CDO_1,
	  ClassSelector: ClassSelector,
	  Combinator: Combinator,
	  Comment: Comment,
	  Declaration: Declaration,
	  DeclarationList: DeclarationList,
	  Dimension: Dimension,
	  Function: _Function,
	  HexColor: HexColor,
	  Identifier: Identifier,
	  IdSelector: IdSelector,
	  MediaFeature: MediaFeature,
	  MediaQuery: MediaQuery,
	  MediaQueryList: MediaQueryList,
	  Nth: Nth,
	  Number: _Number,
	  Operator: Operator,
	  Parentheses: Parentheses,
	  Percentage: Percentage,
	  PseudoClassSelector: PseudoClassSelector,
	  PseudoElementSelector: PseudoElementSelector,
	  Ratio: Ratio,
	  Raw: Raw,
	  Rule: Rule,
	  Selector: Selector,
	  SelectorList: SelectorList,
	  String: _String,
	  StyleSheet: StyleSheet,
	  TypeSelector: TypeSelector,
	  UnicodeRange: UnicodeRange,
	  Url: Url,
	  Value: Value,
	  WhiteSpace: WhiteSpace$1
	};

	var data$1 = getCjsExportFromNamespace(defaultSyntax$1);

	var lexer = {
	  generic: true,
	  types: data$1.types,
	  atrules: data$1.atrules,
	  properties: data$1.properties,
	  node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;
	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$2 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023; // U+0023 NUMBER SIGN (#)

	var ASTERISK$5 = 0x002A; // U+002A ASTERISK (*)

	var PLUSSIGN$7 = 0x002B; // U+002B PLUS SIGN (+)

	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)

	var SOLIDUS$4 = 0x002F; // U+002F SOLIDUS (/)

	var U$2 = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	  switch (this.scanner.tokenType) {
	    case HASH$4:
	      return this.HexColor();

	    case COMMA$3:
	      context.space = null;
	      context.ignoreWSAfter = true;
	      return this.Operator();

	    case LEFTPARENTHESIS$5:
	      return this.Parentheses(this.readSequence, context.recognizer);

	    case LEFTSQUAREBRACKET$3:
	      return this.Brackets(this.readSequence, context.recognizer);

	    case STRING$2:
	      return this.String();

	    case DIMENSION$6:
	      return this.Dimension();

	    case PERCENTAGE$2:
	      return this.Percentage();

	    case NUMBER$8:
	      return this.Number();

	    case FUNCTION$4:
	      return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(') ? this.Url() : this.Function(this.readSequence, context.recognizer);

	    case URL$2:
	      return this.Url();

	    case IDENT$f:
	      // check for unicode range, it should start with u+ or U+
	      if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) && cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	        return this.UnicodeRange();
	      } else {
	        return this.Identifier();
	      }

	    case DELIM$5:
	      var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	      if (code === SOLIDUS$4 || code === ASTERISK$5 || code === PLUSSIGN$7 || code === HYPHENMINUS$5) {
	        return this.Operator(); // TODO: replace with Delim
	      } // TODO: produce a node with Delim node type


	      if (code === NUMBERSIGN$3) {
	        this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	      }

	      break;
	  }
	};

	var atrulePrelude = {
	  getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;
	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023; // U+0023 NUMBER SIGN (#)

	var ASTERISK$6 = 0x002A; // U+002A ASTERISK (*)

	var PLUSSIGN$8 = 0x002B; // U+002B PLUS SIGN (+)

	var SOLIDUS$5 = 0x002F; // U+002F SOLIDUS (/)

	var FULLSTOP$2 = 0x002E; // U+002E FULL STOP (.)

	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)

	var VERTICALLINE$3 = 0x007C; // U+007C VERTICAL LINE (|)

	var TILDE$2 = 0x007E; // U+007E TILDE (~)

	function getNode(context) {
	  switch (this.scanner.tokenType) {
	    case LEFTSQUAREBRACKET$4:
	      return this.AttributeSelector();

	    case HASH$5:
	      return this.IdSelector();

	    case COLON$5:
	      if (this.scanner.lookupType(1) === COLON$5) {
	        return this.PseudoElementSelector();
	      } else {
	        return this.PseudoClassSelector();
	      }

	    case IDENT$g:
	      return this.TypeSelector();

	    case NUMBER$9:
	    case PERCENTAGE$3:
	      return this.Percentage();

	    case DIMENSION$7:
	      // throws when .123ident
	      if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	        this.error('Identifier is expected', this.scanner.tokenStart + 1);
	      }

	      break;

	    case DELIM$6:
	      var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	      switch (code) {
	        case PLUSSIGN$8:
	        case GREATERTHANSIGN$2:
	        case TILDE$2:
	          context.space = null;
	          context.ignoreWSAfter = true;
	          return this.Combinator();

	        case SOLIDUS$5:
	          // /deep/
	          return this.Combinator();

	        case FULLSTOP$2:
	          return this.ClassSelector();

	        case ASTERISK$6:
	        case VERTICALLINE$3:
	          return this.TypeSelector();

	        case NUMBERSIGN$4:
	          return this.IdSelector();
	      }

	      break;
	  }
	}
	var selector = {
	  getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function () {
	  this.scanner.skipSC();
	  var children = this.createSingleNodeList(this.IdSelector());
	  this.scanner.skipSC();
	  return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function () {
	  return this.createSingleNodeList(this.Raw(this.scanner.tokenIndex, null, false));
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;
	var COMMA$4 = TYPE$F.Comma; // var( <ident> , <value>? )

	var _var = function () {
	  var children = this.createList();
	  this.scanner.skipSC(); // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer

	  children.push(this.Identifier());
	  this.scanner.skipSC();

	  if (this.scanner.tokenType === COMMA$4) {
	    children.push(this.Operator());
	    children.push(this.parseCustomProperty ? this.Value(null) : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false));
	  }

	  return children;
	};

	var value = {
	  getNode: _default,
	  '-moz-element': element,
	  'element': element,
	  'expression': expression,
	  'var': _var
	};

	var scope = {
	  AtrulePrelude: atrulePrelude,
	  Selector: selector,
	  Value: value
	};

	var fontFace = {
	  parse: {
	    prelude: null,
	    block: function () {
	      return this.Block(true);
	    }
	  }
	};

	var TYPE$G = tokenizer.TYPE;
	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$3 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;
	var _import = {
	  parse: {
	    prelude: function () {
	      var children = this.createList();
	      this.scanner.skipSC();

	      switch (this.scanner.tokenType) {
	        case STRING$3:
	          children.push(this.String());
	          break;

	        case URL$3:
	        case FUNCTION$5:
	          children.push(this.Url());
	          break;

	        default:
	          this.error('String or url() is expected');
	      }

	      if (this.lookupNonWSType(0) === IDENT$h || this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	        children.push(this.WhiteSpace());
	        children.push(this.MediaQueryList());
	      }

	      return children;
	    },
	    block: null
	  }
	};

	var media = {
	  parse: {
	    prelude: function () {
	      return this.createSingleNodeList(this.MediaQueryList());
	    },
	    block: function () {
	      return this.Block(false);
	    }
	  }
	};

	var page = {
	  parse: {
	    prelude: function () {
	      return this.createSingleNodeList(this.SelectorList());
	    },
	    block: function () {
	      return this.Block(true);
	    }
	  }
	};

	var TYPE$H = tokenizer.TYPE;
	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	  return this.createSingleNodeList(this.Raw(this.scanner.tokenIndex, null, false));
	}

	function parentheses() {
	  this.scanner.skipSC();

	  if (this.scanner.tokenType === IDENT$i && this.lookupNonWSType(1) === COLON$6) {
	    return this.createSingleNodeList(this.Declaration());
	  }

	  return readSequence.call(this);
	}

	function readSequence() {
	  var children = this.createList();
	  var space = null;
	  var child;
	  this.scanner.skipSC();

	  scan: while (!this.scanner.eof) {
	    switch (this.scanner.tokenType) {
	      case WHITESPACE$a:
	        space = this.WhiteSpace();
	        continue;

	      case COMMENT$9:
	        this.scanner.next();
	        continue;

	      case FUNCTION$6:
	        child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	        break;

	      case IDENT$i:
	        child = this.Identifier();
	        break;

	      case LEFTPARENTHESIS$7:
	        child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	        break;

	      default:
	        break scan;
	    }

	    if (space !== null) {
	      children.push(space);
	      space = null;
	    }

	    children.push(child);
	  }

	  return children;
	}

	var supports = {
	  parse: {
	    prelude: function () {
	      var children = readSequence.call(this);

	      if (this.getFirstListNode(children) === null) {
	        this.error('Condition is expected');
	      }

	      return children;
	    },
	    block: function () {
	      return this.Block(false);
	    }
	  }
	};

	var atrule = {
	  'font-face': fontFace,
	  'import': _import,
	  'media': media,
	  'page': page,
	  'supports': supports
	};

	var dir = {
	  parse: function () {
	    return this.createSingleNodeList(this.Identifier());
	  }
	};

	var has$1 = {
	  parse: function () {
	    return this.createSingleNodeList(this.SelectorList());
	  }
	};

	var lang = {
	  parse: function () {
	    return this.createSingleNodeList(this.Identifier());
	  }
	};

	var selectorList = {
	  parse: function selectorList() {
	    return this.createSingleNodeList(this.SelectorList());
	  }
	};

	var matches$2 = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;
	var nthWithOfClause = {
	  parse: function nthWithOfClause() {
	    return this.createSingleNodeList(this.Nth(ALLOW_OF_CLAUSE));
	  }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;
	var nth = {
	  parse: function nth() {
	    return this.createSingleNodeList(this.Nth(DISALLOW_OF_CLAUSE));
	  }
	};

	var nthLastOfType = nth;

	var nthOfType = nth;

	var slotted = {
	  parse: function compoundSelector() {
	    return this.createSingleNodeList(this.Selector());
	  }
	};

	var pseudo = {
	  'dir': dir,
	  'has': has$1,
	  'lang': lang,
	  'matches': matches$2,
	  'not': not,
	  'nth-child': nthChild,
	  'nth-last-child': nthLastChild,
	  'nth-last-of-type': nthLastOfType,
	  'nth-of-type': nthOfType,
	  'slotted': slotted
	};

	var parser = {
	  parseContext: {
	    default: 'StyleSheet',
	    stylesheet: 'StyleSheet',
	    atrule: 'Atrule',
	    atrulePrelude: function (options) {
	      return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	    },
	    mediaQueryList: 'MediaQueryList',
	    mediaQuery: 'MediaQuery',
	    rule: 'Rule',
	    selectorList: 'SelectorList',
	    selector: 'Selector',
	    block: function () {
	      return this.Block(true);
	    },
	    declarationList: 'DeclarationList',
	    declaration: 'Declaration',
	    value: 'Value'
	  },
	  scope: scope,
	  atrule: atrule,
	  pseudo: pseudo,
	  node: node
	};

	var walker = {
	  node: node
	};

	function merge() {
	  var dest = {};

	  for (var i = 0; i < arguments.length; i++) {
	    var src = arguments[i];

	    for (var key in src) {
	      dest[key] = src[key];
	    }
	  }

	  return dest;
	}

	var syntax = create$4.create(merge(lexer, parser, walker));

	var lib = syntax;

	var hasOwnProperty$7 = Object.prototype.hasOwnProperty;

	function buildMap(list, caseInsensitive) {
	  var map = Object.create(null);

	  if (!Array.isArray(list)) {
	    return null;
	  }

	  for (var i = 0; i < list.length; i++) {
	    var name = list[i];

	    if (caseInsensitive) {
	      name = name.toLowerCase();
	    }

	    map[name] = true;
	  }

	  return map;
	}

	function buildList(data) {
	  if (!data) {
	    return null;
	  }

	  var tags = buildMap(data.tags, true);
	  var ids = buildMap(data.ids);
	  var classes = buildMap(data.classes);

	  if (tags === null && ids === null && classes === null) {
	    return null;
	  }

	  return {
	    tags: tags,
	    ids: ids,
	    classes: classes
	  };
	}

	function buildIndex(data) {
	  var scopes = false;

	  if (data.scopes && Array.isArray(data.scopes)) {
	    scopes = Object.create(null);

	    for (var i = 0; i < data.scopes.length; i++) {
	      var list = data.scopes[i];

	      if (!list || !Array.isArray(list)) {
	        throw new Error('Wrong usage format');
	      }

	      for (var j = 0; j < list.length; j++) {
	        var name = list[j];

	        if (hasOwnProperty$7.call(scopes, name)) {
	          throw new Error('Class can\'t be used for several scopes: ' + name);
	        }

	        scopes[name] = i + 1;
	      }
	    }
	  }

	  return {
	    whitelist: buildList(data),
	    blacklist: buildList(data.blacklist),
	    scopes: scopes
	  };
	}

	var usage = {
	  buildIndex: buildIndex
	};

	var utils$1 = {
	  hasNoChildren: function (node) {
	    return !node || !node.children || node.children.isEmpty();
	  },
	  isNodeChildrenList: function (node, list) {
	    return node !== null && node.children === list;
	  }
	};

	var resolveKeyword = lib.keyword;
	var {
	  hasNoChildren
	} = utils$1;

	var Atrule$1 = function cleanAtrule(node, item, list) {
	  if (node.block) {
	    // otherwise removed at-rule don't prevent @import for removal
	    if (this.stylesheet !== null) {
	      this.stylesheet.firstAtrulesAllowed = false;
	    }

	    if (hasNoChildren(node.block)) {
	      list.remove(item);
	      return;
	    }
	  }

	  switch (node.name) {
	    case 'charset':
	      if (hasNoChildren(node.prelude)) {
	        list.remove(item);
	        return;
	      } // if there is any rule before @charset -> remove it


	      if (item.prev) {
	        list.remove(item);
	        return;
	      }

	      break;

	    case 'import':
	      if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
	        list.remove(item);
	        return;
	      } // if there are some rules that not an @import or @charset before @import
	      // remove it


	      list.prevUntil(item.prev, function (rule) {
	        if (rule.type === 'Atrule') {
	          if (rule.name === 'import' || rule.name === 'charset') {
	            return;
	          }
	        }

	        this.root.firstAtrulesAllowed = false;
	        list.remove(item);
	        return true;
	      }, this);
	      break;

	    default:
	      var name = resolveKeyword(node.name).basename;

	      if (name === 'keyframes' || name === 'media' || name === 'supports') {
	        // drop at-rule with no prelude
	        if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
	          list.remove(item);
	        }
	      }

	  }
	};

	var Comment$1 = function cleanComment(data, item, list) {
	  list.remove(item);
	};

	var Declaration$1 = function cleanDeclartion(node, item, list) {
	  if (node.value.children && node.value.children.isEmpty()) {
	    list.remove(item);
	  }
	};

	var {
	  isNodeChildrenList
	} = utils$1;

	var Raw$1 = function cleanRaw(node, item, list) {
	  // raw in stylesheet or block children
	  if (isNodeChildrenList(this.stylesheet, list) || isNodeChildrenList(this.block, list)) {
	    list.remove(item);
	  }
	};

	var hasOwnProperty$8 = Object.prototype.hasOwnProperty;
	var walk$1 = lib.walk;
	var {
	  hasNoChildren: hasNoChildren$1
	} = utils$1;

	function cleanUnused(selectorList, usageData) {
	  selectorList.children.each(function (selector, item, list) {
	    var shouldRemove = false;
	    walk$1(selector, function (node) {
	      // ignore nodes in nested selectors
	      if (this.selector === null || this.selector === selectorList) {
	        switch (node.type) {
	          case 'SelectorList':
	            // TODO: remove toLowerCase when pseudo selectors will be normalized
	            // ignore selectors inside :not()
	            if (this.function === null || this.function.name.toLowerCase() !== 'not') {
	              if (cleanUnused(node, usageData)) {
	                shouldRemove = true;
	              }
	            }

	            break;

	          case 'ClassSelector':
	            if (usageData.whitelist !== null && usageData.whitelist.classes !== null && !hasOwnProperty$8.call(usageData.whitelist.classes, node.name)) {
	              shouldRemove = true;
	            }

	            if (usageData.blacklist !== null && usageData.blacklist.classes !== null && hasOwnProperty$8.call(usageData.blacklist.classes, node.name)) {
	              shouldRemove = true;
	            }

	            break;

	          case 'IdSelector':
	            if (usageData.whitelist !== null && usageData.whitelist.ids !== null && !hasOwnProperty$8.call(usageData.whitelist.ids, node.name)) {
	              shouldRemove = true;
	            }

	            if (usageData.blacklist !== null && usageData.blacklist.ids !== null && hasOwnProperty$8.call(usageData.blacklist.ids, node.name)) {
	              shouldRemove = true;
	            }

	            break;

	          case 'TypeSelector':
	            // TODO: remove toLowerCase when type selectors will be normalized
	            // ignore universal selectors
	            if (node.name.charAt(node.name.length - 1) !== '*') {
	              if (usageData.whitelist !== null && usageData.whitelist.tags !== null && !hasOwnProperty$8.call(usageData.whitelist.tags, node.name.toLowerCase())) {
	                shouldRemove = true;
	              }

	              if (usageData.blacklist !== null && usageData.blacklist.tags !== null && hasOwnProperty$8.call(usageData.blacklist.tags, node.name.toLowerCase())) {
	                shouldRemove = true;
	              }
	            }

	            break;
	        }
	      }
	    });

	    if (shouldRemove) {
	      list.remove(item);
	    }
	  });
	  return selectorList.children.isEmpty();
	}

	var Rule$1 = function cleanRule(node, item, list, options) {
	  if (hasNoChildren$1(node.prelude) || hasNoChildren$1(node.block)) {
	    list.remove(item);
	    return;
	  }

	  var usageData = options.usage;

	  if (usageData && (usageData.whitelist !== null || usageData.blacklist !== null)) {
	    cleanUnused(node.prelude, usageData);

	    if (hasNoChildren$1(node.prelude)) {
	      list.remove(item);
	      return;
	    }
	  }
	};

	// remove useless universal selector
	var TypeSelector$1 = function cleanTypeSelector(node, item, list) {
	  var name = item.data.name; // check it's a non-namespaced universal selector

	  if (name !== '*') {
	    return;
	  } // remove when universal selector before other selectors


	  var nextType = item.next && item.next.data.type;

	  if (nextType === 'IdSelector' || nextType === 'ClassSelector' || nextType === 'AttributeSelector' || nextType === 'PseudoClassSelector' || nextType === 'PseudoElementSelector') {
	    list.remove(item);
	  }
	};

	var {
	  isNodeChildrenList: isNodeChildrenList$1
	} = utils$1;

	function isSafeOperator(node) {
	  return node.type === 'Operator' && node.value !== '+' && node.value !== '-';
	}

	var WhiteSpace$2 = function cleanWhitespace(node, item, list) {
	  // remove when first or last item in sequence
	  if (item.next === null || item.prev === null) {
	    list.remove(item);
	    return;
	  } // white space in stylesheet or block children


	  if (isNodeChildrenList$1(this.stylesheet, list) || isNodeChildrenList$1(this.block, list)) {
	    list.remove(item);
	    return;
	  }

	  if (item.next.data.type === 'WhiteSpace') {
	    list.remove(item);
	    return;
	  }

	  if (isSafeOperator(item.prev.data) || isSafeOperator(item.next.data)) {
	    list.remove(item);
	    return;
	  }
	};

	var walk$2 = lib.walk;
	var handlers = {
	  Atrule: Atrule$1,
	  Comment: Comment$1,
	  Declaration: Declaration$1,
	  Raw: Raw$1,
	  Rule: Rule$1,
	  TypeSelector: TypeSelector$1,
	  WhiteSpace: WhiteSpace$2
	};

	var clean = function (ast, options) {
	  walk$2(ast, {
	    leave: function (node, item, list) {
	      if (handlers.hasOwnProperty(node.type)) {
	        handlers[node.type].call(this, node, item, list, options);
	      }
	    }
	  });
	};

	var keyframes = function (node) {
	  node.block.children.each(function (rule) {
	    rule.prelude.children.each(function (simpleselector) {
	      simpleselector.children.each(function (data, item) {
	        if (data.type === 'Percentage' && data.value === '100') {
	          item.data = {
	            type: 'TypeSelector',
	            loc: data.loc,
	            name: 'to'
	          };
	        } else if (data.type === 'TypeSelector' && data.name === 'from') {
	          item.data = {
	            type: 'Percentage',
	            loc: data.loc,
	            value: '0'
	          };
	        }
	      });
	    });
	  });
	};

	var resolveKeyword$1 = lib.keyword;

	var Atrule$2 = function (node) {
	  // compress @keyframe selectors
	  if (resolveKeyword$1(node.name).basename === 'keyframes') {
	    keyframes(node);
	  }
	};

	// Can unquote attribute detection
	// Adopted implementation of Mathias Bynens
	// https://github.com/mathiasbynens/mothereff.in/blob/master/unquoted-attributes/eff.js
	var escapesRx = /\\([0-9A-Fa-f]{1,6})(\r\n|[ \t\n\f\r])?|\\./g;
	var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

	function canUnquote(value) {
	  if (value === '' || value === '-') {
	    return;
	  } // Escapes are valid, so replace them with a valid non-empty string


	  value = value.replace(escapesRx, 'a');
	  return !blockUnquoteRx.test(value);
	}

	var AttributeSelector$1 = function (node) {
	  var attrValue = node.value;

	  if (!attrValue || attrValue.type !== 'String') {
	    return;
	  }

	  var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, '$2');

	  if (canUnquote(unquotedValue)) {
	    node.value = {
	      type: 'Identifier',
	      loc: attrValue.loc,
	      name: unquotedValue
	    };
	  }
	};

	var font = function compressFont(node) {
	  var list = node.children;
	  list.eachRight(function (node, item) {
	    if (node.type === 'Identifier') {
	      if (node.name === 'bold') {
	        item.data = {
	          type: 'Number',
	          loc: node.loc,
	          value: '700'
	        };
	      } else if (node.name === 'normal') {
	        var prev = item.prev;

	        if (prev && prev.data.type === 'Operator' && prev.data.value === '/') {
	          this.remove(prev);
	        }

	        this.remove(item);
	      } else if (node.name === 'medium') {
	        var next = item.next;

	        if (!next || next.data.type !== 'Operator') {
	          this.remove(item);
	        }
	      }
	    }
	  }); // remove redundant spaces

	  list.each(function (node, item) {
	    if (node.type === 'WhiteSpace') {
	      if (!item.prev || !item.next || item.next.data.type === 'WhiteSpace') {
	        this.remove(item);
	      }
	    }
	  });

	  if (list.isEmpty()) {
	    list.insert(list.createItem({
	      type: 'Identifier',
	      name: 'normal'
	    }));
	  }
	};

	var fontWeight = function compressFontWeight(node) {
	  var value = node.children.head.data;

	  if (value.type === 'Identifier') {
	    switch (value.name) {
	      case 'normal':
	        node.children.head.data = {
	          type: 'Number',
	          loc: value.loc,
	          value: '400'
	        };
	        break;

	      case 'bold':
	        node.children.head.data = {
	          type: 'Number',
	          loc: value.loc,
	          value: '700'
	        };
	        break;
	    }
	  }
	};

	var List$1 = lib.List;

	var background = function compressBackground(node) {
	  function lastType() {
	    if (buffer.length) {
	      return buffer[buffer.length - 1].type;
	    }
	  }

	  function flush() {
	    if (lastType() === 'WhiteSpace') {
	      buffer.pop();
	    }

	    if (!buffer.length) {
	      buffer.unshift({
	        type: 'Number',
	        loc: null,
	        value: '0'
	      }, {
	        type: 'WhiteSpace',
	        value: ' '
	      }, {
	        type: 'Number',
	        loc: null,
	        value: '0'
	      });
	    }

	    newValue.push.apply(newValue, buffer);
	    buffer = [];
	  }

	  var newValue = [];
	  var buffer = [];
	  node.children.each(function (node) {
	    if (node.type === 'Operator' && node.value === ',') {
	      flush();
	      newValue.push(node);
	      return;
	    } // remove defaults


	    if (node.type === 'Identifier') {
	      if (node.name === 'transparent' || node.name === 'none' || node.name === 'repeat' || node.name === 'scroll') {
	        return;
	      }
	    } // don't add redundant spaces


	    if (node.type === 'WhiteSpace' && (!buffer.length || lastType() === 'WhiteSpace')) {
	      return;
	    }

	    buffer.push(node);
	  });
	  flush();
	  node.children = new List$1().fromArray(newValue);
	};

	function removeItemAndRedundantWhiteSpace(list, item) {
	  var prev = item.prev;
	  var next = item.next;

	  if (next !== null) {
	    if (next.data.type === 'WhiteSpace' && (prev === null || prev.data.type === 'WhiteSpace')) {
	      list.remove(next);
	    }
	  } else if (prev !== null && prev.data.type === 'WhiteSpace') {
	    list.remove(prev);
	  }

	  list.remove(item);
	}

	var border = function compressBorder(node) {
	  node.children.each(function (node, item, list) {
	    if (node.type === 'Identifier' && node.name.toLowerCase() === 'none') {
	      if (list.head === list.tail) {
	        // replace `none` for zero when `none` is a single term
	        item.data = {
	          type: 'Number',
	          loc: node.loc,
	          value: '0'
	        };
	      } else {
	        removeItemAndRedundantWhiteSpace(list, item);
	      }
	    }
	  });
	};

	var resolveName = lib.property;
	var handlers$1 = {
	  'font': font,
	  'font-weight': fontWeight,
	  'background': background,
	  'border': border,
	  'outline': border
	};

	var Value$1 = function compressValue(node) {
	  if (!this.declaration) {
	    return;
	  }

	  var property = resolveName(this.declaration.property);

	  if (handlers$1.hasOwnProperty(property.basename)) {
	    handlers$1[property.basename](node);
	  }
	};

	var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
	var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
	var unsafeToRemovePlusSignAfter = {
	  Dimension: true,
	  HexColor: true,
	  Identifier: true,
	  Number: true,
	  Raw: true,
	  UnicodeRange: true
	};

	function packNumber(value, item) {
	  // omit plus sign only if no prev or prev is safe type
	  var regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.hasOwnProperty(item.prev.data.type) ? KEEP_PLUSSIGN : OMIT_PLUSSIGN; // 100 -> '100'
	  // 00100 -> '100'
	  // +100 -> '100' (only when safe, e.g. omitting plus sign for 1px+1px leads to single dimension instead of two)
	  // -100 -> '-100'
	  // 0.123 -> '.123'
	  // 0.12300 -> '.123'
	  // 0.0 -> ''
	  // 0 -> ''
	  // -0 -> '-'

	  value = String(value).replace(regexp, '$1$2$3');

	  if (value === '' || value === '-') {
	    value = '0';
	  }

	  return value;
	}

	var _Number$1 = function (node, item) {
	  node.value = packNumber(node.value, item);
	};

	var pack = packNumber;
	_Number$1.pack = pack;

	var packNumber$1 = _Number$1.pack;
	var LENGTH_UNIT = {
	  // absolute length units
	  'px': true,
	  'mm': true,
	  'cm': true,
	  'in': true,
	  'pt': true,
	  'pc': true,
	  // relative length units
	  'em': true,
	  'ex': true,
	  'ch': true,
	  'rem': true,
	  // viewport-percentage lengths
	  'vh': true,
	  'vw': true,
	  'vmin': true,
	  'vmax': true,
	  'vm': true
	};

	var Dimension$1 = function compressDimension(node, item) {
	  var value = packNumber$1(node.value, item);
	  node.value = value;

	  if (value === '0' && this.declaration !== null && this.atrulePrelude === null) {
	    var unit = node.unit.toLowerCase(); // only length values can be compressed

	    if (!LENGTH_UNIT.hasOwnProperty(unit)) {
	      return;
	    } // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
	    // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11


	    if (this.declaration.property === '-ms-flex' || this.declaration.property === 'flex') {
	      return;
	    } // issue #222: don't remove units inside calc


	    if (this.function && this.function.name === 'calc') {
	      return;
	    }

	    item.data = {
	      type: 'Number',
	      loc: node.loc,
	      value: value
	    };
	  }
	};

	var lexer$1 = lib.lexer;
	var packNumber$2 = _Number$1.pack;
	var blacklist = new Set([// see https://github.com/jakubpawlowicz/clean-css/issues/957
	'width', 'min-width', 'max-width', 'height', 'min-height', 'max-height', // issue #410: Don’t remove units in flex-basis value for (-ms-)flex shorthand
	// issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
	// issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
	'flex', '-ms-flex']);

	var Percentage$1 = function compressPercentage(node, item) {
	  node.value = packNumber$2(node.value, item);

	  if (node.value === '0' && this.declaration && !blacklist.has(this.declaration.property)) {
	    // try to convert a number
	    item.data = {
	      type: 'Number',
	      loc: node.loc,
	      value: node.value
	    }; // that's ok only when new value matches on length

	    if (!lexer$1.matchDeclaration(this.declaration).isType(item.data, 'length')) {
	      // otherwise rollback changes
	      item.data = node;
	    }
	  }
	};

	var _String$1 = function (node) {
	  var value = node.value; // remove escaped newlines, i.e.
	  // .a { content: "foo\
	  // bar"}
	  // ->
	  // .a { content: "foobar" }

	  value = value.replace(/\\(\r\n|\r|\n|\f)/g, '');
	  node.value = value;
	};

	var UNICODE = '\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?';
	var ESCAPE = '(' + UNICODE + '|\\\\[^\\n\\r\\f0-9a-fA-F])';
	var NONPRINTABLE = '\u0000\u0008\u000b\u000e-\u001f\u007f';
	var SAFE_URL = new RegExp('^(' + ESCAPE + '|[^\"\'\\(\\)\\\\\\s' + NONPRINTABLE + '])*$', 'i');

	var Url$1 = function (node) {
	  var value = node.value;

	  if (value.type !== 'String') {
	    return;
	  }

	  var quote = value.value[0];
	  var url = value.value.substr(1, value.value.length - 2); // convert `\\` to `/`

	  url = url.replace(/\\\\/g, '/'); // remove quotes when safe
	  // https://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram

	  if (SAFE_URL.test(url)) {
	    node.value = {
	      type: 'Raw',
	      loc: node.value.loc,
	      value: url
	    };
	  } else {
	    // use double quotes if string has no double quotes
	    // otherwise use original quotes
	    // TODO: make better quote type selection
	    node.value.value = url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
	  }
	};

	var lexer$2 = lib.lexer;
	var packNumber$3 = _Number$1.pack; // http://www.w3.org/TR/css3-color/#svg-color

	var NAME_TO_HEX = {
	  'aliceblue': 'f0f8ff',
	  'antiquewhite': 'faebd7',
	  'aqua': '0ff',
	  'aquamarine': '7fffd4',
	  'azure': 'f0ffff',
	  'beige': 'f5f5dc',
	  'bisque': 'ffe4c4',
	  'black': '000',
	  'blanchedalmond': 'ffebcd',
	  'blue': '00f',
	  'blueviolet': '8a2be2',
	  'brown': 'a52a2a',
	  'burlywood': 'deb887',
	  'cadetblue': '5f9ea0',
	  'chartreuse': '7fff00',
	  'chocolate': 'd2691e',
	  'coral': 'ff7f50',
	  'cornflowerblue': '6495ed',
	  'cornsilk': 'fff8dc',
	  'crimson': 'dc143c',
	  'cyan': '0ff',
	  'darkblue': '00008b',
	  'darkcyan': '008b8b',
	  'darkgoldenrod': 'b8860b',
	  'darkgray': 'a9a9a9',
	  'darkgrey': 'a9a9a9',
	  'darkgreen': '006400',
	  'darkkhaki': 'bdb76b',
	  'darkmagenta': '8b008b',
	  'darkolivegreen': '556b2f',
	  'darkorange': 'ff8c00',
	  'darkorchid': '9932cc',
	  'darkred': '8b0000',
	  'darksalmon': 'e9967a',
	  'darkseagreen': '8fbc8f',
	  'darkslateblue': '483d8b',
	  'darkslategray': '2f4f4f',
	  'darkslategrey': '2f4f4f',
	  'darkturquoise': '00ced1',
	  'darkviolet': '9400d3',
	  'deeppink': 'ff1493',
	  'deepskyblue': '00bfff',
	  'dimgray': '696969',
	  'dimgrey': '696969',
	  'dodgerblue': '1e90ff',
	  'firebrick': 'b22222',
	  'floralwhite': 'fffaf0',
	  'forestgreen': '228b22',
	  'fuchsia': 'f0f',
	  'gainsboro': 'dcdcdc',
	  'ghostwhite': 'f8f8ff',
	  'gold': 'ffd700',
	  'goldenrod': 'daa520',
	  'gray': '808080',
	  'grey': '808080',
	  'green': '008000',
	  'greenyellow': 'adff2f',
	  'honeydew': 'f0fff0',
	  'hotpink': 'ff69b4',
	  'indianred': 'cd5c5c',
	  'indigo': '4b0082',
	  'ivory': 'fffff0',
	  'khaki': 'f0e68c',
	  'lavender': 'e6e6fa',
	  'lavenderblush': 'fff0f5',
	  'lawngreen': '7cfc00',
	  'lemonchiffon': 'fffacd',
	  'lightblue': 'add8e6',
	  'lightcoral': 'f08080',
	  'lightcyan': 'e0ffff',
	  'lightgoldenrodyellow': 'fafad2',
	  'lightgray': 'd3d3d3',
	  'lightgrey': 'd3d3d3',
	  'lightgreen': '90ee90',
	  'lightpink': 'ffb6c1',
	  'lightsalmon': 'ffa07a',
	  'lightseagreen': '20b2aa',
	  'lightskyblue': '87cefa',
	  'lightslategray': '789',
	  'lightslategrey': '789',
	  'lightsteelblue': 'b0c4de',
	  'lightyellow': 'ffffe0',
	  'lime': '0f0',
	  'limegreen': '32cd32',
	  'linen': 'faf0e6',
	  'magenta': 'f0f',
	  'maroon': '800000',
	  'mediumaquamarine': '66cdaa',
	  'mediumblue': '0000cd',
	  'mediumorchid': 'ba55d3',
	  'mediumpurple': '9370db',
	  'mediumseagreen': '3cb371',
	  'mediumslateblue': '7b68ee',
	  'mediumspringgreen': '00fa9a',
	  'mediumturquoise': '48d1cc',
	  'mediumvioletred': 'c71585',
	  'midnightblue': '191970',
	  'mintcream': 'f5fffa',
	  'mistyrose': 'ffe4e1',
	  'moccasin': 'ffe4b5',
	  'navajowhite': 'ffdead',
	  'navy': '000080',
	  'oldlace': 'fdf5e6',
	  'olive': '808000',
	  'olivedrab': '6b8e23',
	  'orange': 'ffa500',
	  'orangered': 'ff4500',
	  'orchid': 'da70d6',
	  'palegoldenrod': 'eee8aa',
	  'palegreen': '98fb98',
	  'paleturquoise': 'afeeee',
	  'palevioletred': 'db7093',
	  'papayawhip': 'ffefd5',
	  'peachpuff': 'ffdab9',
	  'peru': 'cd853f',
	  'pink': 'ffc0cb',
	  'plum': 'dda0dd',
	  'powderblue': 'b0e0e6',
	  'purple': '800080',
	  'rebeccapurple': '639',
	  'red': 'f00',
	  'rosybrown': 'bc8f8f',
	  'royalblue': '4169e1',
	  'saddlebrown': '8b4513',
	  'salmon': 'fa8072',
	  'sandybrown': 'f4a460',
	  'seagreen': '2e8b57',
	  'seashell': 'fff5ee',
	  'sienna': 'a0522d',
	  'silver': 'c0c0c0',
	  'skyblue': '87ceeb',
	  'slateblue': '6a5acd',
	  'slategray': '708090',
	  'slategrey': '708090',
	  'snow': 'fffafa',
	  'springgreen': '00ff7f',
	  'steelblue': '4682b4',
	  'tan': 'd2b48c',
	  'teal': '008080',
	  'thistle': 'd8bfd8',
	  'tomato': 'ff6347',
	  'turquoise': '40e0d0',
	  'violet': 'ee82ee',
	  'wheat': 'f5deb3',
	  'white': 'fff',
	  'whitesmoke': 'f5f5f5',
	  'yellow': 'ff0',
	  'yellowgreen': '9acd32'
	};
	var HEX_TO_NAME = {
	  '800000': 'maroon',
	  '800080': 'purple',
	  '808000': 'olive',
	  '808080': 'gray',
	  '00ffff': 'cyan',
	  'f0ffff': 'azure',
	  'f5f5dc': 'beige',
	  'ffe4c4': 'bisque',
	  '000000': 'black',
	  '0000ff': 'blue',
	  'a52a2a': 'brown',
	  'ff7f50': 'coral',
	  'ffd700': 'gold',
	  '008000': 'green',
	  '4b0082': 'indigo',
	  'fffff0': 'ivory',
	  'f0e68c': 'khaki',
	  '00ff00': 'lime',
	  'faf0e6': 'linen',
	  '000080': 'navy',
	  'ffa500': 'orange',
	  'da70d6': 'orchid',
	  'cd853f': 'peru',
	  'ffc0cb': 'pink',
	  'dda0dd': 'plum',
	  'f00': 'red',
	  'ff0000': 'red',
	  'fa8072': 'salmon',
	  'a0522d': 'sienna',
	  'c0c0c0': 'silver',
	  'fffafa': 'snow',
	  'd2b48c': 'tan',
	  '008080': 'teal',
	  'ff6347': 'tomato',
	  'ee82ee': 'violet',
	  'f5deb3': 'wheat',
	  'ffffff': 'white',
	  'ffff00': 'yellow'
	};

	function hueToRgb(p, q, t) {
	  if (t < 0) {
	    t += 1;
	  }

	  if (t > 1) {
	    t -= 1;
	  }

	  if (t < 1 / 6) {
	    return p + (q - p) * 6 * t;
	  }

	  if (t < 1 / 2) {
	    return q;
	  }

	  if (t < 2 / 3) {
	    return p + (q - p) * (2 / 3 - t) * 6;
	  }

	  return p;
	}

	function hslToRgb(h, s, l, a) {
	  var r;
	  var g;
	  var b;

	  if (s === 0) {
	    r = g = b = l; // achromatic
	  } else {
	    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	    var p = 2 * l - q;
	    r = hueToRgb(p, q, h + 1 / 3);
	    g = hueToRgb(p, q, h);
	    b = hueToRgb(p, q, h - 1 / 3);
	  }

	  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a];
	}

	function toHex(value) {
	  value = value.toString(16);
	  return value.length === 1 ? '0' + value : value;
	}

	function parseFunctionArgs(functionArgs, count, rgb) {
	  var cursor = functionArgs.head;
	  var args = [];
	  var wasValue = false;

	  while (cursor !== null) {
	    var node = cursor.data;
	    var type = node.type;

	    switch (type) {
	      case 'Number':
	      case 'Percentage':
	        if (wasValue) {
	          return;
	        }

	        wasValue = true;
	        args.push({
	          type: type,
	          value: Number(node.value)
	        });
	        break;

	      case 'Operator':
	        if (node.value === ',') {
	          if (!wasValue) {
	            return;
	          }

	          wasValue = false;
	        } else if (wasValue || node.value !== '+') {
	          return;
	        }

	        break;

	      default:
	        // something we couldn't understand
	        return;
	    }

	    cursor = cursor.next;
	  }

	  if (args.length !== count) {
	    // invalid arguments count
	    // TODO: remove those tokens
	    return;
	  }

	  if (args.length === 4) {
	    if (args[3].type !== 'Number') {
	      // 4th argument should be a number
	      // TODO: remove those tokens
	      return;
	    }

	    args[3].type = 'Alpha';
	  }

	  if (rgb) {
	    if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
	      // invalid color, numbers and percentage shouldn't be mixed
	      // TODO: remove those tokens
	      return;
	    }
	  } else {
	    if (args[0].type !== 'Number' || args[1].type !== 'Percentage' || args[2].type !== 'Percentage') {
	      // invalid color, for hsl values should be: number, percentage, percentage
	      // TODO: remove those tokens
	      return;
	    }

	    args[0].type = 'Angle';
	  }

	  return args.map(function (arg) {
	    var value = Math.max(0, arg.value);

	    switch (arg.type) {
	      case 'Number':
	        // fit value to [0..255] range
	        value = Math.min(value, 255);
	        break;

	      case 'Percentage':
	        // convert 0..100% to value in [0..255] range
	        value = Math.min(value, 100) / 100;

	        if (!rgb) {
	          return value;
	        }

	        value = 255 * value;
	        break;

	      case 'Angle':
	        // fit value to (-360..360) range
	        return (value % 360 + 360) % 360 / 360;

	      case 'Alpha':
	        // fit value to [0..1] range
	        return Math.min(value, 1);
	    }

	    return Math.round(value);
	  });
	}

	function compressFunction(node, item, list) {
	  var functionName = node.name;
	  var args;

	  if (functionName === 'rgba' || functionName === 'hsla') {
	    args = parseFunctionArgs(node.children, 4, functionName === 'rgba');

	    if (!args) {
	      // something went wrong
	      return;
	    }

	    if (functionName === 'hsla') {
	      args = hslToRgb.apply(null, args);
	      node.name = 'rgba';
	    }

	    if (args[3] === 0) {
	      // try to replace `rgba(x, x, x, 0)` to `transparent`
	      // always replace `rgba(0, 0, 0, 0)` to `transparent`
	      // otherwise avoid replacement in gradients since it may break color transition
	      // http://stackoverflow.com/questions/11829410/css3-gradient-rendering-issues-from-transparent-to-white
	      var scopeFunctionName = this.function && this.function.name;

	      if (args[0] === 0 && args[1] === 0 && args[2] === 0 || !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {
	        item.data = {
	          type: 'Identifier',
	          loc: node.loc,
	          name: 'transparent'
	        };
	        return;
	      }
	    }

	    if (args[3] !== 1) {
	      // replace argument values for normalized/interpolated
	      node.children.each(function (node, item, list) {
	        if (node.type === 'Operator') {
	          if (node.value !== ',') {
	            list.remove(item);
	          }

	          return;
	        }

	        item.data = {
	          type: 'Number',
	          loc: node.loc,
	          value: packNumber$3(args.shift(), null)
	        };
	      });
	      return;
	    } // otherwise convert to rgb, i.e. rgba(255, 0, 0, 1) -> rgb(255, 0, 0)


	    functionName = 'rgb';
	  }

	  if (functionName === 'hsl') {
	    args = args || parseFunctionArgs(node.children, 3, false);

	    if (!args) {
	      // something went wrong
	      return;
	    } // convert to rgb


	    args = hslToRgb.apply(null, args);
	    functionName = 'rgb';
	  }

	  if (functionName === 'rgb') {
	    args = args || parseFunctionArgs(node.children, 3, true);

	    if (!args) {
	      // something went wrong
	      return;
	    } // check if color is not at the end and not followed by space


	    var next = item.next;

	    if (next && next.data.type !== 'WhiteSpace') {
	      list.insert(list.createItem({
	        type: 'WhiteSpace',
	        value: ' '
	      }), next);
	    }

	    item.data = {
	      type: 'HexColor',
	      loc: node.loc,
	      value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
	    };
	    compressHex(item.data, item);
	  }
	}

	function compressIdent(node, item) {
	  if (this.declaration === null) {
	    return;
	  }

	  var color = node.name.toLowerCase();

	  if (NAME_TO_HEX.hasOwnProperty(color) && lexer$2.matchDeclaration(this.declaration).isType(node, 'color')) {
	    var hex = NAME_TO_HEX[color];

	    if (hex.length + 1 <= color.length) {
	      // replace for shorter hex value
	      item.data = {
	        type: 'HexColor',
	        loc: node.loc,
	        value: hex
	      };
	    } else {
	      // special case for consistent colors
	      if (color === 'grey') {
	        color = 'gray';
	      } // just replace value for lower cased name


	      node.name = color;
	    }
	  }
	}

	function compressHex(node, item) {
	  var color = node.value.toLowerCase(); // #112233 -> #123

	  if (color.length === 6 && color[0] === color[1] && color[2] === color[3] && color[4] === color[5]) {
	    color = color[0] + color[2] + color[4];
	  }

	  if (HEX_TO_NAME[color]) {
	    item.data = {
	      type: 'Identifier',
	      loc: node.loc,
	      name: HEX_TO_NAME[color]
	    };
	  } else {
	    node.value = color;
	  }
	}

	var color = {
	  compressFunction: compressFunction,
	  compressIdent: compressIdent,
	  compressHex: compressHex
	};

	var walk$3 = lib.walk;
	var handlers$2 = {
	  Atrule: Atrule$2,
	  AttributeSelector: AttributeSelector$1,
	  Value: Value$1,
	  Dimension: Dimension$1,
	  Percentage: Percentage$1,
	  Number: _Number$1,
	  String: _String$1,
	  Url: Url$1,
	  HexColor: color.compressHex,
	  Identifier: color.compressIdent,
	  Function: color.compressFunction
	};

	var replace = function (ast) {
	  walk$3(ast, {
	    leave: function (node, item, list) {
	      if (handlers$2.hasOwnProperty(node.type)) {
	        handlers$2[node.type].call(this, node, item, list);
	      }
	    }
	  });
	};

	var generate$1 = lib.generate;

	function Index() {
	  this.seed = 0;
	  this.map = Object.create(null);
	}

	Index.prototype.resolve = function (str) {
	  var index = this.map[str];

	  if (!index) {
	    index = ++this.seed;
	    this.map[str] = index;
	  }

	  return index;
	};

	var createDeclarationIndexer = function createDeclarationIndexer() {
	  var ids = new Index();
	  return function markDeclaration(node) {
	    var id = generate$1(node);
	    node.id = ids.resolve(id);
	    node.length = id.length;
	    node.fingerprint = null;
	    return node;
	  };
	};

	var specificity = function specificity(simpleSelector) {
	  var A = 0;
	  var B = 0;
	  var C = 0;
	  simpleSelector.children.each(function walk(node) {
	    switch (node.type) {
	      case 'SelectorList':
	      case 'Selector':
	        node.children.each(walk);
	        break;

	      case 'IdSelector':
	        A++;
	        break;

	      case 'ClassSelector':
	      case 'AttributeSelector':
	        B++;
	        break;

	      case 'PseudoClassSelector':
	        switch (node.name.toLowerCase()) {
	          case 'not':
	            node.children.each(walk);
	            break;

	          case 'before':
	          case 'after':
	          case 'first-line':
	          case 'first-letter':
	            C++;
	            break;
	          // TODO: support for :nth-*(.. of <SelectorList>), :matches(), :has()

	          default:
	            B++;
	        }

	        break;

	      case 'PseudoElementSelector':
	        C++;
	        break;

	      case 'TypeSelector':
	        // ignore universal selector
	        if (node.name.charAt(node.name.length - 1) !== '*') {
	          C++;
	        }

	        break;
	    }
	  });
	  return [A, B, C];
	};

	var generate$2 = lib.generate;
	var nonFreezePseudoElements = {
	  'first-letter': true,
	  'first-line': true,
	  'after': true,
	  'before': true
	};
	var nonFreezePseudoClasses = {
	  'link': true,
	  'visited': true,
	  'hover': true,
	  'active': true,
	  'first-letter': true,
	  'first-line': true,
	  'after': true,
	  'before': true
	};

	var processSelector = function freeze(node, usageData) {
	  var pseudos = Object.create(null);
	  var hasPseudo = false;
	  node.prelude.children.each(function (simpleSelector) {
	    var tagName = '*';
	    var scope = 0;
	    simpleSelector.children.each(function (node) {
	      switch (node.type) {
	        case 'ClassSelector':
	          if (usageData && usageData.scopes) {
	            var classScope = usageData.scopes[node.name] || 0;

	            if (scope !== 0 && classScope !== scope) {
	              throw new Error('Selector can\'t has classes from different scopes: ' + generate$2(simpleSelector));
	            }

	            scope = classScope;
	          }

	          break;

	        case 'PseudoClassSelector':
	          var name = node.name.toLowerCase();

	          if (!nonFreezePseudoClasses.hasOwnProperty(name)) {
	            pseudos[name] = true;
	            hasPseudo = true;
	          }

	          break;

	        case 'PseudoElementSelector':
	          var name = node.name.toLowerCase();

	          if (!nonFreezePseudoElements.hasOwnProperty(name)) {
	            pseudos[name] = true;
	            hasPseudo = true;
	          }

	          break;

	        case 'TypeSelector':
	          tagName = node.name.toLowerCase();
	          break;

	        case 'AttributeSelector':
	          if (node.flags) {
	            pseudos['[' + node.flags.toLowerCase() + ']'] = true;
	            hasPseudo = true;
	          }

	          break;

	        case 'WhiteSpace':
	        case 'Combinator':
	          tagName = '*';
	          break;
	      }
	    });
	    simpleSelector.compareMarker = specificity(simpleSelector).toString();
	    simpleSelector.id = null; // pre-init property to avoid multiple hidden class

	    simpleSelector.id = generate$2(simpleSelector);

	    if (scope) {
	      simpleSelector.compareMarker += ':' + scope;
	    }

	    if (tagName !== '*') {
	      simpleSelector.compareMarker += ',' + tagName;
	    }
	  }); // add property to all rule nodes to avoid multiple hidden class

	  node.pseudoSignature = hasPseudo && Object.keys(pseudos).sort().join(',');
	};

	var resolveKeyword$2 = lib.keyword;
	var walk$4 = lib.walk;
	var generate$3 = lib.generate;

	var prepare = function prepare(ast, options) {
	  var markDeclaration = createDeclarationIndexer();
	  walk$4(ast, {
	    visit: 'Rule',
	    enter: function processRule(node) {
	      node.block.children.each(markDeclaration);
	      processSelector(node, options.usage);
	    }
	  });
	  walk$4(ast, {
	    visit: 'Atrule',
	    enter: function (node) {
	      if (node.prelude) {
	        node.prelude.id = null; // pre-init property to avoid multiple hidden class for generate

	        node.prelude.id = generate$3(node.prelude);
	      } // compare keyframe selectors by its values
	      // NOTE: still no clarification about problems with keyframes selector grouping (issue #197)


	      if (resolveKeyword$2(node.name).basename === 'keyframes') {
	        node.block.avoidRulesMerge = true;
	        /* probably we don't need to prevent those merges for @keyframes
	           TODO: need to be checked */

	        node.block.children.each(function (rule) {
	          rule.prelude.children.each(function (simpleselector) {
	            simpleselector.compareMarker = simpleselector.id;
	          });
	        });
	      }
	    }
	  });
	  return {
	    declaration: markDeclaration
	  };
	};

	var List$2 = lib.List;
	var resolveKeyword$3 = lib.keyword;
	var hasOwnProperty$9 = Object.prototype.hasOwnProperty;
	var walk$5 = lib.walk;

	function addRuleToMap(map, item, list, single) {
	  var node = item.data;
	  var name = resolveKeyword$3(node.name).basename;
	  var id = node.name.toLowerCase() + '/' + (node.prelude ? node.prelude.id : null);

	  if (!hasOwnProperty$9.call(map, name)) {
	    map[name] = Object.create(null);
	  }

	  if (single) {
	    delete map[name][id];
	  }

	  if (!hasOwnProperty$9.call(map[name], id)) {
	    map[name][id] = new List$2();
	  }

	  map[name][id].append(list.remove(item));
	}

	function relocateAtrules(ast, options) {
	  var collected = Object.create(null);
	  var topInjectPoint = null;
	  ast.children.each(function (node, item, list) {
	    if (node.type === 'Atrule') {
	      var name = resolveKeyword$3(node.name).basename;

	      switch (name) {
	        case 'keyframes':
	          addRuleToMap(collected, item, list, true);
	          return;

	        case 'media':
	          if (options.forceMediaMerge) {
	            addRuleToMap(collected, item, list, false);
	            return;
	          }

	          break;
	      }

	      if (topInjectPoint === null && name !== 'charset' && name !== 'import') {
	        topInjectPoint = item;
	      }
	    } else {
	      if (topInjectPoint === null) {
	        topInjectPoint = item;
	      }
	    }
	  });

	  for (var atrule in collected) {
	    for (var id in collected[atrule]) {
	      ast.children.insertList(collected[atrule][id], atrule === 'media' ? null : topInjectPoint);
	    }
	  }
	}

	function isMediaRule(node) {
	  return node.type === 'Atrule' && node.name === 'media';
	}

	function processAtrule(node, item, list) {
	  if (!isMediaRule(node)) {
	    return;
	  }

	  var prev = item.prev && item.prev.data;

	  if (!prev || !isMediaRule(prev)) {
	    return;
	  } // merge @media with same query


	  if (node.prelude && prev.prelude && node.prelude.id === prev.prelude.id) {
	    prev.block.children.appendList(node.block.children);
	    list.remove(item); // TODO: use it when we can refer to several points in source
	    // prev.loc = {
	    //     primary: prev.loc,
	    //     merged: node.loc
	    // };
	  }
	}

	var _1MergeAtrule = function rejoinAtrule(ast, options) {
	  relocateAtrules(ast, options);
	  walk$5(ast, {
	    visit: 'Atrule',
	    reverse: true,
	    enter: processAtrule
	  });
	};

	var hasOwnProperty$a = Object.prototype.hasOwnProperty;

	function isEqualSelectors(a, b) {
	  var cursor1 = a.head;
	  var cursor2 = b.head;

	  while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
	    cursor1 = cursor1.next;
	    cursor2 = cursor2.next;
	  }

	  return cursor1 === null && cursor2 === null;
	}

	function isEqualDeclarations(a, b) {
	  var cursor1 = a.head;
	  var cursor2 = b.head;

	  while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
	    cursor1 = cursor1.next;
	    cursor2 = cursor2.next;
	  }

	  return cursor1 === null && cursor2 === null;
	}

	function compareDeclarations(declarations1, declarations2) {
	  var result = {
	    eq: [],
	    ne1: [],
	    ne2: [],
	    ne2overrided: []
	  };
	  var fingerprints = Object.create(null);
	  var declarations2hash = Object.create(null);

	  for (var cursor = declarations2.head; cursor; cursor = cursor.next) {
	    declarations2hash[cursor.data.id] = true;
	  }

	  for (var cursor = declarations1.head; cursor; cursor = cursor.next) {
	    var data = cursor.data;

	    if (data.fingerprint) {
	      fingerprints[data.fingerprint] = data.important;
	    }

	    if (declarations2hash[data.id]) {
	      declarations2hash[data.id] = false;
	      result.eq.push(data);
	    } else {
	      result.ne1.push(data);
	    }
	  }

	  for (var cursor = declarations2.head; cursor; cursor = cursor.next) {
	    var data = cursor.data;

	    if (declarations2hash[data.id]) {
	      // when declarations1 has an overriding declaration, this is not a difference
	      // unless no !important is used on prev and !important is used on the following
	      if (!hasOwnProperty$a.call(fingerprints, data.fingerprint) || !fingerprints[data.fingerprint] && data.important) {
	        result.ne2.push(data);
	      }

	      result.ne2overrided.push(data);
	    }
	  }

	  return result;
	}

	function addSelectors(dest, source) {
	  source.each(function (sourceData) {
	    var newStr = sourceData.id;
	    var cursor = dest.head;

	    while (cursor) {
	      var nextStr = cursor.data.id;

	      if (nextStr === newStr) {
	        return;
	      }

	      if (nextStr > newStr) {
	        break;
	      }

	      cursor = cursor.next;
	    }

	    dest.insert(dest.createItem(sourceData), cursor);
	  });
	  return dest;
	} // check if simpleselectors has no equal specificity and element selector


	function hasSimilarSelectors(selectors1, selectors2) {
	  var cursor1 = selectors1.head;

	  while (cursor1 !== null) {
	    var cursor2 = selectors2.head;

	    while (cursor2 !== null) {
	      if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
	        return true;
	      }

	      cursor2 = cursor2.next;
	    }

	    cursor1 = cursor1.next;
	  }

	  return false;
	} // test node can't to be skipped


	function unsafeToSkipNode(node) {
	  switch (node.type) {
	    case 'Rule':
	      // unsafe skip ruleset with selector similarities
	      return hasSimilarSelectors(node.prelude.children, this);

	    case 'Atrule':
	      // can skip at-rules with blocks
	      if (node.block) {
	        // unsafe skip at-rule if block contains something unsafe to skip
	        return node.block.children.some(unsafeToSkipNode, this);
	      }

	      break;

	    case 'Declaration':
	      return false;
	  } // unsafe by default


	  return true;
	}

	var utils$2 = {
	  isEqualSelectors: isEqualSelectors,
	  isEqualDeclarations: isEqualDeclarations,
	  compareDeclarations: compareDeclarations,
	  addSelectors: addSelectors,
	  hasSimilarSelectors: hasSimilarSelectors,
	  unsafeToSkipNode: unsafeToSkipNode
	};

	var walk$6 = lib.walk;

	function processRule(node, item, list) {
	  var selectors = node.prelude.children;
	  var declarations = node.block.children;
	  list.prevUntil(item.prev, function (prev) {
	    // skip non-ruleset node if safe
	    if (prev.type !== 'Rule') {
	      return utils$2.unsafeToSkipNode.call(selectors, prev);
	    }

	    var prevSelectors = prev.prelude.children;
	    var prevDeclarations = prev.block.children; // try to join rulesets with equal pseudo signature

	    if (node.pseudoSignature === prev.pseudoSignature) {
	      // try to join by selectors
	      if (utils$2.isEqualSelectors(prevSelectors, selectors)) {
	        prevDeclarations.appendList(declarations);
	        list.remove(item);
	        return true;
	      } // try to join by declarations


	      if (utils$2.isEqualDeclarations(declarations, prevDeclarations)) {
	        utils$2.addSelectors(prevSelectors, selectors);
	        list.remove(item);
	        return true;
	      }
	    } // go to prev ruleset if has no selector similarities


	    return utils$2.hasSimilarSelectors(selectors, prevSelectors);
	  });
	} // NOTE: direction should be left to right, since rulesets merge to left
	// ruleset. When direction right to left unmerged rulesets may prevent lookup
	// TODO: remove initial merge


	var _2InitialMergeRuleset = function initialMergeRule(ast) {
	  walk$6(ast, {
	    visit: 'Rule',
	    enter: processRule
	  });
	};

	var List$3 = lib.List;
	var walk$7 = lib.walk;

	function processRule$1(node, item, list) {
	  var selectors = node.prelude.children; // generate new rule sets:
	  // .a, .b { color: red; }
	  // ->
	  // .a { color: red; }
	  // .b { color: red; }
	  // while there are more than 1 simple selector split for rulesets

	  while (selectors.head !== selectors.tail) {
	    var newSelectors = new List$3();
	    newSelectors.insert(selectors.remove(selectors.head));
	    list.insert(list.createItem({
	      type: 'Rule',
	      loc: node.loc,
	      prelude: {
	        type: 'SelectorList',
	        loc: node.prelude.loc,
	        children: newSelectors
	      },
	      block: {
	        type: 'Block',
	        loc: node.block.loc,
	        children: node.block.children.copy()
	      },
	      pseudoSignature: node.pseudoSignature
	    }), item);
	  }
	}

	var _3DisjoinRuleset = function disjoinRule(ast) {
	  walk$7(ast, {
	    visit: 'Rule',
	    reverse: true,
	    enter: processRule$1
	  });
	};

	var List$4 = lib.List;
	var generate$4 = lib.generate;
	var walk$8 = lib.walk;
	var REPLACE = 1;
	var REMOVE = 2;
	var TOP = 0;
	var RIGHT = 1;
	var BOTTOM = 2;
	var LEFT = 3;
	var SIDES = ['top', 'right', 'bottom', 'left'];
	var SIDE = {
	  'margin-top': 'top',
	  'margin-right': 'right',
	  'margin-bottom': 'bottom',
	  'margin-left': 'left',
	  'padding-top': 'top',
	  'padding-right': 'right',
	  'padding-bottom': 'bottom',
	  'padding-left': 'left',
	  'border-top-color': 'top',
	  'border-right-color': 'right',
	  'border-bottom-color': 'bottom',
	  'border-left-color': 'left',
	  'border-top-width': 'top',
	  'border-right-width': 'right',
	  'border-bottom-width': 'bottom',
	  'border-left-width': 'left',
	  'border-top-style': 'top',
	  'border-right-style': 'right',
	  'border-bottom-style': 'bottom',
	  'border-left-style': 'left'
	};
	var MAIN_PROPERTY = {
	  'margin': 'margin',
	  'margin-top': 'margin',
	  'margin-right': 'margin',
	  'margin-bottom': 'margin',
	  'margin-left': 'margin',
	  'padding': 'padding',
	  'padding-top': 'padding',
	  'padding-right': 'padding',
	  'padding-bottom': 'padding',
	  'padding-left': 'padding',
	  'border-color': 'border-color',
	  'border-top-color': 'border-color',
	  'border-right-color': 'border-color',
	  'border-bottom-color': 'border-color',
	  'border-left-color': 'border-color',
	  'border-width': 'border-width',
	  'border-top-width': 'border-width',
	  'border-right-width': 'border-width',
	  'border-bottom-width': 'border-width',
	  'border-left-width': 'border-width',
	  'border-style': 'border-style',
	  'border-top-style': 'border-style',
	  'border-right-style': 'border-style',
	  'border-bottom-style': 'border-style',
	  'border-left-style': 'border-style'
	};

	function TRBL(name) {
	  this.name = name;
	  this.loc = null;
	  this.iehack = undefined;
	  this.sides = {
	    'top': null,
	    'right': null,
	    'bottom': null,
	    'left': null
	  };
	}

	TRBL.prototype.getValueSequence = function (declaration, count) {
	  var values = [];
	  var iehack = '';
	  var hasBadValues = declaration.value.children.some(function (child) {
	    var special = false;

	    switch (child.type) {
	      case 'Identifier':
	        switch (child.name) {
	          case '\\0':
	          case '\\9':
	            iehack = child.name;
	            return;

	          case 'inherit':
	          case 'initial':
	          case 'unset':
	          case 'revert':
	            special = child.name;
	            break;
	        }

	        break;

	      case 'Dimension':
	        switch (child.unit) {
	          // is not supported until IE11
	          case 'rem': // v* units is too buggy across browsers and better
	          // don't merge values with those units

	          case 'vw':
	          case 'vh':
	          case 'vmin':
	          case 'vmax':
	          case 'vm':
	            // IE9 supporting "vm" instead of "vmin".
	            special = child.unit;
	            break;
	        }

	        break;

	      case 'HexColor': // color

	      case 'Number':
	      case 'Percentage':
	        break;

	      case 'Function':
	        special = child.name;
	        break;

	      case 'WhiteSpace':
	        return false;
	      // ignore space

	      default:
	        return true;
	      // bad value
	    }

	    values.push({
	      node: child,
	      special: special,
	      important: declaration.important
	    });
	  });

	  if (hasBadValues || values.length > count) {
	    return false;
	  }

	  if (typeof this.iehack === 'string' && this.iehack !== iehack) {
	    return false;
	  }

	  this.iehack = iehack; // move outside

	  return values;
	};

	TRBL.prototype.canOverride = function (side, value) {
	  var currentValue = this.sides[side];
	  return !currentValue || value.important && !currentValue.important;
	};

	TRBL.prototype.add = function (name, declaration) {
	  function attemptToAdd() {
	    var sides = this.sides;
	    var side = SIDE[name];

	    if (side) {
	      if (side in sides === false) {
	        return false;
	      }

	      var values = this.getValueSequence(declaration, 1);

	      if (!values || !values.length) {
	        return false;
	      } // can mix only if specials are equal


	      for (var key in sides) {
	        if (sides[key] !== null && sides[key].special !== values[0].special) {
	          return false;
	        }
	      }

	      if (!this.canOverride(side, values[0])) {
	        return true;
	      }

	      sides[side] = values[0];
	      return true;
	    } else if (name === this.name) {
	      var values = this.getValueSequence(declaration, 4);

	      if (!values || !values.length) {
	        return false;
	      }

	      switch (values.length) {
	        case 1:
	          values[RIGHT] = values[TOP];
	          values[BOTTOM] = values[TOP];
	          values[LEFT] = values[TOP];
	          break;

	        case 2:
	          values[BOTTOM] = values[TOP];
	          values[LEFT] = values[RIGHT];
	          break;

	        case 3:
	          values[LEFT] = values[RIGHT];
	          break;
	      } // can mix only if specials are equal


	      for (var i = 0; i < 4; i++) {
	        for (var key in sides) {
	          if (sides[key] !== null && sides[key].special !== values[i].special) {
	            return false;
	          }
	        }
	      }

	      for (var i = 0; i < 4; i++) {
	        if (this.canOverride(SIDES[i], values[i])) {
	          sides[SIDES[i]] = values[i];
	        }
	      }

	      return true;
	    }
	  }

	  if (!attemptToAdd.call(this)) {
	    return false;
	  } // TODO: use it when we can refer to several points in source
	  // if (this.loc) {
	  //     this.loc = {
	  //         primary: this.loc,
	  //         merged: declaration.loc
	  //     };
	  // } else {
	  //     this.loc = declaration.loc;
	  // }


	  if (!this.loc) {
	    this.loc = declaration.loc;
	  }

	  return true;
	};

	TRBL.prototype.isOkToMinimize = function () {
	  var top = this.sides.top;
	  var right = this.sides.right;
	  var bottom = this.sides.bottom;
	  var left = this.sides.left;

	  if (top && right && bottom && left) {
	    var important = top.important + right.important + bottom.important + left.important;
	    return important === 0 || important === 4;
	  }

	  return false;
	};

	TRBL.prototype.getValue = function () {
	  var result = new List$4();
	  var sides = this.sides;
	  var values = [sides.top, sides.right, sides.bottom, sides.left];
	  var stringValues = [generate$4(sides.top.node), generate$4(sides.right.node), generate$4(sides.bottom.node), generate$4(sides.left.node)];

	  if (stringValues[LEFT] === stringValues[RIGHT]) {
	    values.pop();

	    if (stringValues[BOTTOM] === stringValues[TOP]) {
	      values.pop();

	      if (stringValues[RIGHT] === stringValues[TOP]) {
	        values.pop();
	      }
	    }
	  }

	  for (var i = 0; i < values.length; i++) {
	    if (i) {
	      result.appendData({
	        type: 'WhiteSpace',
	        value: ' '
	      });
	    }

	    result.appendData(values[i].node);
	  }

	  if (this.iehack) {
	    result.appendData({
	      type: 'WhiteSpace',
	      value: ' '
	    });
	    result.appendData({
	      type: 'Identifier',
	      loc: null,
	      name: this.iehack
	    });
	  }

	  return {
	    type: 'Value',
	    loc: null,
	    children: result
	  };
	};

	TRBL.prototype.getDeclaration = function () {
	  return {
	    type: 'Declaration',
	    loc: this.loc,
	    important: this.sides.top.important,
	    property: this.name,
	    value: this.getValue()
	  };
	};

	function processRule$2(rule, shorts, shortDeclarations, lastShortSelector) {
	  var declarations = rule.block.children;
	  var selector = rule.prelude.children.first().id;
	  rule.block.children.eachRight(function (declaration, item) {
	    var property = declaration.property;

	    if (!MAIN_PROPERTY.hasOwnProperty(property)) {
	      return;
	    }

	    var key = MAIN_PROPERTY[property];
	    var shorthand;
	    var operation;

	    if (!lastShortSelector || selector === lastShortSelector) {
	      if (key in shorts) {
	        operation = REMOVE;
	        shorthand = shorts[key];
	      }
	    }

	    if (!shorthand || !shorthand.add(property, declaration)) {
	      operation = REPLACE;
	      shorthand = new TRBL(key); // if can't parse value ignore it and break shorthand children

	      if (!shorthand.add(property, declaration)) {
	        lastShortSelector = null;
	        return;
	      }
	    }

	    shorts[key] = shorthand;
	    shortDeclarations.push({
	      operation: operation,
	      block: declarations,
	      item: item,
	      shorthand: shorthand
	    });
	    lastShortSelector = selector;
	  });
	  return lastShortSelector;
	}

	function processShorthands(shortDeclarations, markDeclaration) {
	  shortDeclarations.forEach(function (item) {
	    var shorthand = item.shorthand;

	    if (!shorthand.isOkToMinimize()) {
	      return;
	    }

	    if (item.operation === REPLACE) {
	      item.item.data = markDeclaration(shorthand.getDeclaration());
	    } else {
	      item.block.remove(item.item);
	    }
	  });
	}

	var _4RestructShorthand = function restructBlock(ast, indexer) {
	  var stylesheetMap = {};
	  var shortDeclarations = [];
	  walk$8(ast, {
	    visit: 'Rule',
	    reverse: true,
	    enter: function (node) {
	      var stylesheet = this.block || this.stylesheet;
	      var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
	      var ruleMap;
	      var shorts;

	      if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
	        ruleMap = {
	          lastShortSelector: null
	        };
	        stylesheetMap[stylesheet.id] = ruleMap;
	      } else {
	        ruleMap = stylesheetMap[stylesheet.id];
	      }

	      if (ruleMap.hasOwnProperty(ruleId)) {
	        shorts = ruleMap[ruleId];
	      } else {
	        shorts = {};
	        ruleMap[ruleId] = shorts;
	      }

	      ruleMap.lastShortSelector = processRule$2.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
	    }
	  });
	  processShorthands(shortDeclarations, indexer.declaration);
	};

	var resolveProperty = lib.property;
	var resolveKeyword$4 = lib.keyword;
	var walk$9 = lib.walk;
	var generate$5 = lib.generate;
	var fingerprintId = 1;
	var dontRestructure = {
	  'src': 1 // https://github.com/afelix/csso/issues/50

	};
	var DONT_MIX_VALUE = {
	  // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
	  'display': /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
	  // https://developer.mozilla.org/en/docs/Web/CSS/text-align
	  'text-align': /^(start|end|match-parent|justify-all)$/i
	};
	var CURSOR_SAFE_VALUE = ['auto', 'crosshair', 'default', 'move', 'text', 'wait', 'help', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'pointer', 'progress', 'not-allowed', 'no-drop', 'vertical-text', 'all-scroll', 'col-resize', 'row-resize'];
	var POSITION_SAFE_VALUE = ['static', 'relative', 'absolute', 'fixed'];
	var NEEDLESS_TABLE = {
	  'border-width': ['border'],
	  'border-style': ['border'],
	  'border-color': ['border'],
	  'border-top': ['border'],
	  'border-right': ['border'],
	  'border-bottom': ['border'],
	  'border-left': ['border'],
	  'border-top-width': ['border-top', 'border-width', 'border'],
	  'border-right-width': ['border-right', 'border-width', 'border'],
	  'border-bottom-width': ['border-bottom', 'border-width', 'border'],
	  'border-left-width': ['border-left', 'border-width', 'border'],
	  'border-top-style': ['border-top', 'border-style', 'border'],
	  'border-right-style': ['border-right', 'border-style', 'border'],
	  'border-bottom-style': ['border-bottom', 'border-style', 'border'],
	  'border-left-style': ['border-left', 'border-style', 'border'],
	  'border-top-color': ['border-top', 'border-color', 'border'],
	  'border-right-color': ['border-right', 'border-color', 'border'],
	  'border-bottom-color': ['border-bottom', 'border-color', 'border'],
	  'border-left-color': ['border-left', 'border-color', 'border'],
	  'margin-top': ['margin'],
	  'margin-right': ['margin'],
	  'margin-bottom': ['margin'],
	  'margin-left': ['margin'],
	  'padding-top': ['padding'],
	  'padding-right': ['padding'],
	  'padding-bottom': ['padding'],
	  'padding-left': ['padding'],
	  'font-style': ['font'],
	  'font-variant': ['font'],
	  'font-weight': ['font'],
	  'font-size': ['font'],
	  'font-family': ['font'],
	  'list-style-type': ['list-style'],
	  'list-style-position': ['list-style'],
	  'list-style-image': ['list-style']
	};

	function getPropertyFingerprint(propertyName, declaration, fingerprints) {
	  var realName = resolveProperty(propertyName).basename;

	  if (realName === 'background') {
	    return propertyName + ':' + generate$5(declaration.value);
	  }

	  var declarationId = declaration.id;
	  var fingerprint = fingerprints[declarationId];

	  if (!fingerprint) {
	    switch (declaration.value.type) {
	      case 'Value':
	        var vendorId = '';
	        var iehack = '';
	        var special = {};
	        var raw = false;
	        declaration.value.children.each(function walk(node) {
	          switch (node.type) {
	            case 'Value':
	            case 'Brackets':
	            case 'Parentheses':
	              node.children.each(walk);
	              break;

	            case 'Raw':
	              raw = true;
	              break;

	            case 'Identifier':
	              var name = node.name;

	              if (!vendorId) {
	                vendorId = resolveKeyword$4(name).vendor;
	              }

	              if (/\\[09]/.test(name)) {
	                iehack = RegExp.lastMatch;
	              }

	              if (realName === 'cursor') {
	                if (CURSOR_SAFE_VALUE.indexOf(name) === -1) {
	                  special[name] = true;
	                }
	              } else if (realName === 'position') {
	                if (POSITION_SAFE_VALUE.indexOf(name) === -1) {
	                  special[name] = true;
	                }
	              } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
	                if (DONT_MIX_VALUE[realName].test(name)) {
	                  special[name] = true;
	                }
	              }

	              break;

	            case 'Function':
	              var name = node.name;

	              if (!vendorId) {
	                vendorId = resolveKeyword$4(name).vendor;
	              }

	              if (name === 'rect') {
	                // there are 2 forms of rect:
	                //   rect(<top>, <right>, <bottom>, <left>) - standart
	                //   rect(<top> <right> <bottom> <left>) – backwards compatible syntax
	                // only the same form values can be merged
	                var hasComma = node.children.some(function (node) {
	                  return node.type === 'Operator' && node.value === ',';
	                });

	                if (!hasComma) {
	                  name = 'rect-backward';
	                }
	              }

	              special[name + '()'] = true; // check nested tokens too

	              node.children.each(walk);
	              break;

	            case 'Dimension':
	              var unit = node.unit;

	              if (/\\[09]/.test(unit)) {
	                iehack = RegExp.lastMatch;
	              }

	              switch (unit) {
	                // is not supported until IE11
	                case 'rem': // v* units is too buggy across browsers and better
	                // don't merge values with those units

	                case 'vw':
	                case 'vh':
	                case 'vmin':
	                case 'vmax':
	                case 'vm':
	                  // IE9 supporting "vm" instead of "vmin".
	                  special[unit] = true;
	                  break;
	              }

	              break;
	          }
	        });
	        fingerprint = raw ? '!' + fingerprintId++ : '!' + Object.keys(special).sort() + '|' + iehack + vendorId;
	        break;

	      case 'Raw':
	        fingerprint = '!' + declaration.value.value;
	        break;

	      default:
	        fingerprint = generate$5(declaration.value);
	    }

	    fingerprints[declarationId] = fingerprint;
	  }

	  return propertyName + fingerprint;
	}

	function needless(props, declaration, fingerprints) {
	  var property = resolveProperty(declaration.property);

	  if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
	    var table = NEEDLESS_TABLE[property.basename];

	    for (var i = 0; i < table.length; i++) {
	      var ppre = getPropertyFingerprint(property.prefix + table[i], declaration, fingerprints);
	      var prev = props.hasOwnProperty(ppre) ? props[ppre] : null;

	      if (prev && (!declaration.important || prev.item.data.important)) {
	        return prev;
	      }
	    }
	  }
	}

	function processRule$3(rule, item, list, props, fingerprints) {
	  var declarations = rule.block.children;
	  declarations.eachRight(function (declaration, declarationItem) {
	    var property = declaration.property;
	    var fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
	    var prev = props[fingerprint];

	    if (prev && !dontRestructure.hasOwnProperty(property)) {
	      if (declaration.important && !prev.item.data.important) {
	        props[fingerprint] = {
	          block: declarations,
	          item: declarationItem
	        };
	        prev.block.remove(prev.item); // TODO: use it when we can refer to several points in source
	        // declaration.loc = {
	        //     primary: declaration.loc,
	        //     merged: prev.item.data.loc
	        // };
	      } else {
	        declarations.remove(declarationItem); // TODO: use it when we can refer to several points in source
	        // prev.item.data.loc = {
	        //     primary: prev.item.data.loc,
	        //     merged: declaration.loc
	        // };
	      }
	    } else {
	      var prev = needless(props, declaration, fingerprints);

	      if (prev) {
	        declarations.remove(declarationItem); // TODO: use it when we can refer to several points in source
	        // prev.item.data.loc = {
	        //     primary: prev.item.data.loc,
	        //     merged: declaration.loc
	        // };
	      } else {
	        declaration.fingerprint = fingerprint;
	        props[fingerprint] = {
	          block: declarations,
	          item: declarationItem
	        };
	      }
	    }
	  });

	  if (declarations.isEmpty()) {
	    list.remove(item);
	  }
	}

	var _6RestructBlock = function restructBlock(ast) {
	  var stylesheetMap = {};
	  var fingerprints = Object.create(null);
	  walk$9(ast, {
	    visit: 'Rule',
	    reverse: true,
	    enter: function (node, item, list) {
	      var stylesheet = this.block || this.stylesheet;
	      var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
	      var ruleMap;
	      var props;

	      if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
	        ruleMap = {};
	        stylesheetMap[stylesheet.id] = ruleMap;
	      } else {
	        ruleMap = stylesheetMap[stylesheet.id];
	      }

	      if (ruleMap.hasOwnProperty(ruleId)) {
	        props = ruleMap[ruleId];
	      } else {
	        props = {};
	        ruleMap[ruleId] = props;
	      }

	      processRule$3.call(this, node, item, list, props, fingerprints);
	    }
	  });
	};

	var walk$a = lib.walk;
	/*
	    At this step all rules has single simple selector. We try to join by equal
	    declaration blocks to first rule, e.g.

	    .a { color: red }
	    b { ... }
	    .b { color: red }
	    ->
	    .a, .b { color: red }
	    b { ... }
	*/

	function processRule$4(node, item, list) {
	  var selectors = node.prelude.children;
	  var declarations = node.block.children;
	  var nodeCompareMarker = selectors.first().compareMarker;
	  var skippedCompareMarkers = {};
	  list.nextUntil(item.next, function (next, nextItem) {
	    // skip non-ruleset node if safe
	    if (next.type !== 'Rule') {
	      return utils$2.unsafeToSkipNode.call(selectors, next);
	    }

	    if (node.pseudoSignature !== next.pseudoSignature) {
	      return true;
	    }

	    var nextFirstSelector = next.prelude.children.head;
	    var nextDeclarations = next.block.children;
	    var nextCompareMarker = nextFirstSelector.data.compareMarker; // if next ruleset has same marked as one of skipped then stop joining

	    if (nextCompareMarker in skippedCompareMarkers) {
	      return true;
	    } // try to join by selectors


	    if (selectors.head === selectors.tail) {
	      if (selectors.first().id === nextFirstSelector.data.id) {
	        declarations.appendList(nextDeclarations);
	        list.remove(nextItem);
	        return;
	      }
	    } // try to join by properties


	    if (utils$2.isEqualDeclarations(declarations, nextDeclarations)) {
	      var nextStr = nextFirstSelector.data.id;
	      selectors.some(function (data, item) {
	        var curStr = data.id;

	        if (nextStr < curStr) {
	          selectors.insert(nextFirstSelector, item);
	          return true;
	        }

	        if (!item.next) {
	          selectors.insert(nextFirstSelector);
	          return true;
	        }
	      });
	      list.remove(nextItem);
	      return;
	    } // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)


	    if (nextCompareMarker === nodeCompareMarker) {
	      return true;
	    }

	    skippedCompareMarkers[nextCompareMarker] = true;
	  });
	}

	var _7MergeRuleset = function mergeRule(ast) {
	  walk$a(ast, {
	    visit: 'Rule',
	    enter: processRule$4
	  });
	};

	var List$5 = lib.List;
	var walk$b = lib.walk;

	function calcSelectorLength(list) {
	  var length = 0;
	  list.each(function (data) {
	    length += data.id.length + 1;
	  });
	  return length - 1;
	}

	function calcDeclarationsLength(tokens) {
	  var length = 0;

	  for (var i = 0; i < tokens.length; i++) {
	    length += tokens[i].length;
	  }

	  return length + // declarations
	  tokens.length - 1 // delimeters
	  ;
	}

	function processRule$5(node, item, list) {
	  var avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
	  var selectors = node.prelude.children;
	  var block = node.block;
	  var disallowDownMarkers = Object.create(null);
	  var allowMergeUp = true;
	  var allowMergeDown = true;
	  list.prevUntil(item.prev, function (prev, prevItem) {
	    var prevBlock = prev.block;
	    var prevType = prev.type;

	    if (prevType !== 'Rule') {
	      var unsafe = utils$2.unsafeToSkipNode.call(selectors, prev);

	      if (!unsafe && prevType === 'Atrule' && prevBlock) {
	        walk$b(prevBlock, {
	          visit: 'Rule',
	          enter: function (node) {
	            node.prelude.children.each(function (data) {
	              disallowDownMarkers[data.compareMarker] = true;
	            });
	          }
	        });
	      }

	      return unsafe;
	    }

	    var prevSelectors = prev.prelude.children;

	    if (node.pseudoSignature !== prev.pseudoSignature) {
	      return true;
	    }

	    allowMergeDown = !prevSelectors.some(function (selector) {
	      return selector.compareMarker in disallowDownMarkers;
	    }); // try prev ruleset if simpleselectors has no equal specifity and element selector

	    if (!allowMergeDown && !allowMergeUp) {
	      return true;
	    } // try to join by selectors


	    if (allowMergeUp && utils$2.isEqualSelectors(prevSelectors, selectors)) {
	      prevBlock.children.appendList(block.children);
	      list.remove(item);
	      return true;
	    } // try to join by properties


	    var diff = utils$2.compareDeclarations(block.children, prevBlock.children); // console.log(diff.eq, diff.ne1, diff.ne2);

	    if (diff.eq.length) {
	      if (!diff.ne1.length && !diff.ne2.length) {
	        // equal blocks
	        if (allowMergeDown) {
	          utils$2.addSelectors(selectors, prevSelectors);
	          list.remove(prevItem);
	        }

	        return true;
	      } else if (!avoidRulesMerge) {
	        /* probably we don't need to prevent those merges for @keyframes
	           TODO: need to be checked */
	        if (diff.ne1.length && !diff.ne2.length) {
	          // prevBlock is subset block
	          var selectorLength = calcSelectorLength(selectors);
	          var blockLength = calcDeclarationsLength(diff.eq); // declarations length

	          if (allowMergeUp && selectorLength < blockLength) {
	            utils$2.addSelectors(prevSelectors, selectors);
	            block.children = new List$5().fromArray(diff.ne1);
	          }
	        } else if (!diff.ne1.length && diff.ne2.length) {
	          // node is subset of prevBlock
	          var selectorLength = calcSelectorLength(prevSelectors);
	          var blockLength = calcDeclarationsLength(diff.eq); // declarations length

	          if (allowMergeDown && selectorLength < blockLength) {
	            utils$2.addSelectors(selectors, prevSelectors);
	            prevBlock.children = new List$5().fromArray(diff.ne2);
	          }
	        } else {
	          // diff.ne1.length && diff.ne2.length
	          // extract equal block
	          var newSelector = {
	            type: 'SelectorList',
	            loc: null,
	            children: utils$2.addSelectors(prevSelectors.copy(), selectors)
	          };
	          var newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length

	          var blockLength = calcDeclarationsLength(diff.eq); // declarations length
	          // create new ruleset if declarations length greater than
	          // ruleset description overhead

	          if (blockLength >= newBlockLength) {
	            var newItem = list.createItem({
	              type: 'Rule',
	              loc: null,
	              prelude: newSelector,
	              block: {
	                type: 'Block',
	                loc: null,
	                children: new List$5().fromArray(diff.eq)
	              },
	              pseudoSignature: node.pseudoSignature
	            });
	            block.children = new List$5().fromArray(diff.ne1);
	            prevBlock.children = new List$5().fromArray(diff.ne2overrided);

	            if (allowMergeUp) {
	              list.insert(newItem, prevItem);
	            } else {
	              list.insert(newItem, item);
	            }

	            return true;
	          }
	        }
	      }
	    }

	    if (allowMergeUp) {
	      // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);
	      // await property families to find property interception correctly
	      allowMergeUp = !prevSelectors.some(function (prevSelector) {
	        return selectors.some(function (selector) {
	          return selector.compareMarker === prevSelector.compareMarker;
	        });
	      });
	    }

	    prevSelectors.each(function (data) {
	      disallowDownMarkers[data.compareMarker] = true;
	    });
	  });
	}

	var _8RestructRuleset = function restructRule(ast) {
	  walk$b(ast, {
	    visit: 'Rule',
	    reverse: true,
	    enter: processRule$5
	  });
	};

	var restructure = function (ast, options) {
	  // prepare ast for restructing
	  var indexer = prepare(ast, options);
	  options.logger('prepare', ast);
	  _1MergeAtrule(ast, options);
	  options.logger('mergeAtrule', ast);
	  _2InitialMergeRuleset(ast);
	  options.logger('initialMergeRuleset', ast);
	  _3DisjoinRuleset(ast);
	  options.logger('disjoinRuleset', ast);
	  _4RestructShorthand(ast, indexer);
	  options.logger('restructShorthand', ast);
	  _6RestructBlock(ast);
	  options.logger('restructBlock', ast);
	  _7MergeRuleset(ast);
	  options.logger('mergeRuleset', ast);
	  _8RestructRuleset(ast);
	  options.logger('restructRuleset', ast);
	};

	var List$6 = lib.List;
	var clone$2 = lib.clone;
	var walk$c = lib.walk;

	function readChunk(children, specialComments) {
	  var buffer = new List$6();
	  var nonSpaceTokenInBuffer = false;
	  var protectedComment;
	  children.nextUntil(children.head, function (node, item, list) {
	    if (node.type === 'Comment') {
	      if (!specialComments || node.value.charAt(0) !== '!') {
	        list.remove(item);
	        return;
	      }

	      if (nonSpaceTokenInBuffer || protectedComment) {
	        return true;
	      }

	      list.remove(item);
	      protectedComment = node;
	      return;
	    }

	    if (node.type !== 'WhiteSpace') {
	      nonSpaceTokenInBuffer = true;
	    }

	    buffer.insert(list.remove(item));
	  });
	  return {
	    comment: protectedComment,
	    stylesheet: {
	      type: 'StyleSheet',
	      loc: null,
	      children: buffer
	    }
	  };
	}

	function compressChunk(ast, firstAtrulesAllowed, num, options) {
	  options.logger('Compress block #' + num, null, true);
	  var seed = 1;

	  if (ast.type === 'StyleSheet') {
	    ast.firstAtrulesAllowed = firstAtrulesAllowed;
	    ast.id = seed++;
	  }

	  walk$c(ast, {
	    visit: 'Atrule',
	    enter: function markScopes(node) {
	      if (node.block !== null) {
	        node.block.id = seed++;
	      }
	    }
	  });
	  options.logger('init', ast); // remove redundant

	  clean(ast, options);
	  options.logger('clean', ast); // replace nodes for shortened forms

	  replace(ast);
	  options.logger('replace', ast); // structure optimisations

	  if (options.restructuring) {
	    restructure(ast, options);
	  }

	  return ast;
	}

	function getCommentsOption(options) {
	  var comments = 'comments' in options ? options.comments : 'exclamation';

	  if (typeof comments === 'boolean') {
	    comments = comments ? 'exclamation' : false;
	  } else if (comments !== 'exclamation' && comments !== 'first-exclamation') {
	    comments = false;
	  }

	  return comments;
	}

	function getRestructureOption(options) {
	  if ('restructure' in options) {
	    return options.restructure;
	  }

	  return 'restructuring' in options ? options.restructuring : true;
	}

	function wrapBlock(block) {
	  return new List$6().appendData({
	    type: 'Rule',
	    loc: null,
	    prelude: {
	      type: 'SelectorList',
	      loc: null,
	      children: new List$6().appendData({
	        type: 'Selector',
	        loc: null,
	        children: new List$6().appendData({
	          type: 'TypeSelector',
	          loc: null,
	          name: 'x'
	        })
	      })
	    },
	    block: block
	  });
	}

	var compress = function compress(ast, options) {
	  ast = ast || {
	    type: 'StyleSheet',
	    loc: null,
	    children: new List$6()
	  };
	  options = options || {};
	  var compressOptions = {
	    logger: typeof options.logger === 'function' ? options.logger : function () {},
	    restructuring: getRestructureOption(options),
	    forceMediaMerge: Boolean(options.forceMediaMerge),
	    usage: options.usage ? usage.buildIndex(options.usage) : false
	  };
	  var specialComments = getCommentsOption(options);
	  var firstAtrulesAllowed = true;
	  var input;
	  var output = new List$6();
	  var chunk;
	  var chunkNum = 1;
	  var chunkChildren;

	  if (options.clone) {
	    ast = clone$2(ast);
	  }

	  if (ast.type === 'StyleSheet') {
	    input = ast.children;
	    ast.children = output;
	  } else {
	    input = wrapBlock(ast);
	  }

	  do {
	    chunk = readChunk(input, Boolean(specialComments));
	    compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
	    chunkChildren = chunk.stylesheet.children;

	    if (chunk.comment) {
	      // add \n before comment if there is another content in output
	      if (!output.isEmpty()) {
	        output.insert(List$6.createItem({
	          type: 'Raw',
	          value: '\n'
	        }));
	      }

	      output.insert(List$6.createItem(chunk.comment)); // add \n after comment if chunk is not empty

	      if (!chunkChildren.isEmpty()) {
	        output.insert(List$6.createItem({
	          type: 'Raw',
	          value: '\n'
	        }));
	      }
	    }

	    if (firstAtrulesAllowed && !chunkChildren.isEmpty()) {
	      var lastRule = chunkChildren.last();

	      if (lastRule.type !== 'Atrule' || lastRule.name !== 'import' && lastRule.name !== 'charset') {
	        firstAtrulesAllowed = false;
	      }
	    }

	    if (specialComments !== 'exclamation') {
	      specialComments = false;
	    }

	    output.appendList(chunkChildren);
	  } while (!input.isEmpty());

	  return {
	    ast: ast
	  };
	};

	var name = "csso";
	var version$1 = "4.0.3";
	var description = "CSS minifier with structural optimisations";
	var homepage = "https://github.com/css/csso";
	var author = "Sergey Kryzhanovsky <skryzhanovsky@ya.ru> (https://github.com/afelix)";
	var maintainers = [
		{
			name: "Roman Dvornov",
			email: "rdvornov@gmail.com",
			"github-username": "lahmatiy"
		}
	];
	var license = "MIT";
	var repository = "css/csso";
	var bugs = {
		url: "https://github.com/css/csso/issues"
	};
	var keywords$1 = [
		"css",
		"compress",
		"minifier",
		"minify",
		"optimise",
		"optimisation",
		"csstree"
	];
	var main = "./lib/index";
	var scripts = {
		test: "mocha --reporter dot",
		lint: "eslint lib test",
		"lint-and-test": "npm run lint && npm test",
		build: "rollup --config && terser dist/csso.js --compress --mangle -o dist/csso.min.js",
		coverage: "nyc npm test",
		coveralls: "nyc report --reporter=text-lcov | coveralls",
		travis: "nyc npm run lint-and-test && npm run coveralls",
		hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null",
		"gh-pages": "git clone --depth=1 -b gh-pages https://github.com/css/csso.git .gh-pages && npm run build && cp dist/csso.min.js .gh-pages/ && cd .gh-pages && git commit -am \"update\" && git push && cd .. && rm -rf .gh-pages",
		prepublishOnly: "npm run build",
		postpublish: "npm run gh-pages"
	};
	var dependencies = {
		"css-tree": "1.0.0-alpha.39"
	};
	var devDependencies = {
		"@rollup/plugin-commonjs": "^11.0.1",
		"@rollup/plugin-json": "^4.0.1",
		"@rollup/plugin-node-resolve": "^7.0.0",
		coveralls: "^3.0.11",
		eslint: "^6.8.0",
		mocha: "^7.1.1",
		nyc: "^15.0.0",
		rollup: "^1.29.0",
		"source-map": "^0.6.1",
		terser: "^4.6.3"
	};
	var engines = {
		node: ">=8.0.0"
	};
	var files = [
		"dist/csso.js",
		"dist/csso.min.js",
		"lib"
	];
	var _package = {
		name: name,
		version: version$1,
		description: description,
		homepage: homepage,
		author: author,
		maintainers: maintainers,
		license: license,
		repository: repository,
		bugs: bugs,
		keywords: keywords$1,
		main: main,
		scripts: scripts,
		dependencies: dependencies,
		devDependencies: devDependencies,
		engines: engines,
		files: files
	};

	var _package$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		name: name,
		version: version$1,
		description: description,
		homepage: homepage,
		author: author,
		maintainers: maintainers,
		license: license,
		repository: repository,
		bugs: bugs,
		keywords: keywords$1,
		main: main,
		scripts: scripts,
		dependencies: dependencies,
		devDependencies: devDependencies,
		engines: engines,
		files: files,
		'default': _package
	});

	var require$$0 = getCjsExportFromNamespace(_package$1);

	var parse$3 = lib.parse;
	var generate$6 = lib.generate;

	function debugOutput(name, options, startTime, data) {
	  if (options.debug) {
	    console.error('## ' + name + ' done in %d ms\n', Date.now() - startTime);
	  }

	  return data;
	}

	function createDefaultLogger(level) {
	  var lastDebug;
	  return function logger(title, ast) {
	    var line = title;

	    if (ast) {
	      line = '[' + ((Date.now() - lastDebug) / 1000).toFixed(3) + 's] ' + line;
	    }

	    if (level > 1 && ast) {
	      var css = generate$6(ast); // when level 2, limit css to 256 symbols

	      if (level === 2 && css.length > 256) {
	        css = css.substr(0, 256) + '...';
	      }

	      line += '\n  ' + css + '\n';
	    }

	    console.error(line);
	    lastDebug = Date.now();
	  };
	}

	function copy$1(obj) {
	  var result = {};

	  for (var key in obj) {
	    result[key] = obj[key];
	  }

	  return result;
	}

	function buildCompressOptions(options) {
	  options = copy$1(options);

	  if (typeof options.logger !== 'function' && options.debug) {
	    options.logger = createDefaultLogger(options.debug);
	  }

	  return options;
	}

	function runHandler(ast, options, handlers) {
	  if (!Array.isArray(handlers)) {
	    handlers = [handlers];
	  }

	  handlers.forEach(function (fn) {
	    fn(ast, options);
	  });
	}

	function minify(context, source, options) {
	  options = options || {};
	  var filename = options.filename || '<unknown>';
	  var result; // parse

	  var ast = debugOutput('parsing', options, Date.now(), parse$3(source, {
	    context: context,
	    filename: filename,
	    positions: Boolean(options.sourceMap)
	  })); // before compress handlers

	  if (options.beforeCompress) {
	    debugOutput('beforeCompress', options, Date.now(), runHandler(ast, options, options.beforeCompress));
	  } // compress


	  var compressResult = debugOutput('compress', options, Date.now(), compress(ast, buildCompressOptions(options))); // after compress handlers

	  if (options.afterCompress) {
	    debugOutput('afterCompress', options, Date.now(), runHandler(compressResult, options, options.afterCompress));
	  } // generate


	  if (options.sourceMap) {
	    result = debugOutput('generate(sourceMap: true)', options, Date.now(), function () {
	      var tmp = generate$6(compressResult.ast, {
	        sourceMap: true
	      });
	      tmp.map._file = filename; // since other tools can relay on file in source map transform chain

	      tmp.map.setSourceContent(filename, source);
	      return tmp;
	    }());
	  } else {
	    result = debugOutput('generate', options, Date.now(), {
	      css: generate$6(compressResult.ast),
	      map: null
	    });
	  }

	  return result;
	}

	function minifyStylesheet(source, options) {
	  return minify('stylesheet', source, options);
	}

	function minifyBlock(source, options) {
	  return minify('declarationList', source, options);
	}

	var lib$1 = {
	  version: require$$0.version,
	  // main methods
	  minify: minifyStylesheet,
	  minifyBlock: minifyBlock,
	  // css syntax parser/walkers/generator/etc
	  syntax: Object.assign({
	    compress: compress
	  }, lib)
	};

	var version$2 = "1.4.2";

	var apiWorker;
	var api = {
	  get: function get(_ref) {
	    var route = _ref.route,
	        draft = _ref.draft,
	        style = _ref.style;
	    var data = new FormData();
	    data.append('id', draft.id);
	    style && style.style && data.append('style', style.style);
	    style && style.substyle && data.append('substyle', style.substyle);
	    return ajax(route.ajax + "styles/get/", {
	      data: data,
	      method: 'POST',
	      responseType: 'json'
	    });
	  },
	  set: function set(_ref2) {
	    var route = _ref2.route,
	        draft = _ref2.draft,
	        values = _ref2.values;
	    var data = new FormData();
	    data.append('id', draft.id);
	    convertToFormData(values, data);
	    return ajax(route.ajax + "styles/set/", {
	      data: data,
	      method: 'POST',
	      responseType: 'json'
	    });
	  },
	  compile: function compile(_ref3) {
	    var route = _ref3.route,
	        getters = _ref3.getters;
	    apiWorker && apiWorker.terminate();
	    return new Promise(function (resolve, reject) {
	      if (window.Worker) {
	        apiWorker = new Worker(route.ajax.replace('customizer/', "wa-apps/customizer/plugins/styles/js/frontend/worker.min.js?v=" + version$2));

	        apiWorker.onmessage = function (e) {
	          apiWorker.terminate();
	          resolve(e.data);
	        };

	        apiWorker.onerror = function (e) {
	          apiWorker.terminate();
	          reject(e);
	        };

	        apiWorker.postMessage([getters]);
	      } else {
	        reject('Your browser doesn\'t support web workers.');
	      }
	    });
	  }
	};

	var actions = {
	  get: function get(_ref, style) {
	    var commit = _ref.commit,
	        dispatch = _ref.dispatch,
	        getters = _ref.getters,
	        rootGetters = _ref.rootGetters;
	    return new Promise(function (resolve, reject) {
	      var route = rootGetters.route,
	          draft = rootGetters.draft;

	      var _final = function _final() {
	        return commit('setState', {
	          name: 'status',
	          value: 4
	        });
	      };

	      commit('setState', {
	        name: 'status',
	        value: 1
	      });
	      api.get({
	        route: route,
	        draft: draft,
	        style: style
	      }).then(function (_ref2) {
	        var response = _ref2.response;

	        if (getters.compatible && !response.data.compatible) {
	          var panels = {
	            styles: {
	              name: 'styles',
	              title: 'Styles',
	              fields: {
	                errorcompatible: {
	                  type: 'error-compatible'
	                }
	              }
	            }
	          };
	          commit('setState', {
	            name: 'panels',
	            value: panels
	          });
	          return;
	        }

	        commit('setState', {
	          name: 'vars',
	          value: response.data.vars
	        });
	        commit('setState', {
	          name: 'styles',
	          value: response.data.styles
	        });
	        commit('setState', {
	          name: 'imports',
	          value: response.data.imports
	        });
	        dispatch('set');
	        /*
	        dispatch('compile').then(
	            r => {
	                final()
	                resolve(r)
	            },
	            e => {
	                final()
	                reject(e)
	            }
	        )
	        */
	      }, function (e) {
	        _final();

	        reject(e);
	      });
	    });
	  },
	  set: function set(_ref3, force) {
	    var commit = _ref3.commit,
	        dispatch = _ref3.dispatch,
	        getters = _ref3.getters,
	        rootGetters = _ref3.rootGetters;
	    return new Promise(function (resolve, reject) {
	      var route = rootGetters.route,
	          draft = rootGetters.draft;

	      var _final2 = function _final2() {
	        commit('setState', {
	          name: 'status',
	          value: 4
	        });
	        commit('setState', {
	          name: 'status',
	          value: 4
	        }, {
	          root: true
	        });
	      };

	      commit('setState', {
	        name: 'status',
	        value: 2
	      });
	      commit('setState', {
	        name: 'status',
	        value: 0
	      }, {
	        root: true
	      });
	      dispatch('compile', force).then(function (r) {
	        var values = {
	          config: getters.vars,
	          css: r.css,
	          min: r.min,
	          icons: getters.styles[getters.style].icons,
	          iconsMin: getters.styles[getters.style].iconsMin
	        };
	        api.set({
	          route: route,
	          draft: draft,
	          values: values
	        }).then(function (_ref4) {
	          var response = _ref4.response;

	          if (response.status === 'fail') {
	            (isArray(response.errors) ? response.errors : [response.errors]).forEach(function (error) {
	              uikit.notification({
	                message: error,
	                status: 'danger',
	                pos: 'bottom-right',
	                timeout: 5000
	              });
	            });
	          }

	          commit('setState', {
	            name: 'changed',
	            value: false
	          });
	          dispatch('updatePreview', {});

	          _final2();

	          resolve(response);
	        }, function (error) {
	          uikit.notification({
	            message: error,
	            status: 'danger',
	            pos: 'bottom-right',
	            timeout: 5000
	          });

	          _final2();

	          reject(error);
	        });
	      }, function (error) {
	        uikit.notification({
	          message: error,
	          status: 'danger',
	          pos: 'bottom-right',
	          timeout: 5000
	        });

	        _final2();

	        reject(error);
	      });
	    });
	  },
	  compile: function compile(_ref5, force) {
	    var commit = _ref5.commit,
	        getters = _ref5.getters,
	        rootGetters = _ref5.rootGetters;
	    return new Promise(function (resolve, reject) {
	      var route = rootGetters.route;
	      commit('setState', {
	        name: 'vars',
	        value: assign({}, getters.vars, getters.diff)
	      }); // set new vars
	      // console.log(getters.less)

	      api.compile({
	        route: route,
	        getters: getters
	      }).then(function (e) {
	        if (e.message) {
	          reject(e.message);
	          return;
	        }

	        if (!force) {
	          commit('setState', {
	            name: 'variables',
	            value: e.variables
	          });
	          commit('setState', {
	            name: 'panels',
	            value: e.panels
	          }); // deactivate values change tracking

	          commit('setState', {
	            name: 'tracking',
	            value: false
	          }); // update changed values

	          Object.keys(getters.values).forEach(function (name) {
	            return e.variables[name] && (getters.values[name] = e.variables[name].value);
	          }); // activate values change tracking

	          setTimeout(function () {
	            return commit('setState', {
	              name: 'tracking',
	              value: true
	            });
	          }, 0); // rerender current pane with new fields

	          e.panels[getters.currentPanelName] && (rootGetters['sidebar/panel'].fields = e.panels[getters.currentPanelName].fields);
	          /*
	          const panelName = getters.currentPanelName
	            if (panelName in getters.groups) {
	              dispatch('sidebar/closePanel', void 0, { root: true })
	              dispatch('openPanel', panelName)
	          }
	          */
	        } // minify


	        e.min = lib$1.minify(e.css, {
	          restructure: false
	        }).css;
	        resolve(e);
	      }, reject);
	    });
	  },
	  openPanel: function openPanel(_ref6, panel) {
	    var dispatch = _ref6.dispatch,
	        getters = _ref6.getters;
	    panel = isString(panel) ? getters.panels[panel] : panel;
	    panel && dispatch('sidebar/openPanel', assign({
	      component: __vue_component__$w,
	      props: {
	        values: getters.values
	      }
	    }, panel), {
	      root: true
	    });
	  },
	  updatePreview: function updatePreview(_ref7, payload) {
	    var dispatch = _ref7.dispatch;

	    if (payload === void 0) {
	      payload = {};
	    }

	    dispatch('preview/load', payload, {
	      root: true
	    });
	  },
	  reset: function reset(_ref8, name) {
	    var commit = _ref8.commit,
	        dispatch = _ref8.dispatch,
	        state = _ref8.state,
	        getters = _ref8.getters;

	    /*
	    getters.panels[name]
	        ? Object.keys(getters.panels[name].fields).reduce((names, n) => {
	            return names.concat(Object.keys(getters.panels[name].fields[n].items))
	        }, []).forEach(name => commit('setState', { name: `vars.${name}` }))
	        : commit('setState', { name: `vars.${name}` })
	    */
	    var names = getters.panels[name] ? Object.keys(getters.panels[name].fields).reduce(function (names, n) {
	      // return names.concat(Object.keys(getters.panels[name].fields[n].items))
	      return names.concat(getters.panels[name].fields[n].items ? Object.keys(getters.panels[name].fields[n].items) : Object.keys(getters.panels[name].fields));
	    }, []) : [name]; // console.log(names)

	    names.forEach(function (name) {
	      if (/.*-background$/.test(name)) {
	        commit('setState', {
	          name: "vars." + name.replace(/^@/, '@internal-').replace(/-background$/, '-gradient')
	        });
	      }

	      commit('setState', {
	        name: "vars." + name
	      });
	    }); // internal fonts

	    if (getters.vars['@internal-fonts']) {
	      var vars = Object.keys(getters.vars).filter(function (n) {
	        return /-font-family$/.test(n);
	      }).filter(function (n) {
	        return !state.variables[n].computed;
	      }).map(function (n) {
	        var font = state.fonts[1].fonts.filter(function (font) {
	          return font.value === getters.vars[n];
	        })[0];
	        return font ? font.name.replace(/\s/g, '+') : false;
	      }).filter(Boolean);

	      if (vars.length) {
	        commit('setState', {
	          name: "vars.@internal-fonts",
	          value: getters.vars['@internal-fonts'].replace(/~'([^']*)'/, '$1').split('|').filter(function (f) {
	            return vars.includes(f.split(':')[0]);
	          }).join('|').replace(/(.*)/, "~'$1'")
	        });
	      } else {
	        commit('setState', {
	          name: "vars.@internal-fonts"
	        });
	      }
	    } // apply changes


	    getters.autoApply ? dispatch('set') : commit('setState', {
	      name: 'changed',
	      value: true
	    });
	  },
	  clear: function clear(_ref9) {
	    var commit = _ref9.commit;
	    commit('setState', {
	      name: 'changed',
	      value: false
	    });
	    commit('setState', {
	      name: 'panels',
	      value: {}
	    });
	    commit('setState', {
	      name: 'values',
	      value: {}
	    });
	  }
	};

	var mutations = {
	  setState: function setState(state, _ref) {
	    var name = _ref.name,
	        value = _ref.value;
	    value === void 0 ? del(state, name) : set(state, name, value);
	  }
	};

	var name$1 = "System Fonts";
	var fonts = [
		{
			name: "Default System Font",
			value: "-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"",
			category: "sans-serif"
		},
		{
			name: "Consolas/Monaco",
			value: "Consolas, monaco, monospace",
			category: "monospace"
		},
		{
			name: "Georgia",
			value: "Georgia, \"Times New Roman\", Times, serif",
			category: "serif"
		},
		{
			name: "Helvetica/Arial",
			value: "\"Helvetica Neue\", Helvetica, Arial, sans-serif",
			category: "sans-serif"
		},
		{
			name: "Lucida",
			value: "\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, sans-serif",
			category: "sans-serif"
		},
		{
			name: "Times New Roman",
			value: "\"Times New Roman\", Times, serif",
			category: "serif"
		},
		{
			name: "Trebuchet",
			value: "\"Trebuchet MS\", Verdana, sans-serif",
			category: "sans-serif"
		},
		{
			name: "Verdana",
			value: "Verdana, Geneva, sans-serif",
			category: "sans-serif"
		},
		{
			name: "Inherit",
			value: "inherit"
		}
	];
	var system = {
		name: name$1,
		fonts: fonts
	};

	var name$2 = "Google Fonts";
	var fonts$1 = [
		{
			name: "ABeeZee",
			value: "ABeeZee, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Abel",
			value: "Abel, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Abhaya Libre",
			value: "\"Abhaya Libre\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"sinhala"
			],
			category: "serif"
		},
		{
			name: "Abril Fatface",
			value: "\"Abril Fatface\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Aclonica",
			value: "Aclonica, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Acme",
			value: "Acme, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Actor",
			value: "Actor, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Adamina",
			value: "Adamina, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Advent Pro",
			value: "\"Advent Pro\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"greek",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Aguafina Script",
			value: "\"Aguafina Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Akronim",
			value: "Akronim, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Aladin",
			value: "Aladin, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Alata",
			value: "Alata, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Alatsi",
			value: "Alatsi, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Aldrich",
			value: "Aldrich, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Alef",
			value: "Alef, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"hebrew",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Alegreya",
			value: "Alegreya, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Alegreya SC",
			value: "\"Alegreya SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Alegreya Sans",
			value: "\"Alegreya Sans\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Alegreya Sans SC",
			value: "\"Alegreya Sans SC\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Aleo",
			value: "Aleo, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Alex Brush",
			value: "\"Alex Brush\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Alfa Slab One",
			value: "\"Alfa Slab One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Alice",
			value: "Alice, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Alike",
			value: "Alike, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Alike Angular",
			value: "\"Alike Angular\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Allan",
			value: "Allan, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Allerta",
			value: "Allerta, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Allerta Stencil",
			value: "\"Allerta Stencil\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Allura",
			value: "Allura, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Almarai",
			value: "Almarai, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic"
			],
			category: "sans-serif"
		},
		{
			name: "Almendra",
			value: "Almendra, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Almendra Display",
			value: "\"Almendra Display\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Almendra SC",
			value: "\"Almendra SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Amarante",
			value: "Amarante, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Amaranth",
			value: "Amaranth, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Amatic SC",
			value: "\"Amatic SC\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"hebrew",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Amethysta",
			value: "Amethysta, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Amiko",
			value: "Amiko, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Amiri",
			value: "Amiri, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Amita",
			value: "Amita, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Anaheim",
			value: "Anaheim, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Andada",
			value: "Andada, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Andika",
			value: "Andika, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Angkor",
			value: "Angkor, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Annie Use Your Telescope",
			value: "\"Annie Use Your Telescope\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Anonymous Pro",
			value: "\"Anonymous Pro\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"greek",
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "Antic",
			value: "Antic, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Antic Didone",
			value: "\"Antic Didone\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Antic Slab",
			value: "\"Antic Slab\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Anton",
			value: "Anton, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Arapey",
			value: "Arapey, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Arbutus",
			value: "Arbutus, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Arbutus Slab",
			value: "\"Arbutus Slab\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Architects Daughter",
			value: "\"Architects Daughter\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Archivo",
			value: "Archivo, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Archivo Black",
			value: "\"Archivo Black\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Archivo Narrow",
			value: "\"Archivo Narrow\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Aref Ruqaa",
			value: "\"Aref Ruqaa\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Arima Madurai",
			value: "\"Arima Madurai\", cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"tamil",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Arimo",
			value: "Arimo, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"hebrew",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Arizonia",
			value: "Arizonia, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Armata",
			value: "Armata, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Arsenal",
			value: "Arsenal, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Artifika",
			value: "Artifika, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Arvo",
			value: "Arvo, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Arya",
			value: "Arya, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Asap",
			value: "Asap, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Asap Condensed",
			value: "\"Asap Condensed\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Asar",
			value: "Asar, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Asset",
			value: "Asset, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Assistant",
			value: "Assistant, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"hebrew",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Astloch",
			value: "Astloch, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Asul",
			value: "Asul, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Athiti",
			value: "Athiti, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Atma",
			value: "Atma, cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"bengali",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Atomic Age",
			value: "\"Atomic Age\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Aubrey",
			value: "Aubrey, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Audiowide",
			value: "Audiowide, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Autour One",
			value: "\"Autour One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Average",
			value: "Average, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Average Sans",
			value: "\"Average Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Averia Gruesa Libre",
			value: "\"Averia Gruesa Libre\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Averia Libre",
			value: "\"Averia Libre\", cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Averia Sans Libre",
			value: "\"Averia Sans Libre\", cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Averia Serif Libre",
			value: "\"Averia Serif Libre\", cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "B612",
			value: "B612, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "B612 Mono",
			value: "\"B612 Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "monospace"
		},
		{
			name: "Bad Script",
			value: "\"Bad Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Bahiana",
			value: "Bahiana, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Bahianita",
			value: "Bahianita, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Bai Jamjuree",
			value: "\"Bai Jamjuree\", sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Baloo 2",
			value: "\"Baloo 2\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Baloo Bhai 2",
			value: "\"Baloo Bhai 2\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"gujarati",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Baloo Bhaina 2",
			value: "\"Baloo Bhaina 2\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"oriya",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Baloo Chettan 2",
			value: "\"Baloo Chettan 2\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"malayalam",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Baloo Da 2",
			value: "\"Baloo Da 2\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"bengali",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Baloo Paaji 2",
			value: "\"Baloo Paaji 2\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"gurmukhi",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Baloo Tamma 2",
			value: "\"Baloo Tamma 2\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"kannada",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Baloo Tammudu 2",
			value: "\"Baloo Tammudu 2\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"telugu",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Baloo Thambi 2",
			value: "\"Baloo Thambi 2\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"tamil",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Balsamiq Sans",
			value: "\"Balsamiq Sans\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Balthazar",
			value: "Balthazar, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Bangers",
			value: "Bangers, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Barlow",
			value: "Barlow, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Barlow Condensed",
			value: "\"Barlow Condensed\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Barlow Semi Condensed",
			value: "\"Barlow Semi Condensed\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Barriecito",
			value: "Barriecito, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Barrio",
			value: "Barrio, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Basic",
			value: "Basic, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Baskervville",
			value: "Baskervville, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Battambang",
			value: "Battambang, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Baumans",
			value: "Baumans, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Bayon",
			value: "Bayon, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Be Vietnam",
			value: "\"Be Vietnam\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Bebas Neue",
			value: "\"Bebas Neue\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Belgrano",
			value: "Belgrano, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Bellefair",
			value: "Bellefair, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"hebrew",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Belleza",
			value: "Belleza, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Bellota",
			value: "Bellota, cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Bellota Text",
			value: "\"Bellota Text\", cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "BenchNine",
			value: "BenchNine, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Bentham",
			value: "Bentham, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Berkshire Swash",
			value: "\"Berkshire Swash\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Beth Ellen",
			value: "\"Beth Ellen\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Bevan",
			value: "Bevan, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Big Shoulders Display",
			value: "\"Big Shoulders Display\", cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Big Shoulders Inline Display",
			value: "\"Big Shoulders Inline Display\", cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Big Shoulders Inline Text",
			value: "\"Big Shoulders Inline Text\", cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Big Shoulders Stencil Display",
			value: "\"Big Shoulders Stencil Display\", cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Big Shoulders Stencil Text",
			value: "\"Big Shoulders Stencil Text\", cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Big Shoulders Text",
			value: "\"Big Shoulders Text\", cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Bigelow Rules",
			value: "\"Bigelow Rules\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Bigshot One",
			value: "\"Bigshot One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Bilbo",
			value: "Bilbo, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Bilbo Swash Caps",
			value: "\"Bilbo Swash Caps\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "BioRhyme",
			value: "BioRhyme, serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "BioRhyme Expanded",
			value: "\"BioRhyme Expanded\", serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Biryani",
			value: "Biryani, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Bitter",
			value: "Bitter, serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Black And White Picture",
			value: "\"Black And White Picture\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Black Han Sans",
			value: "\"Black Han Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Black Ops One",
			value: "\"Black Ops One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Blinker",
			value: "Blinker, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Bokor",
			value: "Bokor, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Bonbon",
			value: "Bonbon, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Boogaloo",
			value: "Boogaloo, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Bowlby One",
			value: "\"Bowlby One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Bowlby One SC",
			value: "\"Bowlby One SC\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Brawler",
			value: "Brawler, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Bree Serif",
			value: "\"Bree Serif\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Bubblegum Sans",
			value: "\"Bubblegum Sans\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Bubbler One",
			value: "\"Bubbler One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Buda",
			value: "Buda, cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Buenard",
			value: "Buenard, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Bungee",
			value: "Bungee, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Bungee Hairline",
			value: "\"Bungee Hairline\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Bungee Inline",
			value: "\"Bungee Inline\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Bungee Outline",
			value: "\"Bungee Outline\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Bungee Shade",
			value: "\"Bungee Shade\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Butcherman",
			value: "Butcherman, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Butterfly Kids",
			value: "\"Butterfly Kids\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Cabin",
			value: "Cabin, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Cabin Condensed",
			value: "\"Cabin Condensed\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Cabin Sketch",
			value: "\"Cabin Sketch\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Caesar Dressing",
			value: "\"Caesar Dressing\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Cagliostro",
			value: "Cagliostro, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Cairo",
			value: "Cairo, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Caladea",
			value: "Caladea, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Calistoga",
			value: "Calistoga, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Calligraffitti",
			value: "Calligraffitti, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Cambay",
			value: "Cambay, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Cambo",
			value: "Cambo, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Candal",
			value: "Candal, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Cantarell",
			value: "Cantarell, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Cantata One",
			value: "\"Cantata One\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Cantora One",
			value: "\"Cantora One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Capriola",
			value: "Capriola, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Cardo",
			value: "Cardo, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"greek",
				"greek-ext",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Carme",
			value: "Carme, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Carrois Gothic",
			value: "\"Carrois Gothic\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Carrois Gothic SC",
			value: "\"Carrois Gothic SC\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Carter One",
			value: "\"Carter One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Catamaran",
			value: "Catamaran, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"tamil"
			],
			category: "sans-serif"
		},
		{
			name: "Caudex",
			value: "Caudex, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"greek",
				"greek-ext",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Caveat",
			value: "Caveat, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Caveat Brush",
			value: "\"Caveat Brush\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Cedarville Cursive",
			value: "\"Cedarville Cursive\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Ceviche One",
			value: "\"Ceviche One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Chakra Petch",
			value: "\"Chakra Petch\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Changa",
			value: "Changa, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Changa One",
			value: "\"Changa One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Chango",
			value: "Chango, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Charm",
			value: "Charm, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Charmonman",
			value: "Charmonman, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Chathura",
			value: "Chathura, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "sans-serif"
		},
		{
			name: "Chau Philomene One",
			value: "\"Chau Philomene One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Chela One",
			value: "\"Chela One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Chelsea Market",
			value: "\"Chelsea Market\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Chenla",
			value: "Chenla, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Cherry Cream Soda",
			value: "\"Cherry Cream Soda\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Cherry Swash",
			value: "\"Cherry Swash\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Chewy",
			value: "Chewy, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Chicle",
			value: "Chicle, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Chilanka",
			value: "Chilanka, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"malayalam"
			],
			category: "handwriting"
		},
		{
			name: "Chivo",
			value: "Chivo, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Chonburi",
			value: "Chonburi, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Cinzel",
			value: "Cinzel, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Cinzel Decorative",
			value: "\"Cinzel Decorative\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Clicker Script",
			value: "\"Clicker Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Coda",
			value: "Coda, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Coda Caption",
			value: "\"Coda Caption\", sans-serif",
			variants: [
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Codystar",
			value: "Codystar, cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Coiny",
			value: "Coiny, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"tamil",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Combo",
			value: "Combo, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Comfortaa",
			value: "Comfortaa, cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Comic Neue",
			value: "\"Comic Neue\", cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Coming Soon",
			value: "\"Coming Soon\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Commissioner",
			value: "Commissioner, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Concert One",
			value: "\"Concert One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Condiment",
			value: "Condiment, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Content",
			value: "Content, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Contrail One",
			value: "\"Contrail One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Convergence",
			value: "Convergence, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Cookie",
			value: "Cookie, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Copse",
			value: "Copse, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Corben",
			value: "Corben, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Cormorant",
			value: "Cormorant, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Cormorant Garamond",
			value: "\"Cormorant Garamond\", serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Cormorant Infant",
			value: "\"Cormorant Infant\", serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Cormorant SC",
			value: "\"Cormorant SC\", serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Cormorant Unicase",
			value: "\"Cormorant Unicase\", serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Cormorant Upright",
			value: "\"Cormorant Upright\", serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Courgette",
			value: "Courgette, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Courier Prime",
			value: "\"Courier Prime\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "Cousine",
			value: "Cousine, monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"hebrew",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "monospace"
		},
		{
			name: "Coustard",
			value: "Coustard, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Covered By Your Grace",
			value: "\"Covered By Your Grace\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Crafty Girls",
			value: "\"Crafty Girls\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Creepster",
			value: "Creepster, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Crete Round",
			value: "\"Crete Round\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Crimson Pro",
			value: "\"Crimson Pro\", serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Crimson Text",
			value: "\"Crimson Text\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Croissant One",
			value: "\"Croissant One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Crushed",
			value: "Crushed, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Cuprum",
			value: "Cuprum, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Cute Font",
			value: "\"Cute Font\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "display"
		},
		{
			name: "Cutive",
			value: "Cutive, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Cutive Mono",
			value: "\"Cutive Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "DM Mono",
			value: "\"DM Mono\", monospace",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "DM Sans",
			value: "\"DM Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "DM Serif Display",
			value: "\"DM Serif Display\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "DM Serif Text",
			value: "\"DM Serif Text\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Damion",
			value: "Damion, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Dancing Script",
			value: "\"Dancing Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Dangrek",
			value: "Dangrek, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Darker Grotesque",
			value: "\"Darker Grotesque\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "David Libre",
			value: "\"David Libre\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"hebrew",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Dawning of a New Day",
			value: "\"Dawning of a New Day\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Days One",
			value: "\"Days One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Dekko",
			value: "Dekko, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Delius",
			value: "Delius, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Delius Swash Caps",
			value: "\"Delius Swash Caps\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Delius Unicase",
			value: "\"Delius Unicase\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Della Respira",
			value: "\"Della Respira\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Denk One",
			value: "\"Denk One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Devonshire",
			value: "Devonshire, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Dhurjati",
			value: "Dhurjati, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "sans-serif"
		},
		{
			name: "Didact Gothic",
			value: "\"Didact Gothic\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Diplomata",
			value: "Diplomata, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Diplomata SC",
			value: "\"Diplomata SC\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Do Hyeon",
			value: "\"Do Hyeon\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Dokdo",
			value: "Dokdo, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Domine",
			value: "Domine, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Donegal One",
			value: "\"Donegal One\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Doppio One",
			value: "\"Doppio One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Dorsa",
			value: "Dorsa, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Dosis",
			value: "Dosis, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Dr Sugiyama",
			value: "\"Dr Sugiyama\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Duru Sans",
			value: "\"Duru Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Dynalight",
			value: "Dynalight, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "EB Garamond",
			value: "\"EB Garamond\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Eagle Lake",
			value: "\"Eagle Lake\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "East Sea Dokdo",
			value: "\"East Sea Dokdo\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Eater",
			value: "Eater, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Economica",
			value: "Economica, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Eczar",
			value: "Eczar, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "El Messiri",
			value: "\"El Messiri\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"cyrillic",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Electrolize",
			value: "Electrolize, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Elsie",
			value: "Elsie, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Elsie Swash Caps",
			value: "\"Elsie Swash Caps\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Emblema One",
			value: "\"Emblema One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Emilys Candy",
			value: "\"Emilys Candy\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Encode Sans",
			value: "\"Encode Sans\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Encode Sans Condensed",
			value: "\"Encode Sans Condensed\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Encode Sans Expanded",
			value: "\"Encode Sans Expanded\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Encode Sans Semi Condensed",
			value: "\"Encode Sans Semi Condensed\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Encode Sans Semi Expanded",
			value: "\"Encode Sans Semi Expanded\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Engagement",
			value: "Engagement, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Englebert",
			value: "Englebert, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Enriqueta",
			value: "Enriqueta, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Epilogue",
			value: "Epilogue, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Erica One",
			value: "\"Erica One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Esteban",
			value: "Esteban, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Euphoria Script",
			value: "\"Euphoria Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Ewert",
			value: "Ewert, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Exo",
			value: "Exo, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Exo 2",
			value: "\"Exo 2\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Expletus Sans",
			value: "\"Expletus Sans\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Fahkwang",
			value: "Fahkwang, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Fanwood Text",
			value: "\"Fanwood Text\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Farro",
			value: "Farro, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Farsan",
			value: "Farsan, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"gujarati",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Fascinate",
			value: "Fascinate, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Fascinate Inline",
			value: "\"Fascinate Inline\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Faster One",
			value: "\"Faster One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Fasthand",
			value: "Fasthand, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "serif"
		},
		{
			name: "Fauna One",
			value: "\"Fauna One\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Faustina",
			value: "Faustina, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Federant",
			value: "Federant, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Federo",
			value: "Federo, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Felipa",
			value: "Felipa, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Fenix",
			value: "Fenix, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Finger Paint",
			value: "\"Finger Paint\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Fira Code",
			value: "\"Fira Code\", monospace",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "Fira Mono",
			value: "\"Fira Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "Fira Sans",
			value: "\"Fira Sans\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Fira Sans Condensed",
			value: "\"Fira Sans Condensed\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Fira Sans Extra Condensed",
			value: "\"Fira Sans Extra Condensed\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Fjalla One",
			value: "\"Fjalla One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Fjord One",
			value: "\"Fjord One\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Flamenco",
			value: "Flamenco, cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Flavors",
			value: "Flavors, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Fondamento",
			value: "Fondamento, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Fontdiner Swanky",
			value: "\"Fontdiner Swanky\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Forum",
			value: "Forum, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Francois One",
			value: "\"Francois One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Frank Ruhl Libre",
			value: "\"Frank Ruhl Libre\", serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"hebrew",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Freckle Face",
			value: "\"Freckle Face\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Fredericka the Great",
			value: "\"Fredericka the Great\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Fredoka One",
			value: "\"Fredoka One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Freehand",
			value: "Freehand, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Fresca",
			value: "Fresca, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Frijole",
			value: "Frijole, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Fruktur",
			value: "Fruktur, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Fugaz One",
			value: "\"Fugaz One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "GFS Didot",
			value: "\"GFS Didot\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"greek"
			],
			category: "serif"
		},
		{
			name: "GFS Neohellenic",
			value: "\"GFS Neohellenic\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"greek"
			],
			category: "sans-serif"
		},
		{
			name: "Gabriela",
			value: "Gabriela, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Gaegu",
			value: "Gaegu, cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Gafata",
			value: "Gafata, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Galada",
			value: "Galada, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"bengali",
				"latin"
			],
			category: "display"
		},
		{
			name: "Galdeano",
			value: "Galdeano, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Galindo",
			value: "Galindo, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Gamja Flower",
			value: "\"Gamja Flower\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Gayathri",
			value: "Gayathri, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"malayalam"
			],
			category: "sans-serif"
		},
		{
			name: "Gelasio",
			value: "Gelasio, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Gentium Basic",
			value: "\"Gentium Basic\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Gentium Book Basic",
			value: "\"Gentium Book Basic\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Geo",
			value: "Geo, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Geostar",
			value: "Geostar, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Geostar Fill",
			value: "\"Geostar Fill\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Germania One",
			value: "\"Germania One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Gidugu",
			value: "Gidugu, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "sans-serif"
		},
		{
			name: "Gilda Display",
			value: "\"Gilda Display\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Girassol",
			value: "Girassol, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Give You Glory",
			value: "\"Give You Glory\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Glass Antiqua",
			value: "\"Glass Antiqua\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Glegoo",
			value: "Glegoo, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Gloria Hallelujah",
			value: "\"Gloria Hallelujah\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Goblin One",
			value: "\"Goblin One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Gochi Hand",
			value: "\"Gochi Hand\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Goldman",
			value: "Goldman, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Gorditas",
			value: "Gorditas, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Gothic A1",
			value: "\"Gothic A1\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Gotu",
			value: "Gotu, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Goudy Bookletter 1911",
			value: "\"Goudy Bookletter 1911\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Graduate",
			value: "Graduate, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Grand Hotel",
			value: "\"Grand Hotel\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Grandstander",
			value: "Grandstander, cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Gravitas One",
			value: "\"Gravitas One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Great Vibes",
			value: "\"Great Vibes\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Grenze",
			value: "Grenze, serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Grenze Gotisch",
			value: "\"Grenze Gotisch\", cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Griffy",
			value: "Griffy, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Gruppo",
			value: "Gruppo, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Gudea",
			value: "Gudea, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Gugi",
			value: "Gugi, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "display"
		},
		{
			name: "Gupter",
			value: "Gupter, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Gurajada",
			value: "Gurajada, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "serif"
		},
		{
			name: "Habibi",
			value: "Habibi, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Halant",
			value: "Halant, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Hammersmith One",
			value: "\"Hammersmith One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Hanalei",
			value: "Hanalei, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Hanalei Fill",
			value: "\"Hanalei Fill\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Handlee",
			value: "Handlee, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Hanuman",
			value: "Hanuman, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"khmer"
			],
			category: "serif"
		},
		{
			name: "Happy Monkey",
			value: "\"Happy Monkey\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Harmattan",
			value: "Harmattan, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Headland One",
			value: "\"Headland One\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Heebo",
			value: "Heebo, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"hebrew",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Henny Penny",
			value: "\"Henny Penny\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Hepta Slab",
			value: "\"Hepta Slab\", serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Herr Von Muellerhoff",
			value: "\"Herr Von Muellerhoff\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Hi Melody",
			value: "\"Hi Melody\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Hind",
			value: "Hind, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Hind Guntur",
			value: "\"Hind Guntur\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"telugu"
			],
			category: "sans-serif"
		},
		{
			name: "Hind Madurai",
			value: "\"Hind Madurai\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"tamil"
			],
			category: "sans-serif"
		},
		{
			name: "Hind Siliguri",
			value: "\"Hind Siliguri\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"bengali",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Hind Vadodara",
			value: "\"Hind Vadodara\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"gujarati",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Holtwood One SC",
			value: "\"Holtwood One SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Homemade Apple",
			value: "\"Homemade Apple\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Homenaje",
			value: "Homenaje, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "IBM Plex Mono",
			value: "\"IBM Plex Mono\", monospace",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "monospace"
		},
		{
			name: "IBM Plex Sans",
			value: "\"IBM Plex Sans\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "IBM Plex Sans Condensed",
			value: "\"IBM Plex Sans Condensed\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "IBM Plex Serif",
			value: "\"IBM Plex Serif\", serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "IM Fell DW Pica",
			value: "\"IM Fell DW Pica\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "IM Fell DW Pica SC",
			value: "\"IM Fell DW Pica SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "IM Fell Double Pica",
			value: "\"IM Fell Double Pica\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "IM Fell Double Pica SC",
			value: "\"IM Fell Double Pica SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "IM Fell English",
			value: "\"IM Fell English\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "IM Fell English SC",
			value: "\"IM Fell English SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "IM Fell French Canon",
			value: "\"IM Fell French Canon\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "IM Fell French Canon SC",
			value: "\"IM Fell French Canon SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "IM Fell Great Primer",
			value: "\"IM Fell Great Primer\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "IM Fell Great Primer SC",
			value: "\"IM Fell Great Primer SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Ibarra Real Nova",
			value: "\"Ibarra Real Nova\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Iceberg",
			value: "Iceberg, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Iceland",
			value: "Iceland, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Imprima",
			value: "Imprima, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Inconsolata",
			value: "Inconsolata, monospace",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "monospace"
		},
		{
			name: "Inder",
			value: "Inder, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Indie Flower",
			value: "\"Indie Flower\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Inika",
			value: "Inika, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Inknut Antiqua",
			value: "\"Inknut Antiqua\", serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Inria Sans",
			value: "\"Inria Sans\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Inria Serif",
			value: "\"Inria Serif\", serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Inter",
			value: "Inter, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Irish Grover",
			value: "\"Irish Grover\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Istok Web",
			value: "\"Istok Web\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Italiana",
			value: "Italiana, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Italianno",
			value: "Italianno, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Itim",
			value: "Itim, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Jacques Francois",
			value: "\"Jacques Francois\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Jacques Francois Shadow",
			value: "\"Jacques Francois Shadow\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Jaldi",
			value: "Jaldi, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Jim Nightshade",
			value: "\"Jim Nightshade\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Jockey One",
			value: "\"Jockey One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Jolly Lodger",
			value: "\"Jolly Lodger\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Jomhuria",
			value: "Jomhuria, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Jomolhari",
			value: "Jomolhari, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"tibetan"
			],
			category: "serif"
		},
		{
			name: "Josefin Sans",
			value: "\"Josefin Sans\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Josefin Slab",
			value: "\"Josefin Slab\", serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Jost",
			value: "Jost, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Joti One",
			value: "\"Joti One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Jua",
			value: "Jua, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Judson",
			value: "Judson, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Julee",
			value: "Julee, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Julius Sans One",
			value: "\"Julius Sans One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Junge",
			value: "Junge, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Jura",
			value: "Jura, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Just Another Hand",
			value: "\"Just Another Hand\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Just Me Again Down Here",
			value: "\"Just Me Again Down Here\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "K2D",
			value: "K2D, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Kadwa",
			value: "Kadwa, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Kalam",
			value: "Kalam, cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Kameron",
			value: "Kameron, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Kanit",
			value: "Kanit, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Kantumruy",
			value: "Kantumruy, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"khmer"
			],
			category: "sans-serif"
		},
		{
			name: "Karla",
			value: "Karla, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Karma",
			value: "Karma, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Katibeh",
			value: "Katibeh, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Kaushan Script",
			value: "\"Kaushan Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Kavivanar",
			value: "Kavivanar, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"tamil"
			],
			category: "handwriting"
		},
		{
			name: "Kavoon",
			value: "Kavoon, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Kdam Thmor",
			value: "\"Kdam Thmor\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Keania One",
			value: "\"Keania One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Kelly Slab",
			value: "\"Kelly Slab\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Kenia",
			value: "Kenia, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Khand",
			value: "Khand, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Khmer",
			value: "Khmer, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Khula",
			value: "Khula, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Kirang Haerang",
			value: "\"Kirang Haerang\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "display"
		},
		{
			name: "Kite One",
			value: "\"Kite One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Knewave",
			value: "Knewave, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "KoHo",
			value: "KoHo, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Kodchasan",
			value: "Kodchasan, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Kosugi",
			value: "Kosugi, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"japanese",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Kosugi Maru",
			value: "\"Kosugi Maru\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"japanese",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Kotta One",
			value: "\"Kotta One\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Koulen",
			value: "Koulen, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Kranky",
			value: "Kranky, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Kreon",
			value: "Kreon, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Kristi",
			value: "Kristi, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Krona One",
			value: "\"Krona One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Krub",
			value: "Krub, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Kufam",
			value: "Kufam, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Kulim Park",
			value: "\"Kulim Park\", sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Kumar One",
			value: "\"Kumar One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"gujarati",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Kumar One Outline",
			value: "\"Kumar One Outline\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"gujarati",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Kumbh Sans",
			value: "\"Kumbh Sans\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Kurale",
			value: "Kurale, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "La Belle Aurore",
			value: "\"La Belle Aurore\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Lacquer",
			value: "Lacquer, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Laila",
			value: "Laila, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Lakki Reddy",
			value: "\"Lakki Reddy\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "handwriting"
		},
		{
			name: "Lalezar",
			value: "Lalezar, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Lancelot",
			value: "Lancelot, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Lateef",
			value: "Lateef, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"arabic",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Lato",
			value: "Lato, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "League Script",
			value: "\"League Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Leckerli One",
			value: "\"Leckerli One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Ledger",
			value: "Ledger, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Lekton",
			value: "Lekton, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Lemon",
			value: "Lemon, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Lemonada",
			value: "Lemonada, cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Lexend Deca",
			value: "\"Lexend Deca\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Lexend Exa",
			value: "\"Lexend Exa\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Lexend Giga",
			value: "\"Lexend Giga\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Lexend Mega",
			value: "\"Lexend Mega\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Lexend Peta",
			value: "\"Lexend Peta\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Lexend Tera",
			value: "\"Lexend Tera\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Lexend Zetta",
			value: "\"Lexend Zetta\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Libre Barcode 128",
			value: "\"Libre Barcode 128\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Libre Barcode 128 Text",
			value: "\"Libre Barcode 128 Text\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Libre Barcode 39",
			value: "\"Libre Barcode 39\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Libre Barcode 39 Extended",
			value: "\"Libre Barcode 39 Extended\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Libre Barcode 39 Extended Text",
			value: "\"Libre Barcode 39 Extended Text\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Libre Barcode 39 Text",
			value: "\"Libre Barcode 39 Text\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Libre Barcode EAN13 Text",
			value: "\"Libre Barcode EAN13 Text\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Libre Baskerville",
			value: "\"Libre Baskerville\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Libre Caslon Display",
			value: "\"Libre Caslon Display\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Libre Caslon Text",
			value: "\"Libre Caslon Text\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Libre Franklin",
			value: "\"Libre Franklin\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Life Savers",
			value: "\"Life Savers\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Lilita One",
			value: "\"Lilita One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Lily Script One",
			value: "\"Lily Script One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Limelight",
			value: "Limelight, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Linden Hill",
			value: "\"Linden Hill\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Literata",
			value: "Literata, serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Liu Jian Mao Cao",
			value: "\"Liu Jian Mao Cao\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"chinese-simplified",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Livvic",
			value: "Livvic, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Lobster",
			value: "Lobster, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Lobster Two",
			value: "\"Lobster Two\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Londrina Outline",
			value: "\"Londrina Outline\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Londrina Shadow",
			value: "\"Londrina Shadow\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Londrina Sketch",
			value: "\"Londrina Sketch\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Londrina Solid",
			value: "\"Londrina Solid\", cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Long Cang",
			value: "\"Long Cang\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"chinese-simplified",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Lora",
			value: "Lora, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Love Ya Like A Sister",
			value: "\"Love Ya Like A Sister\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Loved by the King",
			value: "\"Loved by the King\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Lovers Quarrel",
			value: "\"Lovers Quarrel\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Luckiest Guy",
			value: "\"Luckiest Guy\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Lusitana",
			value: "Lusitana, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Lustria",
			value: "Lustria, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "M PLUS 1p",
			value: "\"M PLUS 1p\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"hebrew",
				"japanese",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "M PLUS Rounded 1c",
			value: "\"M PLUS Rounded 1c\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"hebrew",
				"japanese",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Ma Shan Zheng",
			value: "\"Ma Shan Zheng\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"chinese-simplified",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Macondo",
			value: "Macondo, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Macondo Swash Caps",
			value: "\"Macondo Swash Caps\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Mada",
			value: "Mada, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Magra",
			value: "Magra, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Maiden Orange",
			value: "\"Maiden Orange\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Maitree",
			value: "Maitree, serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Major Mono Display",
			value: "\"Major Mono Display\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "monospace"
		},
		{
			name: "Mako",
			value: "Mako, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Mali",
			value: "Mali, cursive",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Mallanna",
			value: "Mallanna, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "sans-serif"
		},
		{
			name: "Mandali",
			value: "Mandali, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "sans-serif"
		},
		{
			name: "Manjari",
			value: "Manjari, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"malayalam"
			],
			category: "sans-serif"
		},
		{
			name: "Manrope",
			value: "Manrope, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"greek",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Mansalva",
			value: "Mansalva, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Manuale",
			value: "Manuale, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Marcellus",
			value: "Marcellus, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Marcellus SC",
			value: "\"Marcellus SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Marck Script",
			value: "\"Marck Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Margarine",
			value: "Margarine, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Markazi Text",
			value: "\"Markazi Text\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Marko One",
			value: "\"Marko One\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Marmelad",
			value: "Marmelad, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Martel",
			value: "Martel, serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Martel Sans",
			value: "\"Martel Sans\", sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Marvel",
			value: "Marvel, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Mate",
			value: "Mate, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Mate SC",
			value: "\"Mate SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Maven Pro",
			value: "\"Maven Pro\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "McLaren",
			value: "McLaren, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Meddon",
			value: "Meddon, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "MedievalSharp",
			value: "MedievalSharp, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Medula One",
			value: "\"Medula One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Meera Inimai",
			value: "\"Meera Inimai\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"tamil"
			],
			category: "sans-serif"
		},
		{
			name: "Megrim",
			value: "Megrim, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Meie Script",
			value: "\"Meie Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Merienda",
			value: "Merienda, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Merienda One",
			value: "\"Merienda One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Merriweather",
			value: "Merriweather, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Merriweather Sans",
			value: "\"Merriweather Sans\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Metal",
			value: "Metal, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Metal Mania",
			value: "\"Metal Mania\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Metamorphous",
			value: "Metamorphous, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Metrophobic",
			value: "Metrophobic, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Michroma",
			value: "Michroma, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Milonga",
			value: "Milonga, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Miltonian",
			value: "Miltonian, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Miltonian Tattoo",
			value: "\"Miltonian Tattoo\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Mina",
			value: "Mina, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"bengali",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Miniver",
			value: "Miniver, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Miriam Libre",
			value: "\"Miriam Libre\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"hebrew",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Mirza",
			value: "Mirza, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Miss Fajardose",
			value: "\"Miss Fajardose\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Mitr",
			value: "Mitr, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Modak",
			value: "Modak, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Modern Antiqua",
			value: "\"Modern Antiqua\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Mogra",
			value: "Mogra, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"gujarati",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Molengo",
			value: "Molengo, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Molle",
			value: "Molle, cursive",
			variants: [
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Monda",
			value: "Monda, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Monofett",
			value: "Monofett, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Monoton",
			value: "Monoton, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Monsieur La Doulaise",
			value: "\"Monsieur La Doulaise\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Montaga",
			value: "Montaga, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Montez",
			value: "Montez, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Montserrat",
			value: "Montserrat, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Montserrat Alternates",
			value: "\"Montserrat Alternates\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Montserrat Subrayada",
			value: "\"Montserrat Subrayada\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Moul",
			value: "Moul, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Moulpali",
			value: "Moulpali, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Mountains of Christmas",
			value: "\"Mountains of Christmas\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Mouse Memoirs",
			value: "\"Mouse Memoirs\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Mr Bedfort",
			value: "\"Mr Bedfort\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Mr Dafoe",
			value: "\"Mr Dafoe\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Mr De Haviland",
			value: "\"Mr De Haviland\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Mrs Saint Delafield",
			value: "\"Mrs Saint Delafield\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Mrs Sheppards",
			value: "\"Mrs Sheppards\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Mukta",
			value: "Mukta, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Mukta Mahee",
			value: "\"Mukta Mahee\", sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"gurmukhi",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Mukta Malar",
			value: "\"Mukta Malar\", sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"tamil"
			],
			category: "sans-serif"
		},
		{
			name: "Mukta Vaani",
			value: "\"Mukta Vaani\", sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"gujarati",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Mulish",
			value: "Mulish, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "MuseoModerno",
			value: "MuseoModerno, cursive",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Mystery Quest",
			value: "\"Mystery Quest\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "NTR",
			value: "NTR, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "sans-serif"
		},
		{
			name: "Nanum Brush Script",
			value: "\"Nanum Brush Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Nanum Gothic",
			value: "\"Nanum Gothic\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Nanum Gothic Coding",
			value: "\"Nanum Gothic Coding\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "monospace"
		},
		{
			name: "Nanum Myeongjo",
			value: "\"Nanum Myeongjo\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Nanum Pen Script",
			value: "\"Nanum Pen Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Neucha",
			value: "Neucha, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Neuton",
			value: "Neuton, serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "New Rocker",
			value: "\"New Rocker\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "News Cycle",
			value: "\"News Cycle\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Niconne",
			value: "Niconne, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Niramit",
			value: "Niramit, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Nixie One",
			value: "\"Nixie One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Nobile",
			value: "Nobile, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Nokora",
			value: "Nokora, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"khmer"
			],
			category: "serif"
		},
		{
			name: "Norican",
			value: "Norican, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Nosifer",
			value: "Nosifer, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Notable",
			value: "Notable, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Nothing You Could Do",
			value: "\"Nothing You Could Do\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Noticia Text",
			value: "\"Noticia Text\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Noto Sans",
			value: "\"Noto Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"devanagari",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Noto Sans HK",
			value: "\"Noto Sans HK\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"chinese-hongkong",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Noto Sans JP",
			value: "\"Noto Sans JP\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"japanese",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Noto Sans KR",
			value: "\"Noto Sans KR\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Noto Sans SC",
			value: "\"Noto Sans SC\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"chinese-simplified",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Noto Sans TC",
			value: "\"Noto Sans TC\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"chinese-traditional",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Noto Serif",
			value: "\"Noto Serif\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Noto Serif JP",
			value: "\"Noto Serif JP\", serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"japanese",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Noto Serif KR",
			value: "\"Noto Serif KR\", serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Noto Serif SC",
			value: "\"Noto Serif SC\", serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"chinese-simplified",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Noto Serif TC",
			value: "\"Noto Serif TC\", serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"chinese-traditional",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Nova Cut",
			value: "\"Nova Cut\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Nova Flat",
			value: "\"Nova Flat\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Nova Mono",
			value: "\"Nova Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"greek",
				"latin"
			],
			category: "monospace"
		},
		{
			name: "Nova Oval",
			value: "\"Nova Oval\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Nova Round",
			value: "\"Nova Round\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Nova Script",
			value: "\"Nova Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Nova Slim",
			value: "\"Nova Slim\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Nova Square",
			value: "\"Nova Square\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Numans",
			value: "Numans, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Nunito",
			value: "Nunito, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Nunito Sans",
			value: "\"Nunito Sans\", sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Odibee Sans",
			value: "\"Odibee Sans\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Odor Mean Chey",
			value: "\"Odor Mean Chey\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Offside",
			value: "Offside, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Old Standard TT",
			value: "\"Old Standard TT\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Oldenburg",
			value: "Oldenburg, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Oleo Script",
			value: "\"Oleo Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Oleo Script Swash Caps",
			value: "\"Oleo Script Swash Caps\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Open Sans",
			value: "\"Open Sans\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Open Sans Condensed",
			value: "\"Open Sans Condensed\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Oranienbaum",
			value: "Oranienbaum, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Orbitron",
			value: "Orbitron, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Oregano",
			value: "Oregano, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Orienta",
			value: "Orienta, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Original Surfer",
			value: "\"Original Surfer\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Oswald",
			value: "Oswald, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Over the Rainbow",
			value: "\"Over the Rainbow\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Overlock",
			value: "Overlock, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Overlock SC",
			value: "\"Overlock SC\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Overpass",
			value: "Overpass, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Overpass Mono",
			value: "\"Overpass Mono\", monospace",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "Ovo",
			value: "Ovo, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Oxanium",
			value: "Oxanium, cursive",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Oxygen",
			value: "Oxygen, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Oxygen Mono",
			value: "\"Oxygen Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "PT Mono",
			value: "\"PT Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "PT Sans",
			value: "\"PT Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "PT Sans Caption",
			value: "\"PT Sans Caption\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "PT Sans Narrow",
			value: "\"PT Sans Narrow\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "PT Serif",
			value: "\"PT Serif\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "PT Serif Caption",
			value: "\"PT Serif Caption\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Pacifico",
			value: "Pacifico, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Padauk",
			value: "Padauk, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"myanmar"
			],
			category: "sans-serif"
		},
		{
			name: "Palanquin",
			value: "Palanquin, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Palanquin Dark",
			value: "\"Palanquin Dark\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Pangolin",
			value: "Pangolin, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Paprika",
			value: "Paprika, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Parisienne",
			value: "Parisienne, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Passero One",
			value: "\"Passero One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Passion One",
			value: "\"Passion One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Pathway Gothic One",
			value: "\"Pathway Gothic One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Patrick Hand",
			value: "\"Patrick Hand\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Patrick Hand SC",
			value: "\"Patrick Hand SC\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Pattaya",
			value: "Pattaya, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Patua One",
			value: "\"Patua One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Pavanam",
			value: "Pavanam, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"tamil"
			],
			category: "sans-serif"
		},
		{
			name: "Paytone One",
			value: "\"Paytone One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Peddana",
			value: "Peddana, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "serif"
		},
		{
			name: "Peralta",
			value: "Peralta, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Permanent Marker",
			value: "\"Permanent Marker\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Petit Formal Script",
			value: "\"Petit Formal Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Petrona",
			value: "Petrona, serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Philosopher",
			value: "Philosopher, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Piazzolla",
			value: "Piazzolla, serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Piedra",
			value: "Piedra, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Pinyon Script",
			value: "\"Pinyon Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Pirata One",
			value: "\"Pirata One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Plaster",
			value: "Plaster, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Play",
			value: "Play, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Playball",
			value: "Playball, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Playfair Display",
			value: "\"Playfair Display\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Playfair Display SC",
			value: "\"Playfair Display SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Podkova",
			value: "Podkova, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Poiret One",
			value: "\"Poiret One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Poller One",
			value: "\"Poller One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Poly",
			value: "Poly, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Pompiere",
			value: "Pompiere, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Pontano Sans",
			value: "\"Pontano Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Poor Story",
			value: "\"Poor Story\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "display"
		},
		{
			name: "Poppins",
			value: "Poppins, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Port Lligat Sans",
			value: "\"Port Lligat Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Port Lligat Slab",
			value: "\"Port Lligat Slab\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Pragati Narrow",
			value: "\"Pragati Narrow\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Prata",
			value: "Prata, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Preahvihear",
			value: "Preahvihear, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Press Start 2P",
			value: "\"Press Start 2P\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Pridi",
			value: "Pridi, serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Princess Sofia",
			value: "\"Princess Sofia\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Prociono",
			value: "Prociono, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Prompt",
			value: "Prompt, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Prosto One",
			value: "\"Prosto One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Proza Libre",
			value: "\"Proza Libre\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Public Sans",
			value: "\"Public Sans\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Puritan",
			value: "Puritan, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Purple Purse",
			value: "\"Purple Purse\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Quando",
			value: "Quando, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Quantico",
			value: "Quantico, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Quattrocento",
			value: "Quattrocento, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Quattrocento Sans",
			value: "\"Quattrocento Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Questrial",
			value: "Questrial, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Quicksand",
			value: "Quicksand, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Quintessential",
			value: "Quintessential, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Qwigley",
			value: "Qwigley, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Racing Sans One",
			value: "\"Racing Sans One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Radley",
			value: "Radley, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Rajdhani",
			value: "Rajdhani, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Rakkas",
			value: "Rakkas, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"arabic",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Raleway",
			value: "Raleway, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Raleway Dots",
			value: "\"Raleway Dots\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Ramabhadra",
			value: "Ramabhadra, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "sans-serif"
		},
		{
			name: "Ramaraja",
			value: "Ramaraja, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "serif"
		},
		{
			name: "Rambla",
			value: "Rambla, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Rammetto One",
			value: "\"Rammetto One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Ranchers",
			value: "Ranchers, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Rancho",
			value: "Rancho, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Ranga",
			value: "Ranga, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Rasa",
			value: "Rasa, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"gujarati",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Rationale",
			value: "Rationale, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Ravi Prakash",
			value: "\"Ravi Prakash\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "display"
		},
		{
			name: "Recursive",
			value: "Recursive, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Red Hat Display",
			value: "\"Red Hat Display\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Red Hat Text",
			value: "\"Red Hat Text\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Red Rose",
			value: "\"Red Rose\", cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Redressed",
			value: "Redressed, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Reem Kufi",
			value: "\"Reem Kufi\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"arabic",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Reenie Beanie",
			value: "\"Reenie Beanie\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Revalia",
			value: "Revalia, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Rhodium Libre",
			value: "\"Rhodium Libre\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Ribeye",
			value: "Ribeye, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Ribeye Marrow",
			value: "\"Ribeye Marrow\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Righteous",
			value: "Righteous, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Risque",
			value: "Risque, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Roboto",
			value: "Roboto, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Roboto Condensed",
			value: "\"Roboto Condensed\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Roboto Mono",
			value: "\"Roboto Mono\", monospace",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "monospace"
		},
		{
			name: "Roboto Slab",
			value: "\"Roboto Slab\", serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Rochester",
			value: "Rochester, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Rock Salt",
			value: "\"Rock Salt\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Rokkitt",
			value: "Rokkitt, serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Romanesco",
			value: "Romanesco, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Ropa Sans",
			value: "\"Ropa Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Rosario",
			value: "Rosario, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Rosarivo",
			value: "Rosarivo, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Rouge Script",
			value: "\"Rouge Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Rowdies",
			value: "Rowdies, cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Rozha One",
			value: "\"Rozha One\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Rubik",
			value: "Rubik, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"hebrew",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Rubik Mono One",
			value: "\"Rubik Mono One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Ruda",
			value: "Ruda, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Rufina",
			value: "Rufina, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Ruge Boogie",
			value: "\"Ruge Boogie\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Ruluko",
			value: "Ruluko, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Rum Raisin",
			value: "\"Rum Raisin\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Ruslan Display",
			value: "\"Ruslan Display\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Russo One",
			value: "\"Russo One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Ruthie",
			value: "Ruthie, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Rye",
			value: "Rye, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Sacramento",
			value: "Sacramento, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Sahitya",
			value: "Sahitya, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Sail",
			value: "Sail, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Saira",
			value: "Saira, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Saira Condensed",
			value: "\"Saira Condensed\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Saira Extra Condensed",
			value: "\"Saira Extra Condensed\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Saira Semi Condensed",
			value: "\"Saira Semi Condensed\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Saira Stencil One",
			value: "\"Saira Stencil One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Salsa",
			value: "Salsa, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Sanchez",
			value: "Sanchez, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Sancreek",
			value: "Sancreek, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Sansita",
			value: "Sansita, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Sansita Swashed",
			value: "\"Sansita Swashed\", cursive",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Sarabun",
			value: "Sarabun, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Sarala",
			value: "Sarala, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Sarina",
			value: "Sarina, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Sarpanch",
			value: "Sarpanch, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Satisfy",
			value: "Satisfy, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Sawarabi Gothic",
			value: "\"Sawarabi Gothic\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"japanese",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Sawarabi Mincho",
			value: "\"Sawarabi Mincho\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"japanese",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Scada",
			value: "Scada, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Scheherazade",
			value: "Scheherazade, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Schoolbell",
			value: "Schoolbell, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Scope One",
			value: "\"Scope One\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Seaweed Script",
			value: "\"Seaweed Script\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Secular One",
			value: "\"Secular One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"hebrew",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Sedgwick Ave",
			value: "\"Sedgwick Ave\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Sedgwick Ave Display",
			value: "\"Sedgwick Ave Display\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Sen",
			value: "Sen, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Sevillana",
			value: "Sevillana, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Seymour One",
			value: "\"Seymour One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Shadows Into Light",
			value: "\"Shadows Into Light\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Shadows Into Light Two",
			value: "\"Shadows Into Light Two\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Shanti",
			value: "Shanti, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Share",
			value: "Share, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Share Tech",
			value: "\"Share Tech\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Share Tech Mono",
			value: "\"Share Tech Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "monospace"
		},
		{
			name: "Shojumaru",
			value: "Shojumaru, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Short Stack",
			value: "\"Short Stack\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Shrikhand",
			value: "Shrikhand, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"gujarati",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Siemreap",
			value: "Siemreap, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Sigmar One",
			value: "\"Sigmar One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Signika",
			value: "Signika, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Signika Negative",
			value: "\"Signika Negative\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Simonetta",
			value: "Simonetta, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Single Day",
			value: "\"Single Day\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean"
			],
			category: "display"
		},
		{
			name: "Sintony",
			value: "Sintony, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Sirin Stencil",
			value: "\"Sirin Stencil\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Six Caps",
			value: "\"Six Caps\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Skranji",
			value: "Skranji, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Slabo 13px",
			value: "\"Slabo 13px\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Slabo 27px",
			value: "\"Slabo 27px\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Slackey",
			value: "Slackey, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Smokum",
			value: "Smokum, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Smythe",
			value: "Smythe, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Sniglet",
			value: "Sniglet, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Snippet",
			value: "Snippet, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Snowburst One",
			value: "\"Snowburst One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Sofadi One",
			value: "\"Sofadi One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Sofia",
			value: "Sofia, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Solway",
			value: "Solway, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Song Myung",
			value: "\"Song Myung\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Sonsie One",
			value: "\"Sonsie One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Sora",
			value: "Sora, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Sorts Mill Goudy",
			value: "\"Sorts Mill Goudy\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Source Code Pro",
			value: "\"Source Code Pro\", monospace",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "monospace"
		},
		{
			name: "Source Sans Pro",
			value: "\"Source Sans Pro\", sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Source Serif Pro",
			value: "\"Source Serif Pro\", serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Space Grotesk",
			value: "\"Space Grotesk\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Space Mono",
			value: "\"Space Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "monospace"
		},
		{
			name: "Spartan",
			value: "Spartan, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Special Elite",
			value: "\"Special Elite\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Spectral",
			value: "Spectral, serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Spectral SC",
			value: "\"Spectral SC\", serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Spicy Rice",
			value: "\"Spicy Rice\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Spinnaker",
			value: "Spinnaker, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Spirax",
			value: "Spirax, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Squada One",
			value: "\"Squada One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Sree Krushnadevaraya",
			value: "\"Sree Krushnadevaraya\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "serif"
		},
		{
			name: "Sriracha",
			value: "Sriracha, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "handwriting"
		},
		{
			name: "Srisakdi",
			value: "Srisakdi, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Staatliches",
			value: "Staatliches, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Stalemate",
			value: "Stalemate, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Stalinist One",
			value: "\"Stalinist One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Stardos Stencil",
			value: "\"Stardos Stencil\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Stint Ultra Condensed",
			value: "\"Stint Ultra Condensed\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Stint Ultra Expanded",
			value: "\"Stint Ultra Expanded\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Stoke",
			value: "Stoke, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Strait",
			value: "Strait, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Stylish",
			value: "Stylish, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Sue Ellen Francisco",
			value: "\"Sue Ellen Francisco\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Suez One",
			value: "\"Suez One\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"hebrew",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Sulphur Point",
			value: "\"Sulphur Point\", sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Sumana",
			value: "Sumana, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Sunflower",
			value: "Sunflower, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Sunshiney",
			value: "Sunshiney, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Supermercado One",
			value: "\"Supermercado One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Sura",
			value: "Sura, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Suranna",
			value: "Suranna, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "serif"
		},
		{
			name: "Suravaram",
			value: "Suravaram, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "serif"
		},
		{
			name: "Suwannaphum",
			value: "Suwannaphum, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Swanky and Moo Moo",
			value: "\"Swanky and Moo Moo\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Syncopate",
			value: "Syncopate, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Syne",
			value: "Syne, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Syne Mono",
			value: "\"Syne Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "Syne Tactile",
			value: "\"Syne Tactile\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Tajawal",
			value: "Tajawal, sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"arabic",
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Tangerine",
			value: "Tangerine, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Taprom",
			value: "Taprom, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"khmer"
			],
			category: "display"
		},
		{
			name: "Tauri",
			value: "Tauri, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Taviraj",
			value: "Taviraj, serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Teko",
			value: "Teko, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Telex",
			value: "Telex, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Tenali Ramakrishna",
			value: "\"Tenali Ramakrishna\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "sans-serif"
		},
		{
			name: "Tenor Sans",
			value: "\"Tenor Sans\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Text Me One",
			value: "\"Text Me One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Thasadith",
			value: "Thasadith, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "The Girl Next Door",
			value: "\"The Girl Next Door\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Tienne",
			value: "Tienne, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Tillana",
			value: "Tillana, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "handwriting"
		},
		{
			name: "Timmana",
			value: "Timmana, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"telugu"
			],
			category: "sans-serif"
		},
		{
			name: "Tinos",
			value: "Tinos, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"hebrew",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Titan One",
			value: "\"Titan One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Titillium Web",
			value: "\"Titillium Web\", sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Tomorrow",
			value: "Tomorrow, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Trade Winds",
			value: "\"Trade Winds\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Trirong",
			value: "Trirong, serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"thai",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Trispace",
			value: "Trispace, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Trocchi",
			value: "Trocchi, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Trochut",
			value: "Trochut, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Trykker",
			value: "Trykker, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Tulpen One",
			value: "\"Tulpen One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Turret Road",
			value: "\"Turret Road\", cursive",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Ubuntu",
			value: "Ubuntu, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Ubuntu Condensed",
			value: "\"Ubuntu Condensed\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Ubuntu Mono",
			value: "\"Ubuntu Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"greek-ext",
				"latin",
				"latin-ext"
			],
			category: "monospace"
		},
		{
			name: "Ultra",
			value: "Ultra, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Uncial Antiqua",
			value: "\"Uncial Antiqua\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Underdog",
			value: "Underdog, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Unica One",
			value: "\"Unica One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "UnifrakturCook",
			value: "UnifrakturCook, cursive",
			variants: [
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "UnifrakturMaguntia",
			value: "UnifrakturMaguntia, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Unkempt",
			value: "Unkempt, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Unlock",
			value: "Unlock, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Unna",
			value: "Unna, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "VT323",
			value: "VT323, monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "monospace"
		},
		{
			name: "Vampiro One",
			value: "\"Vampiro One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Varela",
			value: "Varela, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Varela Round",
			value: "\"Varela Round\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"hebrew",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Varta",
			value: "Varta, sans-serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Vast Shadow",
			value: "\"Vast Shadow\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Vesper Libre",
			value: "\"Vesper Libre\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Viaoda Libre",
			value: "\"Viaoda Libre\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Vibes",
			value: "Vibes, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"arabic",
				"latin"
			],
			category: "display"
		},
		{
			name: "Vibur",
			value: "Vibur, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Vidaloka",
			value: "Vidaloka, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Viga",
			value: "Viga, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Voces",
			value: "Voces, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Volkhov",
			value: "Volkhov, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin"
			],
			category: "serif"
		},
		{
			name: "Vollkorn",
			value: "Vollkorn, serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"greek",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Vollkorn SC",
			value: "\"Vollkorn SC\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "serif"
		},
		{
			name: "Voltaire",
			value: "Voltaire, sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Waiting for the Sunrise",
			value: "\"Waiting for the Sunrise\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Wallpoet",
			value: "Wallpoet, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "display"
		},
		{
			name: "Walter Turncoat",
			value: "\"Walter Turncoat\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Warnes",
			value: "Warnes, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Wellfleet",
			value: "Wellfleet, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Wendy One",
			value: "\"Wendy One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Wire One",
			value: "\"Wire One\", sans-serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "sans-serif"
		},
		{
			name: "Work Sans",
			value: "\"Work Sans\", sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800",
					ital: false,
					wght: "800",
					vale: "800",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				},
				{
					name: "Thin 100 italic",
					ital: true,
					wght: "100",
					vale: "100i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-light 200 italic",
					ital: true,
					wght: "200",
					vale: "200i",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				},
				{
					name: "Extra-bold 800 italic",
					ital: true,
					wght: "800",
					vale: "800i",
					selc: false,
					disb: false
				},
				{
					name: "Black 900 italic",
					ital: true,
					wght: "900",
					vale: "900i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Xanh Mono",
			value: "\"Xanh Mono\", monospace",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "monospace"
		},
		{
			name: "Yanone Kaffeesatz",
			value: "\"Yanone Kaffeesatz\", sans-serif",
			variants: [
				{
					name: "Extra-light 200",
					ital: false,
					wght: "200",
					vale: "200",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"cyrillic",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "sans-serif"
		},
		{
			name: "Yantramanav",
			value: "Yantramanav, sans-serif",
			variants: [
				{
					name: "Thin 100",
					ital: false,
					wght: "100",
					vale: "100",
					selc: false,
					disb: false
				},
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Black 900",
					ital: false,
					wght: "900",
					vale: "900",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "sans-serif"
		},
		{
			name: "Yatra One",
			value: "\"Yatra One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"devanagari",
				"latin",
				"latin-ext"
			],
			category: "display"
		},
		{
			name: "Yellowtail",
			value: "Yellowtail, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Yeon Sung",
			value: "\"Yeon Sung\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"korean",
				"latin"
			],
			category: "display"
		},
		{
			name: "Yeseva One",
			value: "\"Yeseva One\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"cyrillic",
				"cyrillic-ext",
				"latin",
				"latin-ext",
				"vietnamese"
			],
			category: "display"
		},
		{
			name: "Yesteryear",
			value: "Yesteryear, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Yrsa",
			value: "Yrsa, serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "ZCOOL KuaiLe",
			value: "\"ZCOOL KuaiLe\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"chinese-simplified",
				"latin"
			],
			category: "display"
		},
		{
			name: "ZCOOL QingKe HuangYou",
			value: "\"ZCOOL QingKe HuangYou\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"chinese-simplified",
				"latin"
			],
			category: "display"
		},
		{
			name: "ZCOOL XiaoWei",
			value: "\"ZCOOL XiaoWei\", serif",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"chinese-simplified",
				"latin"
			],
			category: "serif"
		},
		{
			name: "Zeyada",
			value: "Zeyada, cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Zhi Mang Xing",
			value: "\"Zhi Mang Xing\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				}
			],
			subsets: [
				"chinese-simplified",
				"latin"
			],
			category: "handwriting"
		},
		{
			name: "Zilla Slab",
			value: "\"Zilla Slab\", serif",
			variants: [
				{
					name: "Light 300",
					ital: false,
					wght: "300",
					vale: "300",
					selc: false,
					disb: false
				},
				{
					name: "Light 300 italic",
					ital: true,
					wght: "300",
					vale: "300i",
					selc: false,
					disb: false
				},
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Regular 400 italic",
					ital: true,
					wght: "400",
					vale: "400i",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500",
					ital: false,
					wght: "500",
					vale: "500",
					selc: false,
					disb: false
				},
				{
					name: "Medium 500 italic",
					ital: true,
					wght: "500",
					vale: "500i",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600",
					ital: false,
					wght: "600",
					vale: "600",
					selc: false,
					disb: false
				},
				{
					name: "Semi-bold 600 italic",
					ital: true,
					wght: "600",
					vale: "600i",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				},
				{
					name: "Bold 700 italic",
					ital: true,
					wght: "700",
					vale: "700i",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "serif"
		},
		{
			name: "Zilla Slab Highlight",
			value: "\"Zilla Slab Highlight\", cursive",
			variants: [
				{
					name: "Regular 400",
					ital: false,
					wght: "400",
					vale: "400",
					selc: true,
					disb: true
				},
				{
					name: "Bold 700",
					ital: false,
					wght: "700",
					vale: "700",
					selc: false,
					disb: false
				}
			],
			subsets: [
				"latin",
				"latin-ext"
			],
			category: "display"
		}
	];
	var categories = [
		{
			id: "sans-serif",
			name: "Sans Serif"
		},
		{
			id: "serif",
			name: "Serif"
		},
		{
			id: "display",
			name: "Display"
		},
		{
			id: "handwriting",
			name: "Handwriting"
		},
		{
			id: "monospace",
			name: "Monospace"
		}
	];
	var languages = [
		{
			id: "latin",
			name: "Latin"
		},
		{
			id: "latin-ext",
			name: "Latin (Ext)"
		},
		{
			id: "sinhala",
			name: "Sinhala"
		},
		{
			id: "greek",
			name: "Greek"
		},
		{
			id: "vietnamese",
			name: "Vietnamese"
		},
		{
			id: "hebrew",
			name: "Hebrew"
		},
		{
			id: "cyrillic",
			name: "Cyrillic"
		},
		{
			id: "cyrillic-ext",
			name: "Cyrillic (Ext)"
		},
		{
			id: "greek-ext",
			name: "Greek (Ext)"
		},
		{
			id: "arabic",
			name: "Arabic"
		},
		{
			id: "devanagari",
			name: "Devanagari"
		},
		{
			id: "khmer",
			name: "Khmer"
		},
		{
			id: "tamil",
			name: "Tamil"
		},
		{
			id: "thai",
			name: "Thai"
		},
		{
			id: "bengali",
			name: "Bengali"
		},
		{
			id: "gujarati",
			name: "Gujarati"
		},
		{
			id: "oriya",
			name: "Oriya"
		},
		{
			id: "malayalam",
			name: "Malayalam"
		},
		{
			id: "gurmukhi",
			name: "Gurmukhi"
		},
		{
			id: "kannada",
			name: "Kannada"
		},
		{
			id: "telugu",
			name: "Telugu"
		},
		{
			id: "korean",
			name: "Korean"
		},
		{
			id: "tibetan",
			name: "Tibetan"
		},
		{
			id: "japanese",
			name: "Japanese"
		},
		{
			id: "chinese-simplified",
			name: "Chinese (Simplified)"
		},
		{
			id: "chinese-hongkong",
			name: "Chinese (Hongkong)"
		},
		{
			id: "chinese-traditional",
			name: "Chinese (Traditional)"
		},
		{
			id: "myanmar",
			name: "Myanmar"
		}
	];
	var google = {
		name: name$2,
		fonts: fonts$1,
		categories: categories,
		languages: languages
	};

	var fonts$2 = [system, google];

	var state = {
	  // 0 - uninitialized
	  // 1 - get, load
	  // 2 - set, send
	  // 3 - error
	  // 4 - ready
	  status: 0,
	  changed: false,
	  tracking: true,
	  // to avoid unnecessary preview updates
	  panels: {},
	  values: {},
	  variables: {},
	  vars: {},
	  styles: {},
	  imports: {},
	  fonts: fonts$2
	};
	var store = {
	  namespaced: true,
	  state: state,
	  getters: getters,
	  actions: actions,
	  mutations: mutations
	};

	//
	var script$z = {
	  components: {
	    StylesFields: __vue_component__$w
	  },
	  props: ['config'],
	  // revise later
	  computed: vuex.mapGetters('styles', ['values', 'fields', 'changed', 'tracking', 'autoApply']),
	  watch: {
	    tracking: function tracking(val, oldVal) {
	      var _this = this;

	      if (val === oldVal) {
	        return;
	      }

	      if (val) {
	        this.unwatch = this.$watch('values', debounce(function () {
	          if (_this.autoApply) {
	            _this.$store.dispatch('styles/set');
	          } else {
	            _this.$store.commit('styles/setState', {
	              name: 'changed',
	              value: true
	            });
	          }
	        }, 50), {
	          deep: true
	        });
	      } else {
	        isFunction(this.unwatch) && this.unwatch();
	        this.unwatch = null;
	      }
	    }
	  },
	  beforeCreate: function beforeCreate() {
	    isUndefined(this.$store.state.styles) && this.$store.registerModule('styles', store);
	  },
	  mounted: function mounted() {
	    this.$sticky = new Vue({
	      parent: this,
	      "extends": __vue_component__$x
	    }).$mount();
	    $('.customizer-sidebar-content').appendChild(this.$sticky.$el);
	    this.$store.dispatch('styles/get');
	  },
	  beforeDestroy: function beforeDestroy() {
	    var _this2 = this;

	    var _final = function _final() {
	      _this2.$sticky && _this2.$sticky.$destroy();

	      _this2.$store.dispatch('styles/clear');
	    };

	    this.changed ? this.$modal(__vue_component__$y, null, {
	      bgClose: false,
	      escClose: false
	    }).show({
	      width: 'xlarge'
	    })["finally"](_final) : _final();
	  }
	};

	/* script */
	var __vue_script__$z = script$z;
	/* template */

	var __vue_render__$z = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("StylesFields", {
	    attrs: {
	      config: {
	        fields: _vm.fields
	      },
	      values: _vm.values
	    }
	  });
	};

	var __vue_staticRenderFns__$z = [];
	__vue_render__$z._withStripped = true;
	/* style */

	var __vue_inject_styles__$z = undefined;
	/* scoped */

	var __vue_scope_id__$z = undefined;
	/* module identifier */

	var __vue_module_identifier__$z = undefined;
	/* functional template */

	var __vue_is_functional_template__$z = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$z = normalizeComponent({
	  render: __vue_render__$z,
	  staticRenderFns: __vue_staticRenderFns__$z
	}, __vue_inject_styles__$z, __vue_script__$z, __vue_scope_id__$z, __vue_is_functional_template__$z, __vue_module_identifier__$z, false, undefined, undefined, undefined);

	/**
	 * Plugin class
	 */
	var Plugin = {
	  install: function install(Vue) {
	    if (this.installed) {
	      return;
	    }

	    Util(Vue);
	    Vue.component('styles', __vue_component__$z);
	  },
	  version: '1.4.2'
	};

	/**
	 * Install plugin
	 */

	if (typeof window !== 'undefined' && window.Vue) {
	  window.Vue.use(Plugin);
	}

	return Plugin;

})));
