<?php
/**
 * Created by Echo-company
 * Email: info@echo-company.ru
 * Site: http://www.echo-company.ru
 */

function escapedHexToHex($escaped)
{
    return chr(hexdec($escaped[1]));
}

function escapedOctDec($escaped)
{
    return chr(octdec($escaped[1]));
}


class securityMalwareDetector
{

    //Ограничение времени выполнения
    public $max_duration;

    //Пропускать большие файлы
    public $max_filesize;

    //Время запуска скрипта
    public $script_start;

    public function __construct($scan)
    {
        $this->script_start = time();

        $this->found=array();
        $this->id_scan = $scan['id'];

        $this->tempdir = wa()->getDataPath('scan_'.$this->id_scan);
        $this->list_file = $this->tempdir . '/filelist.txt';
        $this->list_skip = (int)$scan['count_scan'];
        $this->count_files = $scan['count_files'];
        $this->count_signature = $scan['count_signature'];


        if (!function_exists('escapedHexToHex')  || !function_exists('escapedOctDec')) {
            throw new Exception('escapedHexToHex или escapedOctDec отсутсвует!');
        }

        $settings = new waAppSettingsModel();
        $this->max_duration = (int)$settings->get('security','max_duration', 3);
        $this->max_filesize = (int)$settings->get('security','max_filesize', 3) * 1024 * 1024;

        $this->signatures = securityHelper::loadDatabase();
    }

    public function setInterval($delay)
    {
        $this->max_duration = $delay;
    }

    public function throwTimeout($filePath)
    {
        throw new Exception(_w('Ошибка ограничения времени при сканирование: ').$filePath);
    }

    public function normalizeContent($content)
    {
        $content = preg_replace_callback('/\\\\x([a-fA-F0-9]{1,2})/i', 'escapedHexToHex', $content); // strip hex ascii notation
        $content = preg_replace_callback('/\\\\([0-9]{1,3})/i', 'escapedOctDec', $content); // strip dec ascii notation
        $content = preg_replace('/[\'"]\s*?\.\s*?[\'"]/smi', '', $content); // concat fragmented strings
        $content = preg_replace('|/\*.*?\*/|smi', '', $content); // remove comments to detect fragmented pieces of malware
        return $content;
    }

    public function getFragment($content, $pos)
    {
        $maxChars = 60;
        $maxLen = strlen($content);
        $rightPos = min($pos + $maxChars, $maxLen);
        $minPos = max(0, $pos - $maxChars);

        $start = substr($content, 0, $pos);
        $start = str_replace('\r', '', $start);
        $lineNo = strlen($start) - strlen(str_replace("\n", '', $start)) + 1;

        $res = 'L' . $lineNo . ': ' . substr($content, $minPos, $pos - $minPos) .
            '@_MARKER_@' .
            substr($content, $pos, $rightPos - $pos - 1);

        return htmlspecialchars($res);
    }

    public function checkForValidPhp($content)
    {
        $len = strlen($content);
        $start = 0;
        $valid = false;

        while (($start = strpos($content, '<?', $start)) !== false) {
            $valid = true;
            $start++;
            $end = strpos($content, '?>', $start + 1);
            if ($end === false) {
                $end = $len;
            }

            while (++$start < $end) {
                $c = ord($content[$start]);
                if ($c < 9 || ($c >= 14 && $c <= 31) || $c == 11 || $c == 12) {
                    return false;
                }
            }
        }

        return $valid;
    }

    public function detectMalware($filePath)
    {
        $this->signature_index = 0;

        if (filesize($filePath) > $this->max_filesize) {
            return 'to_big';
        }

        if (!is_file($filePath)) {
            return 'no_file';
        }

        if (!is_readable($filePath)) {
            return 'no_read';
        }


        $fileExtension = pathinfo(basename($filePath), PATHINFO_EXTENSION);

        $needToScan = false;
        $extensions = array('ph' /* php, php3, phtml */, 'htm' /* htm, html */, 'txt', 'js', 'pl', 'cgi', 'py', 'bash', 'sh', 'xml', 'ssi', 'inc', 'pm', 'tpl', 'htaccess');
        foreach ($extensions as $scanExt) {
            if (strpos($fileExtension, $scanExt) !== false) {
                $needToScan = true;
                break;
            }
        }

        $content = file_get_contents($filePath);
        if ($content===false){
            return 'no_read';
        }

        $fileToBeScannedSignatureList = array(
            '<?php',
            '<?=',
            '#!/usr/',
            '#!/bin/',
            '#!/local/',
            'eval(',
            'assert(',
            'base64_decode('
        );

        if (!$needToScan) {
            foreach ($fileToBeScannedSignatureList as $scanSig) {
                if (strpos($content, $scanSig) !== false) {
                    $needToScan = true;
                    break;
                }
            }
        }

        if (!$needToScan && $this->checkForValidPhp($content)) {
            $needToScan = true;
        }

        if (!$needToScan) {
            return 'no_need_to_check';
        }

        $normalized = $this->normalizeContent($content);

        $detected = false;

        $attrId=false;
        $attrTitle='';
        $attrSeverity='';

        foreach ($this->signatures as $sig) {

            //Пропускаем уже обработанные сигнатуры
            if ($this->signature_index<$this->count_signature){
                $this->signature_index++;
                continue;
            }


            if (time() - $this->script_start > $this->max_duration) {
                return 'timeout';
            }

            $pos = -1;

            $sigContent = $sig[5];

            $attrId = $sig[0];
            $attrFormat = $sig[1];
            $attrSeverity = $sig[3];
            $attrTitle = $sig[4];

            //Только вирусы
            if ($attrSeverity=='w') continue;

            switch ($attrFormat) {

                case 're':
                    if ((preg_match('#(' . $sigContent . ')#smi', $content, $found, PREG_OFFSET_CAPTURE)) ||
                        (preg_match('#(' . $sigContent . ')#smi', $normalized, $found, PREG_OFFSET_CAPTURE))
                    ) {
                        $detected = true;
                        $pos = $found[0][1];
                        break 2;
                    }

                    break;
                case 'const':
                    if ((($pos = strpos($content, $sigContent)) !== false) ||
                        (($pos = strpos($normalized, $sigContent)) !== false)
                    ) {
                        $detected = true;
                        break 2;
                    }

                    break;
            }

            $this->signature_index++;
        }

        $this->signature_index = 0;
        $this->count_signature = 0;

        if ($detected) {
            $foundFragment = $this->getFragment($content, $pos);
            return array(
                'status'=>$attrSeverity,
                'fragment'=>$foundFragment,
                'signature_id'=>$attrId,
                'title'=> $attrTitle
            );
        }

        return 'not_found';
    }

    public function malwareScanRound()
    {
        $scan_model = new securityScansModel();

        if (!is_file($this->list_file) || !is_readable($this->list_file)) {
            throw new Exception('Невозможно открыть '.$this->list_file.' для сканирования');
        }

        $file_handle = @fopen($this->list_file, "r");

        if ($file_handle===false) {
            throw new Exception('Невозможно открыть '.$this->list_file.' для сканирования');
        }

        $line_index = 0;
        $last_file  = '';

        while (!feof($file_handle)) {
            $line = trim(fgets($file_handle));
            $line_index++;

            //Пропускаем уже обработанные файлы и пустые строки
            if (($line_index<=$this->list_skip)||(empty($line))){
                continue;
            }

            $p = strrpos($line, ' ');

            $filePath = substr($line, 0, $p);
            $fileHash = substr($line, $p + 1);

            //Пустое имя файла
            if (empty($filePath)) continue;

            $res = $this->detectMalware($filePath);

            //Обрабатываем результат сканирования
            //Массив - нашли вирус
            if (is_array($res)){

                $status = $res['status']=='w' ? securityHelper::RESULT_WARNING : securityHelper::RESULT_DANGER;

                $result = securityHelper::ERROR_FOUND;
                
                switch ($res['title']) {
                    case 'WebShell':
                        $result = securityHelper::ERROR_FOUND_SHELl;
                        break;
                    case 'JS Virus':
                        $result = securityHelper::ERROR_FOUND_VIRUS;
                        break;
                    case 'Suspicious Code':
                        $result = securityHelper::ERROR_FOUND_CODE;
                        break;
                }

                $found = securityResultModel::push($this->id_scan, $filePath, $status, $result,
                            filesize($filePath), $res['fragment'], $res['signature_id']);

                $this->found[$found['id']] = $found;

            }else {

                switch ($res) {
                    case 'to_big':
                        $found = securityResultModel::push($this->id_scan, $filePath,
                            securityHelper::RESULT_WARNING,
                            securityHelper::ERROR_TO_BIG,
                            filesize($filePath)
                        );
                        $this->found[$found['id']] = $found;
                        break;

                    case 'no_file':
                    case 'no_need_to_check':
                    case 'not_found':
                        break;

                    case 'no_read':
                        $found = securityResultModel::push($this->id_scan, $filePath,
                            securityHelper::RESULT_WARNING,
                            securityHelper::ERROR_NO_READ);
                        $this->found[$found['id']] = $found;
                        break;

                    case 'timeout':

                        //Сохряняем позицию сканирования одного файла
                        $scan_model->updateById($this->id_scan, array('count_scan'=>$line_index-1, 'count_signature'=>$this->signature_index));
                        $last_file = $filePath;

                        break 2;
                }
            }

            //Сохряняем позицию
            $scan_model->updateById($this->id_scan, array('count_scan'=>$line_index, 'count_signature'=>$this->signature_index));
            $last_file = $filePath;

            //Выходим из цикла
            $executionTime = time() - $this->script_start;
            if ($executionTime >= round($this->max_duration * 0.8)) {
                break;
            }
        }
        fclose($file_handle);

        $data = array(
            'count_scan' => $line_index,
            'count_files'=> $this->count_files,
            'last_file'  => $last_file,
            'status'     => empty($last_file) ? 'finished' :'inProcess'
        );

        if (!empty($this->found)){
            $this->found = array_reverse($this->found);
            $view = wa()->getView();
            $view->assign('founds',$this->found);
            $data['found']  = $view->fetch(wa()->getAppPath('templates/actions/backend/BackendFound.html'));
        }

        return $data;
    }

    public function convert_database(){
        $projectRootDir = wa()->getAppPath();
        $this->SIGNATURE_FILENAME = $projectRootDir . '/lib/data/signatures/malware_db.xml';
        $this->signatures = new DOMDocument();
        $this->signatures->load($this->SIGNATURE_FILENAME);

        $db = $this->signatures->getElementsByTagName('signature');

        foreach ($db as $sig) {
            $sigContent = $sig->nodeValue;
            $attr = $sig->attributes;
            $attrId = $attr->getNamedItem('id')->nodeValue;
            $attrFormat = $attr->getNamedItem('format')->nodeValue;
            $attrChildId = $attr->getNamedItem('child_id')->nodeValue;
            $attrSeverity = $attr->getNamedItem('sever')->nodeValue;
            $attrTitle = $attr->getNamedItem('title')->nodeValue;

            $lines[] =
                implode(";",array($attrId,$attrFormat,$attrChildId,$attrSeverity,$attrTitle, base64_encode($sigContent)));
        }

        $lines = implode("\n",$lines);

        file_put_contents($projectRootDir . '/lib/data/signatures/malware_db.dat', $lines);
    }

} // End of class
